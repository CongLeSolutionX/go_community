{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8a504d14_6730c903",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T15:36:01Z",
      "side": 1,
      "message": "This should be checking the alignment of t since that is the type of the target being stored to. val is the value to be stored.",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92ffe3e5_a4cf04d7",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-01-08T15:45:09Z",
      "side": 1,
      "message": "Hmm, I\u0027m confused. If that\u0027s the case, then the rule is previously working wrong. As you said in my CL, the check for int64 and pointer type make the alignment check un-necessary. But that check is done on \"val.Type\", not \"t\".",
      "parentUuid": "8a504d14_6730c903",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1e3fd1d_0b4eb13a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 36863
      },
      "writtenOn": "2021-01-08T15:49:40Z",
      "side": 1,
      "message": "For my curiosity, when would such an unaligned store be created? Notably, power8/power9 handle unaligned gpr memory operations reasonably well.",
      "parentUuid": "8a504d14_6730c903",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38cacf4c_97df4e32",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T16:59:11Z",
      "side": 1,
      "message": "For the previous rules, I was thinking that if val was int64 or pointer, then it must be storing to the same type and those would have the correct alignment. Before it was correct but more restrictive than necessary. However now that it is only checking the alignment it should check the alignment of the target to be correct in all cases. Is there a case where the alignment of val and the store target are different? Maybe not, but sometimes the unexpected can happen and this should be correct.",
      "parentUuid": "c1e3fd1d_0b4eb13a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b50d97c7_1bf5450a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 7061
      },
      "writtenOn": "2021-01-08T17:43:42Z",
      "side": 1,
      "message": "So just to clarify, this would be a risk-reducing improvement?\n\n(Store {t} ptr val mem) \u0026\u0026 t.Size() \u003d\u003d 8 \u0026\u0026\n    val.Type.Alignment()%4 \u003d\u003d 0 \u0026\u0026 t.Alignment()%4 \u003d\u003d 0\u003d\u003e\n       (MOVDstore ptr val mem)",
      "parentUuid": "38cacf4c_97df4e32",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cb03c5f_a4721c49",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T18:48:14Z",
      "side": 1,
      "message": "In ppc64/ssa.go where MOVDstore is processed, val is a register value and a call is made to AddAux to determine the constant offset that needs to be encoded in the store instruction based on the location of the target. This constant offset must be a multiple of 4 or the assembler will fail. I\u0027m not seeing how the alignment of val\u0027s data has any effect but checking it probably doesn\u0027t hurt because most likely they are always the same?",
      "parentUuid": "b50d97c7_1bf5450a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3451fb99_41f305dd",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T17:13:14Z",
      "side": 1,
      "message": "Hmmm, I\u0027m confused. What happened if t.Size() \u003d\u003d 8 but the alignment is not a multiple of 4? In the current form of this CL it won\u0027t be lowered, so ICE.\n\nI agree with Lynn that the alignment doesn\u0027t seem to matter. So maybe we could just remove that clause.",
      "parentUuid": "0cb03c5f_a4721c49",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fd98628_18daaa3a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-01-11T17:38:06Z",
      "side": 1,
      "message": "IIUC, the alignment of val.Type does not matter, but the alignment of t does.",
      "parentUuid": "3451fb99_41f305dd",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b15ac77_3b3428ad",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T18:09:37Z",
      "side": 1,
      "message": "Why the alignment of t matters?",
      "parentUuid": "5fd98628_18daaa3a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0eb8b278_4b1d7e96",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-11T18:57:23Z",
      "side": 1,
      "message": "Yes, Cuong is correct. The alignment of t matters because the MOVDstore generates a DS form instruction which requires that the offset be a multiple of 4. Cherry had a fix for a similar problem in CL 216379 about a year ago. Unless we are always sure that if the size is 8 the alignment must be 4? (Which I think Paul was asking earlier.) \n\nTo answer the other question, if the size is 8 and alignment is not 4 then I think it could do a MOVDstoreidx where the ptr is a MOVDaddr for the entire address and the idx is 0. I\u0027d have to test that out to be sure that rule works like I think it would. There are other similar rules in that file now.",
      "parentUuid": "8b15ac77_3b3428ad",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e8c4205_ccff7d2a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T19:02:29Z",
      "side": 1,
      "message": "I understand the offset needs to be a multiple of 4. But alignment is not offset. I don\u0027t know why the alignment matters. In fact, the offset is 0 here.",
      "parentUuid": "0eb8b278_4b1d7e96",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79e28725_a7b56bc0",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-11T19:07:14Z",
      "side": 1,
      "message": "If you are guaranteed that the offset is always 0 then there is no problem, but that was not clear to me. I realize the alignment check is not exactly what we want for this general situation but if the alignment of the data is at least 4 then if a constant offset is needed it must also be a multiple of 4. Are you saying this rule will never be used for data on the stack, where the offset is never 0?",
      "parentUuid": "9e8c4205_ccff7d2a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f904be6_08e0205f",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T19:19:18Z",
      "side": 1,
      "message": "For this particular rule, the offset is always 0, as there is no square bracket on the RHS of the rule.\n\nLater on, other optimizations may fold offsets into the store instruction, e.g.\n\n(MOVDstore [off1] {sym} (ADDconst [off2] x) val mem) \u0026\u0026 is16Bit(off1+off2) \u0026\u0026 (off1+off2)%4 \u003d\u003d 0 -\u003e (MOVDstore [off1+off2] {sym} x val mem)\n\nThose rules should check that the folded offset is a multiple of 4, which is what CL 216379 does.",
      "parentUuid": "79e28725_a7b56bc0",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b26a6192_59c6e619",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-11T19:36:37Z",
      "side": 1,
      "message": "I\u0027m referring to the offset that is computed by AddAux2 which not explicitly represented in the rule but gets added into the offset field of the ppc64 instruction.",
      "parentUuid": "6f904be6_08e0205f",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d526d862_5a532052",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T19:49:19Z",
      "side": 1,
      "message": "This rule doesn\u0027t have any Aux. So AddAux2 doesn\u0027t do anything.\n\nIf a later rule adds an Aux, that rule should be responsible to make it correct.",
      "parentUuid": "b26a6192_59c6e619",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "919a077a_8a83b63b",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-11T19:56:28Z",
      "side": 1,
      "message": "{name: \"MOVDstore\", argLength: 3, reg: gpstore, asm: \"MOVD\", aux: \"SymOff\", typ: \"Mem\", faultOnNilArg0: true, symEffect: \"Write\"}, // store 8 bytes",
      "parentUuid": "d526d862_5a532052",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96167663_def85313",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T19:57:57Z",
      "side": 1,
      "message": "That just means MOVDstore _can_ have an Aux. This particular rule doesn\u0027t make one.",
      "parentUuid": "919a077a_8a83b63b",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa7d9697_6ffc3b2c",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-11T23:15:38Z",
      "side": 1,
      "message": "Hmm so I\u0027ve misunderstood the way aux: symOff is supposed to work... But then I don\u0027t understand where the offset gets filled in when it is needed. If you look through our rules file, all the rules with MOVDstore on the right check the alignment and those were put in because without them failures occurred.",
      "parentUuid": "96167663_def85313",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d33cbc3_aa10992c",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T23:34:49Z",
      "side": 1,
      "message": "For example, this rule\n\n(MOVDstore [off1] {sym} (ADDconst [off2] x) val mem) \u0026\u0026 is16Bit(off1+off2) \u0026\u0026 (off1+off2)%4 \u003d\u003d 0 -\u003e (MOVDstore [off1+off2] {sym} x val mem)\n\nIt will produce a MOVDstore with an offset. In particular, if the MOVDstore on the LHS may have no offset (off1\u003d\u003d0), the MOVDstore on the RHS gets an offset from the ADDconst.",
      "parentUuid": "fa7d9697_6ffc3b2c",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}