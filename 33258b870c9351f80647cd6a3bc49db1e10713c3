{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8a504d14_6730c903",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T15:36:01Z",
      "side": 1,
      "message": "This should be checking the alignment of t since that is the type of the target being stored to. val is the value to be stored.",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92ffe3e5_a4cf04d7",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-01-08T15:45:09Z",
      "side": 1,
      "message": "Hmm, I\u0027m confused. If that\u0027s the case, then the rule is previously working wrong. As you said in my CL, the check for int64 and pointer type make the alignment check un-necessary. But that check is done on \"val.Type\", not \"t\".",
      "parentUuid": "8a504d14_6730c903",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1e3fd1d_0b4eb13a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 36863
      },
      "writtenOn": "2021-01-08T15:49:40Z",
      "side": 1,
      "message": "For my curiosity, when would such an unaligned store be created? Notably, power8/power9 handle unaligned gpr memory operations reasonably well.",
      "parentUuid": "8a504d14_6730c903",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38cacf4c_97df4e32",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T16:59:11Z",
      "side": 1,
      "message": "For the previous rules, I was thinking that if val was int64 or pointer, then it must be storing to the same type and those would have the correct alignment. Before it was correct but more restrictive than necessary. However now that it is only checking the alignment it should check the alignment of the target to be correct in all cases. Is there a case where the alignment of val and the store target are different? Maybe not, but sometimes the unexpected can happen and this should be correct.",
      "parentUuid": "c1e3fd1d_0b4eb13a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b50d97c7_1bf5450a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 7061
      },
      "writtenOn": "2021-01-08T17:43:42Z",
      "side": 1,
      "message": "So just to clarify, this would be a risk-reducing improvement?\n\n(Store {t} ptr val mem) \u0026\u0026 t.Size() \u003d\u003d 8 \u0026\u0026\n    val.Type.Alignment()%4 \u003d\u003d 0 \u0026\u0026 t.Alignment()%4 \u003d\u003d 0\u003d\u003e\n       (MOVDstore ptr val mem)",
      "parentUuid": "38cacf4c_97df4e32",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cb03c5f_a4721c49",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T18:48:14Z",
      "side": 1,
      "message": "In ppc64/ssa.go where MOVDstore is processed, val is a register value and a call is made to AddAux to determine the constant offset that needs to be encoded in the store instruction based on the location of the target. This constant offset must be a multiple of 4 or the assembler will fail. I\u0027m not seeing how the alignment of val\u0027s data has any effect but checking it probably doesn\u0027t hurt because most likely they are always the same?",
      "parentUuid": "b50d97c7_1bf5450a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}