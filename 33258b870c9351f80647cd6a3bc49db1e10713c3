{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8a504d14_6730c903",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T15:36:01Z",
      "side": 1,
      "message": "This should be checking the alignment of t since that is the type of the target being stored to. val is the value to be stored.",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92ffe3e5_a4cf04d7",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-01-08T15:45:09Z",
      "side": 1,
      "message": "Hmm, I\u0027m confused. If that\u0027s the case, then the rule is previously working wrong. As you said in my CL, the check for int64 and pointer type make the alignment check un-necessary. But that check is done on \"val.Type\", not \"t\".",
      "parentUuid": "8a504d14_6730c903",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1e3fd1d_0b4eb13a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 36863
      },
      "writtenOn": "2021-01-08T15:49:40Z",
      "side": 1,
      "message": "For my curiosity, when would such an unaligned store be created? Notably, power8/power9 handle unaligned gpr memory operations reasonably well.",
      "parentUuid": "8a504d14_6730c903",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38cacf4c_97df4e32",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T16:59:11Z",
      "side": 1,
      "message": "For the previous rules, I was thinking that if val was int64 or pointer, then it must be storing to the same type and those would have the correct alignment. Before it was correct but more restrictive than necessary. However now that it is only checking the alignment it should check the alignment of the target to be correct in all cases. Is there a case where the alignment of val and the store target are different? Maybe not, but sometimes the unexpected can happen and this should be correct.",
      "parentUuid": "c1e3fd1d_0b4eb13a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b50d97c7_1bf5450a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 7061
      },
      "writtenOn": "2021-01-08T17:43:42Z",
      "side": 1,
      "message": "So just to clarify, this would be a risk-reducing improvement?\n\n(Store {t} ptr val mem) \u0026\u0026 t.Size() \u003d\u003d 8 \u0026\u0026\n    val.Type.Alignment()%4 \u003d\u003d 0 \u0026\u0026 t.Alignment()%4 \u003d\u003d 0\u003d\u003e\n       (MOVDstore ptr val mem)",
      "parentUuid": "38cacf4c_97df4e32",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cb03c5f_a4721c49",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-08T18:48:14Z",
      "side": 1,
      "message": "In ppc64/ssa.go where MOVDstore is processed, val is a register value and a call is made to AddAux to determine the constant offset that needs to be encoded in the store instruction based on the location of the target. This constant offset must be a multiple of 4 or the assembler will fail. I\u0027m not seeing how the alignment of val\u0027s data has any effect but checking it probably doesn\u0027t hurt because most likely they are always the same?",
      "parentUuid": "b50d97c7_1bf5450a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3451fb99_41f305dd",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T17:13:14Z",
      "side": 1,
      "message": "Hmmm, I\u0027m confused. What happened if t.Size() \u003d\u003d 8 but the alignment is not a multiple of 4? In the current form of this CL it won\u0027t be lowered, so ICE.\n\nI agree with Lynn that the alignment doesn\u0027t seem to matter. So maybe we could just remove that clause.",
      "parentUuid": "0cb03c5f_a4721c49",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fd98628_18daaa3a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-01-11T17:38:06Z",
      "side": 1,
      "message": "IIUC, the alignment of val.Type does not matter, but the alignment of t does.",
      "parentUuid": "3451fb99_41f305dd",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b15ac77_3b3428ad",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T18:09:37Z",
      "side": 1,
      "message": "Why the alignment of t matters?",
      "parentUuid": "5fd98628_18daaa3a",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0eb8b278_4b1d7e96",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 6320
      },
      "writtenOn": "2021-01-11T18:57:23Z",
      "side": 1,
      "message": "Yes, Cuong is correct. The alignment of t matters because the MOVDstore generates a DS form instruction which requires that the offset be a multiple of 4. Cherry had a fix for a similar problem in CL 216379 about a year ago. Unless we are always sure that if the size is 8 the alignment must be 4? (Which I think Paul was asking earlier.) \n\nTo answer the other question, if the size is 8 and alignment is not 4 then I think it could do a MOVDstoreidx where the ptr is a MOVDaddr for the entire address and the idx is 0. I\u0027d have to test that out to be sure that rule works like I think it would. There are other similar rules in that file now.",
      "parentUuid": "8b15ac77_3b3428ad",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e8c4205_ccff7d2a",
        "filename": "src/cmd/compile/internal/ssa/gen/PPC64.rules",
        "patchSetId": 4
      },
      "lineNbr": 582,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-01-11T19:02:29Z",
      "side": 1,
      "message": "I understand the offset needs to be a multiple of 4. But alignment is not offset. I don\u0027t know why the alignment matters. In fact, the offset is 0 here.",
      "parentUuid": "0eb8b278_4b1d7e96",
      "revId": "33258b870c9351f80647cd6a3bc49db1e10713c3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}