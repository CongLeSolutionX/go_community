{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "59236899_1f09c740",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-25T02:38:58Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003de637260e\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4150859a_9ac8a6dd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-25T02:43:55Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003de637260e\nFailed on linux-386: https://storage.googleapis.com/go-build-log/e637260e/linux-386_d35ed4d8.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "59236899_1f09c740",
      "tag": "autogenerated:trybots~progress",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fb9d621_e875de6f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-25T02:50:12Z",
      "side": 1,
      "message": "2 of 45 TryBots failed.\nFailed on linux-386: https://storage.googleapis.com/go-build-log/e637260e/linux-386_d35ed4d8.log\nFailed on windows-386-2016: https://storage.googleapis.com/go-build-log/e637260e/windows-386-2016_7348ea72.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\n",
      "parentUuid": "59236899_1f09c740",
      "tag": "autogenerated:trybots~failed",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69663622_ee684c6e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-06-25T03:11:45Z",
      "side": 1,
      "message": "Hi Cherry, this CL adds a parser for arm64 xml instruction documents, which can automatically generate four files instructions.go, ops.go, arm64ops.go and elements.go, which can be used for encoding and decoding arm64 instructions. Encoding and decoding of elements is not done yet, as this needs to be consistent with ruinan\u0027s refactoring to obj.Addr. In addition, I would like to ask for your views on the following problem.\nNormally, a Prog matches one machine instruction, but now I find that a Prog may match multiple arm64 machine instructions, because I find that there are many instructions that are difficult to distinguish under the existing matching mechanism. There are hundreds of such instructions, here are a few examples:\n\nLD1H  { \u003cZt\u003e.S }, \u003cPg\u003e/Z, [\u003cXn|SP\u003e, \u003cZm\u003e.S, \u003cmod\u003e #1]\nLD1H  { \u003cZt\u003e.D }, \u003cPg\u003e/Z, [\u003cXn|SP\u003e, \u003cZm\u003e.D, \u003cmod\u003e]\n\nASR  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.\u003cT\u003e\nASR  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.D\n\nLSL  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.\u003cT\u003e\nLSL  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.D\n\nMOV  \u003cZd\u003e.\u003cT\u003e, #\u003cconst\u003e\nMOV  \u003cZd\u003e.\u003cT\u003e, #\u003cimm\u003e{, \u003cshift\u003e}\n\nCurrently in Go, we use Go opcode and argument classes to match, but according to the current naming and classification rules, the opcode and argument classes of these instructions are exactly the same. So a Prog will match multiple arm64 instructions.\n\nThere are two solutions to this problem. One is to define more differentiated opcodes and argument classes so that a Prog can only match one machine instruction. The other is to allow multiple matches and find the real match during encoding. This is feasible because there will only be one match in the end.\n\nAt present, I am inclined to the second approach. This CL is also implemented in this way, because the naming of opcodes and the classification of arguments will be easier. Since the instruction table is automatically generated, the first method is actually very difficult.\n\nHow do you think about this problem? If you also agree with me, then I will continue with the work as planned and implement the encoding and decoding of more elements.",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}