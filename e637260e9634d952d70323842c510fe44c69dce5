{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "59236899_1f09c740",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-25T02:38:58Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003de637260e\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4150859a_9ac8a6dd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-25T02:43:55Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003de637260e\nFailed on linux-386: https://storage.googleapis.com/go-build-log/e637260e/linux-386_d35ed4d8.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "59236899_1f09c740",
      "tag": "autogenerated:trybots~progress",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fb9d621_e875de6f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-25T02:50:12Z",
      "side": 1,
      "message": "2 of 45 TryBots failed.\nFailed on linux-386: https://storage.googleapis.com/go-build-log/e637260e/linux-386_d35ed4d8.log\nFailed on windows-386-2016: https://storage.googleapis.com/go-build-log/e637260e/windows-386-2016_7348ea72.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\n",
      "parentUuid": "59236899_1f09c740",
      "tag": "autogenerated:trybots~failed",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69663622_ee684c6e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-06-25T03:11:45Z",
      "side": 1,
      "message": "Hi Cherry, this CL adds a parser for arm64 xml instruction documents, which can automatically generate four files instructions.go, ops.go, arm64ops.go and elements.go, which can be used for encoding and decoding arm64 instructions. Encoding and decoding of elements is not done yet, as this needs to be consistent with ruinan\u0027s refactoring to obj.Addr. In addition, I would like to ask for your views on the following problem.\nNormally, a Prog matches one machine instruction, but now I find that a Prog may match multiple arm64 machine instructions, because I find that there are many instructions that are difficult to distinguish under the existing matching mechanism. There are hundreds of such instructions, here are a few examples:\n\nLD1H  { \u003cZt\u003e.S }, \u003cPg\u003e/Z, [\u003cXn|SP\u003e, \u003cZm\u003e.S, \u003cmod\u003e #1]\nLD1H  { \u003cZt\u003e.D }, \u003cPg\u003e/Z, [\u003cXn|SP\u003e, \u003cZm\u003e.D, \u003cmod\u003e]\n\nASR  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.\u003cT\u003e\nASR  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.D\n\nLSL  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.\u003cT\u003e\nLSL  \u003cZdn\u003e.\u003cT\u003e, \u003cPg\u003e/M, \u003cZdn\u003e.\u003cT\u003e, \u003cZm\u003e.D\n\nMOV  \u003cZd\u003e.\u003cT\u003e, #\u003cconst\u003e\nMOV  \u003cZd\u003e.\u003cT\u003e, #\u003cimm\u003e{, \u003cshift\u003e}\n\nCurrently in Go, we use Go opcode and argument classes to match, but according to the current naming and classification rules, the opcode and argument classes of these instructions are exactly the same. So a Prog will match multiple arm64 instructions.\n\nThere are two solutions to this problem. One is to define more differentiated opcodes and argument classes so that a Prog can only match one machine instruction. The other is to allow multiple matches and find the real match during encoding. This is feasible because there will only be one match in the end.\n\nAt present, I am inclined to the second approach. This CL is also implemented in this way, because the naming of opcodes and the classification of arguments will be easier. Since the instruction table is automatically generated, the first method is actually very difficult.\n\nHow do you think about this problem? If you also agree with me, then I will continue with the work as planned and implement the encoding and decoding of more elements.",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0b8c0f7_d5c0fabc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-07-05T14:59:51Z",
      "side": 1,
      "message": "Thanks for getting the XML parser working! I\u0027ll take a detailed look.\n\nDo you mean that these instructions have the same semantics and it is correct to use either one? If so, I think your approach is fine and we just need to pick one to encode. Thanks.",
      "parentUuid": "69663622_ee684c6e",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70115146_7bdb45bf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-07-06T08:15:30Z",
      "side": 1,
      "message": "It should be said that these instructions have similar but not identical semantics . For example, the following two instructions have same function but operate on different data widths, the arrangements are S (32-bit) and D (64-bit) respectively.\n\n  LDFF1W  { \u003cZt\u003e.S }, \u003cPg\u003e/Z, [\u003cXn|SP\u003e, \u003cZm\u003e.S, \u003cmod\u003e #2]\n  LDFF1W  { \u003cZt\u003e.D }, \u003cPg\u003e/Z, [\u003cXn|SP\u003e, \u003cZm\u003e.D, \u003cmod\u003e #2]\n\nAs for why they are defined as two instructions, honestly I don\u0027t know.\n\nSo it is not to say that we can pick either instruction to encode. We need a way to find the right match.\n\nThe method I mentioned above (checking while encoding the element) can handle some of these cases, but not all of them.\n\nIn addition, since \"S\" and \"D\" are string constants and do not participate in encoding, if the user writes a different value, say \"B\", we need to be able to check it out. I haven\u0027t figured out how to do this check yet. This is another problem.\n\nConsidering these two problems, maybe we need to record the arrangement constant when parsing the XML files and save it in the instruction table. Or we implement these difficult instructions through the old optab.",
      "parentUuid": "e0b8c0f7_d5c0fabc",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7cd1ef9_5729609e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-07-14T03:16:49Z",
      "side": 1,
      "message": "I used another method, that is creating a rule for constant symbols. Now I think we can distinguish any two instructions unless we really can pick any one to encode, this doesn\u0027t matter.",
      "parentUuid": "70115146_7bdb45bf",
      "revId": "e637260e9634d952d70323842c510fe44c69dce5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}