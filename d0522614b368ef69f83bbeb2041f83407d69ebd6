{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e2132779_cb139698",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-09T00:07:35Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dd0522614\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d0522614b368ef69f83bbeb2041f83407d69ebd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c810b110_9fb3d279",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-06-09T00:21:03Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "e2132779_cb139698",
      "tag": "autogenerated:trybots~happy",
      "revId": "d0522614b368ef69f83bbeb2041f83407d69ebd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2d21677_a85b37bf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 7392
      },
      "writtenOn": "2023-06-12T16:16:07Z",
      "side": 1,
      "message": "PTAL",
      "revId": "d0522614b368ef69f83bbeb2041f83407d69ebd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d374b84c_84cd042a",
        "filename": "src/go/types/unify.go",
        "patchSetId": 5
      },
      "lineNbr": 705,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-06-12T15:37:57Z",
      "side": 1,
      "message": "This comment should say why.\n\nI think we don\u0027t know why. I tried a bunch to produce a counter example, and couldn\u0027t. At this point x is a type parameter that is not being unified. If y is a named type, then it shouldn\u0027t actually unify with a type parameter from an outer scope, no? The type parameter will by definition have a type set that is larger than just the named type...\n\nI\u0027ll +2 to get things moving, but I think this comment should either explain precisely why we don\u0027t use mode, or admit that we\u0027re not sure or are being defensive.",
      "range": {
        "startLine": 705,
        "startChar": 31,
        "endLine": 705,
        "endChar": 64
      },
      "revId": "d0522614b368ef69f83bbeb2041f83407d69ebd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5d77b9e_28fdb95b",
        "filename": "src/go/types/unify.go",
        "patchSetId": 5
      },
      "lineNbr": 705,
      "author": {
        "id": 7392
      },
      "writtenOn": "2023-06-12T16:16:07Z",
      "side": 1,
      "message": "The primary reason is the comment before: the core type is always an underlying type. If y is a defined type, the match will fail if we use exact notification. Inexact notification will automatically consider the underlying type.\n\nBut thinking of this, we should be using the mode assign in this case. We only want to be inexact at the top, at most.\n\nExpanded the comment.\n\nGoing forward, I think this code can be improved substantially, for 1.22.",
      "parentUuid": "d374b84c_84cd042a",
      "range": {
        "startLine": 705,
        "startChar": 31,
        "endLine": 705,
        "endChar": 64
      },
      "revId": "d0522614b368ef69f83bbeb2041f83407d69ebd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}