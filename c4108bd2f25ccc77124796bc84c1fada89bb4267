{
  "comments": [
    {
      "key": {
        "uuid": "fef500c2_84960713",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 17
      },
      "lineNbr": 885,
      "author": {
        "id": 5167
      },
      "writtenOn": "2018-10-15T14:41:15Z",
      "side": 1,
      "message": "Oh no, this is still wrong. Suppose the physical page size is 64K and we have two spans that go from 0 to 32K and 32K to 64K. We free the span at 0 and eventually scavenge it, but its gets \"rounded-in\" so we actually don\u0027t free any pages, but scavenged gets set. Then we free the span at 32K. Since we want to merge it with the neighboring span, we\u0027ll scavenge it too, but again release no pages. However, the merged span will cover the whole physical page. So if we then try to allocate it, we\u0027ll sysUsed the whole page here and add 64K to heap_released, even though nothing was subtracted from heap_released.\n\nMaybe when we\u0027re merging spans and scavenging a neighbor we need to round *out* whichever side of the unscavenged span has the scavenged neighbor? I think that would be enough to balance the heap_released stat, and would have the advantage of not retaining pages in the middle of otherwise scavenged regions (which can happen right now, though we\u0027ll get the stats right at the moment).",
      "revId": "c4108bd2f25ccc77124796bc84c1fada89bb4267",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e97d127_8159821a",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 17
      },
      "lineNbr": 885,
      "author": {
        "id": 5167
      },
      "writtenOn": "2018-10-15T18:00:23Z",
      "side": 1,
      "message": "Actually, I think what you want is something like this:\n\nSuppose you\u0027re merging spans A and B where A is lower in the address space and A is already scavenged, but B is not. Given\n\naStart, aEnd :\u003d A.physPageBounds()\nbStart, bEnd :\u003d B.physPageBounds()\n\nScavenge [aEnd, bEnd) rather than the more obvious but wrong [bStart, bEnd). But be careful if A or B don\u0027t cover a page boundary at all.",
      "parentUuid": "fef500c2_84960713",
      "revId": "c4108bd2f25ccc77124796bc84c1fada89bb4267",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc5df39e_e6168eec",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 17
      },
      "lineNbr": 885,
      "author": {
        "id": 25391
      },
      "writtenOn": "2018-10-15T19:54:02Z",
      "side": 1,
      "message": "actually, I do want to correct one thing: scavenged _doesn\u0027t_ always get set (if it doesn\u0027t cover a full page, it doesn\u0027t get set), so it\u0027s actually possible for an unscavenged span to end up in scav in both scavenge1 and scavengeLargest. I\u0027ve fixed that in the change below (scavenge1), in the change above (scavengeLargest).\n\nhowever, given those fixes, the code as written is still correct with respect to your example (I think). when we try to scavenge the span at 0, it will fail because it\u0027s not of a proper size, so it gets merged with the neighboring one, and the result will simply be considered unscavenged. I think this is OK. this \"scavenge-on-coalescing\" is sort of peripheral to the more eager scavenging scheme, so the outcomes not always leading to scavenging is probably OK.\n\nI did just think of another bug, though. consider a large, scavenged span merging with a small one that doesn\u0027t fully cover a page, but actually sits across a page boundary. the now-covered page SHOULD be scavenged, but currently its not, exactly because of the issue you raised.",
      "parentUuid": "3e97d127_8159821a",
      "revId": "c4108bd2f25ccc77124796bc84c1fada89bb4267",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9c2c7c7_f265d3db",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 17
      },
      "lineNbr": 885,
      "author": {
        "id": 25391
      },
      "writtenOn": "2018-10-15T22:13:34Z",
      "side": 1,
      "message": "attempted to solve all these issues by just keeping track of whether the whole new span should be scavenged in freeSpanLocked. it simplifies the code in freeSpanLocked a bit.\n\nwill modify the memstats test to ensure heap_released is being tracked correctly.",
      "parentUuid": "dc5df39e_e6168eec",
      "revId": "c4108bd2f25ccc77124796bc84c1fada89bb4267",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}