{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "cb332187_302f3c11",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-06-07T21:56:05Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003de06806d5",
      "tag": "autogenerated:trybots~beginning",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "14d103f8_5e73e18f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-06-07T22:07:02Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "cb332187_302f3c11",
      "tag": "autogenerated:trybots~happy",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2bde49a6_a3e3e86f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-06-08T03:36:22Z",
      "side": 1,
      "message": "Using convertibility does provide for possibly better UX in the common case, but there are some cases where it can lead to confusing behavior.\n\nFor example, converting int64(-1) to a uint64 will convert to a different value (i.e., -1 \u003d\u003e math.MaxUint64). Converting uint64(256) to a uint8 will lose precision (i.e., 256 \u003d\u003e 0). Perhaps we can considering treating it as a \"conversion\" error if the conversion results in a semantically different value. Similarly, conversion to/from int/uint types can be confusing when tests pass/fail depending on which architecture they\u0027re run on. For example, converting int64 to a int may or may not have precision loss depending on the system being 32-bit or 64-bit.\n\nConverting by default SGTM if you think these edge cases aren\u0027t a big deal.",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cc03192_7931327b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-06-09T22:31:54Z",
      "side": 1,
      "message": "I like the idea, and that\u0027s a good point. The problem I\u0027m running into is that I can\u0027t think of a way to do this without it being very messy (ie. lots of switch statements on types). I wasn\u0027t seeing anything in the reflect package or otherwise that would let us check whether the value is semantically different after converting it. I definitely welcome ideas (I at least added a TODO to consider it).",
      "parentUuid": "2bde49a6_a3e3e86f",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88666012_327fa3fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-06-15T18:22:04Z",
      "side": 1,
      "message": "Not super pretty, but this can be checked by round tripping the type conversion, and checking if the value still matches the original, e.g.\n\n  var original interface{}\n  original \u003d int64(1\u003c\u003c63 - 1)\n  var target int32\n\n  origVal :\u003d reflect.ValueOf(original)\n  origType :\u003d origVal.Type()\n\n  targetType :\u003d reflect.ValueOf(target).Type()\n\n  convertedVal, ok :\u003d convertToType(origVal, targetType)\n  if !ok {\n    panic(fmt.Sprintf(\"error converting %v to %v\", origType, targetType))\n  }\n\n  rtVal, ok :\u003d convertToType(convertedVal, origType)\n  if !ok {\n    panic(fmt.Sprintf(\"error converting %v to %v\", targetType, origType))\n  }\n\n  if rtVal.Interface() !\u003d origVal.Interface() {\n    panic(\"overflow\")\n  }",
      "parentUuid": "1cc03192_7931327b",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e18e4cc8_c522e98e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-06-15T18:40:00Z",
      "side": 1,
      "message": "I actually had basically this exact code in a previous iteration, and while it\u0027ll help in some cases, it didn\u0027t help for things like converting between int and uint. For example, if the code was\n\n  f.Add(-1)\n  f.Fuzz(func(*testing.T, uint64)) {  ... }\n \nThen it would end up converting it to the max uint64 value, then convert it back to -1, and appear the same in that last check ðŸ˜­\n\nThough you\u0027re right that the code you suggested could at least help with the loss of precision check (e.g. int64 to int32)",
      "parentUuid": "88666012_327fa3fe",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d6d8762_5374e4b2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-06-15T18:55:59Z",
      "side": 1,
      "message": "Oof, good point. It kind of feels like having a generic `reflect.Value.Overflows(reflect.Type)` would be nice :/\n\nSeems like the only way to actually guard against this now is either doing a gross switch, or having no guardrails at all.",
      "parentUuid": "e18e4cc8_c522e98e",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "059ffccc_05ae94cf",
        "filename": "src/internal/fuzz/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 710,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-06-08T03:36:22Z",
      "side": 1,
      "message": "s/excpeted/expected/",
      "range": {
        "startLine": 710,
        "startChar": 48,
        "endLine": 710,
        "endChar": 56
      },
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8bcb680e_79810b30",
        "filename": "src/internal/fuzz/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 710,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-06-09T22:31:54Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "059ffccc_05ae94cf",
      "range": {
        "startLine": 710,
        "startChar": 48,
        "endLine": 710,
        "endChar": 56
      },
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c02d065_99040c6f",
        "filename": "src/internal/fuzz/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 726,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-06-08T03:36:22Z",
      "side": 1,
      "message": "Would be nice to give an example of such a case.",
      "range": {
        "startLine": 725,
        "startChar": 1,
        "endLine": 726,
        "endChar": 32
      },
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66d721ac_e85c3942",
        "filename": "src/internal/fuzz/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 726,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-06-09T22:31:54Z",
      "side": 1,
      "message": "Sounds like this can happen now due to supporting converstion from slice to array pointer. Should be rare, but best to be sure we don\u0027t run into it. This is what the docs at tip say:\n\n  Even if ConvertibleTo returns true, the conversion may still panic.\n\nline in code: https://github.com/golang/go/blob/master/src/reflect/type.go#L109\nCL: https://go-review.googlesource.com/c/go/+/301652\n\nSince the docs will say this, I don\u0027t think an example in a comment here is necessary, but lmk if you disagree.",
      "parentUuid": "5c02d065_99040c6f",
      "range": {
        "startLine": 725,
        "startChar": 1,
        "endLine": 726,
        "endChar": 32
      },
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f15ede74_291b2f94",
        "filename": "src/testing/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-06-08T03:36:22Z",
      "side": 1,
      "message": "\"convertible\"? Assignability and convertibility are slightly different according to the Go specification. The logic in internal/fuzz seems to use convertibility.",
      "range": {
        "startLine": 225,
        "startChar": 9,
        "endLine": 225,
        "endChar": 19
      },
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7cbe977c_0f55773b",
        "filename": "src/testing/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-06-09T22:31:54Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f15ede74_291b2f94",
      "range": {
        "startLine": 225,
        "startChar": 9,
        "endLine": 225,
        "endChar": 19
      },
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1019ae25_13e76b70",
        "filename": "src/testing/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 297,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-06-08T03:36:22Z",
      "side": 1,
      "message": "This could be future work. We could consider remembering the callsite of each f.Add and providing such information here now that we know exactly which f.Add call was problematic.",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be219fd9_f1842844",
        "filename": "src/testing/fuzz.go",
        "patchSetId": 1
      },
      "lineNbr": 297,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-06-09T22:31:54Z",
      "side": 1,
      "message": "Added a TODO",
      "parentUuid": "1019ae25_13e76b70",
      "revId": "e06806d57ba47458601ee913f19c20525b89d5fe",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}