{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8e4c3220_21ced847",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-14T03:24:06Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003df1c9086f",
      "tag": "autogenerated:trybots~beginning",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "790c4ec0_da752a72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-14T03:36:17Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "8e4c3220_21ced847",
      "tag": "autogenerated:trybots~happy",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ebaeacd_132842e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-01-14T03:36:25Z",
      "side": 1,
      "message": "Now this will be the only CL for the new assembler, let\u0027s review this CL, thanks.",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "883c66af_8227521c",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-19T19:35:08Z",
      "side": 1,
      "message": "Why is this change? Anything fail without this?",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42e93e10_43b76d9e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-20T11:31:21Z",
      "side": 1,
      "message": "Yeah, because there are some checks in the process of expanding and encoding, our error check mechanism does not return immediately when a check fails, but records the error and the program continues to execute, so that we may record multiple failures.\n\nThis is not a problem previously because we tried to report only one error in the span7-\u003easmout process, but now it is difficult to do such coordination after we divide it into multiple stages.",
      "parentUuid": "883c66af_8227521c",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "73feacf0_69c96c6e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-22T12:49:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "42e93e10_43b76d9e",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4681e0cb_3d73e4e1",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-25T22:27:34Z",
      "side": 1,
      "message": "I think we should emit an error in one place. We can have multiple stages but do they all need to emit error?\n\nIf an error is emitted for an instruction, you can put a marker on the instruction (or even rewrite  it) so it won\u0027t emit an error on the same instruction again.",
      "parentUuid": "73feacf0_69c96c6e",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7800a6e3_d0e61e6d",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-19T19:35:08Z",
      "side": 1,
      "message": "I\u0027m leaning toward not defining these in the common/portable package, but in the arm64 package, and also not to add fields into common data structures like Prog. Can we use side tables to track Prog \u003c-\u003e machine instruction mappings? Or, taking a step back, do you really need to store the machine instructions? The old code does the expansion on the fly, one Prog a time, and never needs to store the machine instruction format anywhere. The RISCV64 assembler has a data type for machine instruction and encoding functions, but it doesn\u0027t need to store instructions either. I think we should do that in the new code as well.\n\nI think you can do this by breaking the unfold pass to two parts: the first part validates the instruction, computes the sizes, and marks branch/pool/etc.. The second part actually creates the machine instruction data structure and encodes them.",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b61a0d42_0c7c3635",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-20T11:31:21Z",
      "side": 1,
      "message": "Through the side table, we\u0027re able to keep from adding new fields in Prog, but we can\u0027t encode a Prog like riscv, because the instructions of arm64 are too complicated and have no set format, such as the MOVD instruction, it can translated to more than ten different formats of machine instructions, we can\u0027t record so much information through the markup, we need analysis to determine what sequence of machine instructions a Prog corresponds to, unless we do another analysis while coding, which I believe we won\u0027t do.\nIn addition, we want to keep the process of machine instruction encoding as pure as possible, and less involved in the process of unfolding the Prog (in fact, we can treat the unfolding process of prog is a part of code-gen rather than assembly instruction encoding), and reduce the coupling between prog processing and encoding.",
      "parentUuid": "7800a6e3_d0e61e6d",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d7ec7b6_075ec6eb",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-22T13:00:05Z",
      "side": 1,
      "message": "Move these two fields into the ctxt7 structure. Regarding relocation type, we can\u0027t use Prog.Mark to indicate the reloc information required by a Prog like riscv, because arm64 has many reloc types, and Prog.Mark has only 16 bits. In addition, arm64 The reloc may appear in a Prog.From or Prog.To, so we have to record the location information of a reloc, it\u0027s difficult to record so much information in a bit mask. So I turned to create the reloc when unfolding, and stored its subscript of the reloc in ctxt7.",
      "parentUuid": "b61a0d42_0c7c3635",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c115ddf1_316c4faa",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-25T22:27:34Z",
      "side": 1,
      "message": "Yeah, this is better, thanks.\n\nI still wonder why we need to do the expansion early. I think the expansion is not needed until right before encoding. For handling constant pools and branches, etc., all we need is the size of the instruction and some markers (does it use pool, is it a branch and how many bits, etc.). Can we do that later?\n\nAs for relocations, can we generate the relocations at the encoding stage instead of the expansion stage?\n\n\u003e The reloc may appear in a Prog.From or Prog.To\n\nI don\u0027t understand this. A relocation should always apply to an instruction, not part of it.",
      "parentUuid": "8d7ec7b6_075ec6eb",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}