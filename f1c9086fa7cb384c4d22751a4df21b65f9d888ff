{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8e4c3220_21ced847",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-14T03:24:06Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003df1c9086f",
      "tag": "autogenerated:trybots~beginning",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "790c4ec0_da752a72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-14T03:36:17Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "8e4c3220_21ced847",
      "tag": "autogenerated:trybots~happy",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ebaeacd_132842e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-01-14T03:36:25Z",
      "side": 1,
      "message": "Now this will be the only CL for the new assembler, let\u0027s review this CL, thanks.",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "883c66af_8227521c",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-19T19:35:08Z",
      "side": 1,
      "message": "Why is this change? Anything fail without this?",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42e93e10_43b76d9e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-20T11:31:21Z",
      "side": 1,
      "message": "Yeah, because there are some checks in the process of expanding and encoding, our error check mechanism does not return immediately when a check fails, but records the error and the program continues to execute, so that we may record multiple failures.\n\nThis is not a problem previously because we tried to report only one error in the span7-\u003easmout process, but now it is difficult to do such coordination after we divide it into multiple stages.",
      "parentUuid": "883c66af_8227521c",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "73feacf0_69c96c6e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-22T12:49:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "42e93e10_43b76d9e",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4681e0cb_3d73e4e1",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-25T22:27:34Z",
      "side": 1,
      "message": "I think we should emit an error in one place. We can have multiple stages but do they all need to emit error?\n\nIf an error is emitted for an instruction, you can put a marker on the instruction (or even rewrite  it) so it won\u0027t emit an error on the same instruction again.",
      "parentUuid": "73feacf0_69c96c6e",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5d1d342_196bb1a8",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T03:57:48Z",
      "side": 1,
      "message": "\u003e We can have multiple stages but do they all need to emit error?\nYeah, in unfolding, we check if the instruction format is valid, when encoding an argument type, we check if the argument value is valid, say in the valid range.\n\n\u003e you can put a marker on the instruction (or even rewrite  it)\nThis is feasible, but the current method is the easiest way, are there any other implications of the current practice that I haven\u0027t thought of?",
      "parentUuid": "4681e0cb_3d73e4e1",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac1b45c9_c28bbf4b",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T12:17:19Z",
      "side": 1,
      "message": "At present, I still keep the current practice, because this way we can check more freely instead of checking whether an error has been reported before reporting an check error. If we really need to modify it, I will modify it later.",
      "parentUuid": "c5d1d342_196bb1a8",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9cb18764_17e6679e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-02T19:59:10Z",
      "side": 1,
      "message": "What is the error actually reported on the command line? We can make the the test to do whatever makes sense, but the actual error printed on the command line is what matters to users. We probably don\u0027t want to print multiple error for one bad instruction.",
      "parentUuid": "ac1b45c9_c28bbf4b",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7800a6e3_d0e61e6d",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-19T19:35:08Z",
      "side": 1,
      "message": "I\u0027m leaning toward not defining these in the common/portable package, but in the arm64 package, and also not to add fields into common data structures like Prog. Can we use side tables to track Prog \u003c-\u003e machine instruction mappings? Or, taking a step back, do you really need to store the machine instructions? The old code does the expansion on the fly, one Prog a time, and never needs to store the machine instruction format anywhere. The RISCV64 assembler has a data type for machine instruction and encoding functions, but it doesn\u0027t need to store instructions either. I think we should do that in the new code as well.\n\nI think you can do this by breaking the unfold pass to two parts: the first part validates the instruction, computes the sizes, and marks branch/pool/etc.. The second part actually creates the machine instruction data structure and encodes them.",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b61a0d42_0c7c3635",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-20T11:31:21Z",
      "side": 1,
      "message": "Through the side table, we\u0027re able to keep from adding new fields in Prog, but we can\u0027t encode a Prog like riscv, because the instructions of arm64 are too complicated and have no set format, such as the MOVD instruction, it can translated to more than ten different formats of machine instructions, we can\u0027t record so much information through the markup, we need analysis to determine what sequence of machine instructions a Prog corresponds to, unless we do another analysis while coding, which I believe we won\u0027t do.\nIn addition, we want to keep the process of machine instruction encoding as pure as possible, and less involved in the process of unfolding the Prog (in fact, we can treat the unfolding process of prog is a part of code-gen rather than assembly instruction encoding), and reduce the coupling between prog processing and encoding.",
      "parentUuid": "7800a6e3_d0e61e6d",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d7ec7b6_075ec6eb",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-22T13:00:05Z",
      "side": 1,
      "message": "Move these two fields into the ctxt7 structure. Regarding relocation type, we can\u0027t use Prog.Mark to indicate the reloc information required by a Prog like riscv, because arm64 has many reloc types, and Prog.Mark has only 16 bits. In addition, arm64 The reloc may appear in a Prog.From or Prog.To, so we have to record the location information of a reloc, it\u0027s difficult to record so much information in a bit mask. So I turned to create the reloc when unfolding, and stored its subscript of the reloc in ctxt7.",
      "parentUuid": "b61a0d42_0c7c3635",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c115ddf1_316c4faa",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-25T22:27:34Z",
      "side": 1,
      "message": "Yeah, this is better, thanks.\n\nI still wonder why we need to do the expansion early. I think the expansion is not needed until right before encoding. For handling constant pools and branches, etc., all we need is the size of the instruction and some markers (does it use pool, is it a branch and how many bits, etc.). Can we do that later?\n\nAs for relocations, can we generate the relocations at the encoding stage instead of the expansion stage?\n\n\u003e The reloc may appear in a Prog.From or Prog.To\n\nI don\u0027t understand this. A relocation should always apply to an instruction, not part of it.",
      "parentUuid": "8d7ec7b6_075ec6eb",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1332a0e_c037b067",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T03:57:48Z",
      "side": 1,
      "message": "\u003e I still wonder why we need to do the expansion early, all we need is the size of the instruction\nThis is the root cause why we need to do the expansion early, because we don\u0027t know how many machine instructions a Prog corresponding to. If we don\u0027t know the size, we can\u0027t determine the PC of each instruction, then we can\u0027t handle branches, alignments. I know if we do the unfolding work just before encoding, then we don\u0027t need to save anything.\n\n\u003e I don\u0027t understand this. A relocation should always apply to an instruction, not part of it.\nYeah, my statement is wrong. I mean the relocation symbol may be Prog.From.Sym or Prog.To.Sym, so apart from the relocation type, we also need to record the symbol.",
      "parentUuid": "c115ddf1_316c4faa",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3d05324_1afb9a4b",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T12:17:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a1332a0e_c037b067",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52aed47b_59359a36",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-02T19:59:10Z",
      "side": 1,
      "message": "Yeah, we need to know the number of instructions. But we can compute the number of instructions without actually doing the expansion. Why not do that?\n\n\u003e Yeah, my statement is wrong. I mean the relocation symbol may be Prog.From.Sym or Prog.To.Sym, so apart from the relocation type, we also need to record the symbol.\n\nSo the problem is that the Oprd type (now \"arg\") doesn\u0027t contain a Sym? What about adding it?",
      "parentUuid": "d3d05324_1afb9a4b",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}