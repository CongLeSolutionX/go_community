{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8e4c3220_21ced847",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-14T03:24:06Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003df1c9086f",
      "tag": "autogenerated:trybots~beginning",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "790c4ec0_da752a72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-14T03:36:17Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "8e4c3220_21ced847",
      "tag": "autogenerated:trybots~happy",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ebaeacd_132842e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-01-14T03:36:25Z",
      "side": 1,
      "message": "Now this will be the only CL for the new assembler, let\u0027s review this CL, thanks.",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "883c66af_8227521c",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-19T19:35:08Z",
      "side": 1,
      "message": "Why is this change? Anything fail without this?",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42e93e10_43b76d9e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-20T11:31:21Z",
      "side": 1,
      "message": "Yeah, because there are some checks in the process of expanding and encoding, our error check mechanism does not return immediately when a check fails, but records the error and the program continues to execute, so that we may record multiple failures.\n\nThis is not a problem previously because we tried to report only one error in the span7-\u003easmout process, but now it is difficult to do such coordination after we divide it into multiple stages.",
      "parentUuid": "883c66af_8227521c",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "73feacf0_69c96c6e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-22T12:49:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "42e93e10_43b76d9e",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4681e0cb_3d73e4e1",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-25T22:27:34Z",
      "side": 1,
      "message": "I think we should emit an error in one place. We can have multiple stages but do they all need to emit error?\n\nIf an error is emitted for an instruction, you can put a marker on the instruction (or even rewrite  it) so it won\u0027t emit an error on the same instruction again.",
      "parentUuid": "73feacf0_69c96c6e",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5d1d342_196bb1a8",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T03:57:48Z",
      "side": 1,
      "message": "\u003e We can have multiple stages but do they all need to emit error?\nYeah, in unfolding, we check if the instruction format is valid, when encoding an argument type, we check if the argument value is valid, say in the valid range.\n\n\u003e you can put a marker on the instruction (or even rewrite  it)\nThis is feasible, but the current method is the easiest way, are there any other implications of the current practice that I haven\u0027t thought of?",
      "parentUuid": "4681e0cb_3d73e4e1",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac1b45c9_c28bbf4b",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T12:17:19Z",
      "side": 1,
      "message": "At present, I still keep the current practice, because this way we can check more freely instead of checking whether an error has been reported before reporting an check error. If we really need to modify it, I will modify it later.",
      "parentUuid": "c5d1d342_196bb1a8",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9cb18764_17e6679e",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-02T19:59:10Z",
      "side": 1,
      "message": "What is the error actually reported on the command line? We can make the the test to do whatever makes sense, but the actual error printed on the command line is what matters to users. We probably don\u0027t want to print multiple error for one bad instruction.",
      "parentUuid": "ac1b45c9_c28bbf4b",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce55ee2a_71e92211",
        "filename": "src/cmd/asm/internal/asm/endtoend_test.go",
        "patchSetId": 4
      },
      "lineNbr": 320,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-05-03T05:25:09Z",
      "side": 1,
      "message": "\u003e What is the error actually reported on the command line?\nThis depends on the case, two examples:\n\n    endtoend_test.go:327: multiple errors on testdata/arm64error.s:65:\n                constrained unpredictable behavior: 00061 (testdata/arm64error.s:65)    LDP.P   8(R2), (R2, R3)\n                illegal combination: 00312 (testdata/arm64error.s:65)   LDP.P   8(R2), (R2, R3)\n\n    endtoend_test.go:327: multiple errors on testdata/arm64error.s:81:\n                illegal register F2: 00336 (testdata/arm64error.s:81)   STP     (F2, F3), (R0)\n                illegal register F3: 00336 (testdata/arm64error.s:81)   STP     (F2, F3), (R0)\n\nIn the first example, we first checked out the first error. Due to the first error, we did not generate legal machine instruction information for the Prog, and the second error was then reported when encoding later. As can be seen from this example, the second error is actually unnecessary and does not give very useful hints.\n\nIn the second example, because we check whether F2 and F3 are legal one by one, two errors will be reported, and both errors are suggestive.\n\nSo I feel that usually the first error is the most valuable, so I choose to use the first error as the expected error.\n\n\u003e We probably don\u0027t want to print multiple error for one bad instruction.\nOkay, I hadn\u0027t thought of this before, we\u0027d be presenting multiple errors to the user and it would really be a little confusing. I\u0027m wondering if there is a way to just report an error without restricting the check code.",
      "parentUuid": "9cb18764_17e6679e",
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7800a6e3_d0e61e6d",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-19T19:35:08Z",
      "side": 1,
      "message": "I\u0027m leaning toward not defining these in the common/portable package, but in the arm64 package, and also not to add fields into common data structures like Prog. Can we use side tables to track Prog \u003c-\u003e machine instruction mappings? Or, taking a step back, do you really need to store the machine instructions? The old code does the expansion on the fly, one Prog a time, and never needs to store the machine instruction format anywhere. The RISCV64 assembler has a data type for machine instruction and encoding functions, but it doesn\u0027t need to store instructions either. I think we should do that in the new code as well.\n\nI think you can do this by breaking the unfold pass to two parts: the first part validates the instruction, computes the sizes, and marks branch/pool/etc.. The second part actually creates the machine instruction data structure and encodes them.",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b61a0d42_0c7c3635",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-20T11:31:21Z",
      "side": 1,
      "message": "Through the side table, we\u0027re able to keep from adding new fields in Prog, but we can\u0027t encode a Prog like riscv, because the instructions of arm64 are too complicated and have no set format, such as the MOVD instruction, it can translated to more than ten different formats of machine instructions, we can\u0027t record so much information through the markup, we need analysis to determine what sequence of machine instructions a Prog corresponds to, unless we do another analysis while coding, which I believe we won\u0027t do.\nIn addition, we want to keep the process of machine instruction encoding as pure as possible, and less involved in the process of unfolding the Prog (in fact, we can treat the unfolding process of prog is a part of code-gen rather than assembly instruction encoding), and reduce the coupling between prog processing and encoding.",
      "parentUuid": "7800a6e3_d0e61e6d",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d7ec7b6_075ec6eb",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-22T13:00:05Z",
      "side": 1,
      "message": "Move these two fields into the ctxt7 structure. Regarding relocation type, we can\u0027t use Prog.Mark to indicate the reloc information required by a Prog like riscv, because arm64 has many reloc types, and Prog.Mark has only 16 bits. In addition, arm64 The reloc may appear in a Prog.From or Prog.To, so we have to record the location information of a reloc, it\u0027s difficult to record so much information in a bit mask. So I turned to create the reloc when unfolding, and stored its subscript of the reloc in ctxt7.",
      "parentUuid": "b61a0d42_0c7c3635",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c115ddf1_316c4faa",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-04-25T22:27:34Z",
      "side": 1,
      "message": "Yeah, this is better, thanks.\n\nI still wonder why we need to do the expansion early. I think the expansion is not needed until right before encoding. For handling constant pools and branches, etc., all we need is the size of the instruction and some markers (does it use pool, is it a branch and how many bits, etc.). Can we do that later?\n\nAs for relocations, can we generate the relocations at the encoding stage instead of the expansion stage?\n\n\u003e The reloc may appear in a Prog.From or Prog.To\n\nI don\u0027t understand this. A relocation should always apply to an instruction, not part of it.",
      "parentUuid": "8d7ec7b6_075ec6eb",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1332a0e_c037b067",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T03:57:48Z",
      "side": 1,
      "message": "\u003e I still wonder why we need to do the expansion early, all we need is the size of the instruction\nThis is the root cause why we need to do the expansion early, because we don\u0027t know how many machine instructions a Prog corresponding to. If we don\u0027t know the size, we can\u0027t determine the PC of each instruction, then we can\u0027t handle branches, alignments. I know if we do the unfolding work just before encoding, then we don\u0027t need to save anything.\n\n\u003e I don\u0027t understand this. A relocation should always apply to an instruction, not part of it.\nYeah, my statement is wrong. I mean the relocation symbol may be Prog.From.Sym or Prog.To.Sym, so apart from the relocation type, we also need to record the symbol.",
      "parentUuid": "c115ddf1_316c4faa",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3d05324_1afb9a4b",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-04-26T12:17:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a1332a0e_c037b067",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52aed47b_59359a36",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-02T19:59:10Z",
      "side": 1,
      "message": "Yeah, we need to know the number of instructions. But we can compute the number of instructions without actually doing the expansion. Why not do that?\n\n\u003e Yeah, my statement is wrong. I mean the relocation symbol may be Prog.From.Sym or Prog.To.Sym, so apart from the relocation type, we also need to record the symbol.\n\nSo the problem is that the Oprd type (now \"arg\") doesn\u0027t contain a Sym? What about adding it?",
      "parentUuid": "d3d05324_1afb9a4b",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16ca8b66_28a641d0",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-05-03T05:25:09Z",
      "side": 1,
      "message": "\u003e But we can compute the number of instructions without actually doing the expansion\nSorry I don\u0027t know how to do this, can you elaborate on this, thanks~\n\nRISCV calls the instructionsForProg function three times, once in preprocess, once in setPCs and once in assemble. I didn\u0027t delve into it, but this seems to do some repetitive work because the machine instructions corresponding to a Prog are analyzed three times. \n\nMaybe RISCV does this because their instructions are more regular? I\u0027m not sure， but I don\u0027t lean to repeat this process on arm64, that is, unfolding analysis, because this process does not seem to be very simple, although it may not take too much time. Why not apply a little space to cache the machine instructions obtained by the unfolding process? It doesn\u0027t take much space.\n\n\u003e So the problem is that the Oprd type (now \"arg\") doesn\u0027t contain a Sym? What about adding it?\nI mean we can\u0027t make a bit mark on the reloc type like RISCV, and then process it. We can\u0027t use a bit mark to record all information needed by a relocation here, because we need to record not only the reloc type but also the symbol information. And the Prog.Mark is only 16 bits, it records up to 16 combinations, and we obviously have more than that, so we can\u0027t do it like RISCV. So we record the reloc information of a Prog in a map.",
      "parentUuid": "52aed47b_59359a36",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68158e8f_e4648453",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-03T15:03:52Z",
      "side": 1,
      "message": "I didn\u0027t mean that this needs to follow the RISCV code closely. RISCV code does something is not a justification that we should or should not do that.\n\nI don\u0027t understand why you have to put the relocation information intoProg.Mask. You can use a field in \"arg\" type, or \"inst\" type, whatever fits for this code.\n\nSimilarly, the RISCV code calls instructionsForProg multiple times doesn\u0027t mean this code needs to do. All I said is to have a separate function that simply returns the number of inst needed for a Prog. I don\u0027t understand why this is hard to do. For example, you can have something similar to the unfoldTab but each entry is func(*Prog) int.",
      "parentUuid": "16ca8b66_28a641d0",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2e9abd0_8b9550e8",
        "filename": "src/cmd/internal/obj/link.go",
        "patchSetId": 4
      },
      "lineNbr": 353,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-05-04T03:54:11Z",
      "side": 1,
      "message": "\u003e I don\u0027t understand why you have to put the relocation information intoProg.Mask.\nSorry I misunderstood your previous comment and thought you suggested the RISCV approach.\n\u003e You can use a field in \"arg\" type, or \"inst\" type, whatever fits for this code.\nYes, that\u0027s fine.\n\u003e All I said is to have a separate function that simply returns the number of inst needed for a Prog. I don\u0027t understand why this is hard to do.\nNot very hard, it\u0027s feasible, but that function will be quite similar with the unfolding function. Because we need to analyze the arguments and the opcode and then we can determine the number of inst, this is basically what unfolding process does. For example:\n Prog p: MOVD $0xabcde001, R0\n\nTo determine the number of inst corresponding to p, do:\n 1, Check the type of p.From, namely a constant.\n 2, Check the type of p.To, a general register type.\n 3, Based on the value of this constant， determine how many instructions we need to \n    move it into register R0 , maybe 1, 2, 3, or 4.\n\nNow we get the number of inst, and at this time, we basically know which machine instructions this Prog should be translated into. It\u0027s just that we also do some legality checks in the unfolding process, as well as some work involving literal pool, branch and reloc.\n\nSo my point is whether we should do a process with greater redundancy with the unfolding process in order to get the inst number of Prog.\n\nI don\u0027t know if there is an easier way to get the inst count of the Prog, if there is, please let me know, thanks.",
      "parentUuid": "68158e8f_e4648453",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 353,
        "endChar": 1
      },
      "revId": "f1c9086fa7cb384c4d22751a4df21b65f9d888ff",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}