{
  "comments": [
    {
      "key": {
        "uuid": "7c729f70_c1df0335",
        "filename": "src/go/go2go/rewrite.go",
        "patchSetId": 15
      },
      "lineNbr": 722,
      "author": {
        "id": 24715
      },
      "writtenOn": "2020-04-10T09:47:47Z",
      "side": 1,
      "message": "Gets hit for generic return types with slice type parameters:\n\n```\npackage arr_panic\n\ntype Thing(type T) struct{}\n\nfunc ArrayThing(type T)() Thing([]T) {\n\treturn Thing([]T){}\n}\n\nvar _ \u003d ArrayThing(int)()\n```\n\n```\npanic: arr_panic.go2:5:33: no type found for *ast.ArrayType \u0026{81 \u003cnil\u003e int}\n```",
      "revId": "64065059ea5c43751ac7fd865de8b13c42bc080e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3969512_1100d6b7",
        "filename": "src/go/go2go/rewrite.go",
        "patchSetId": 15
      },
      "lineNbr": 722,
      "author": {
        "id": 5206
      },
      "writtenOn": "2020-04-10T19:28:49Z",
      "side": 1,
      "message": "Thanks for the test case.  This will be fixed in the next update.",
      "parentUuid": "7c729f70_c1df0335",
      "revId": "64065059ea5c43751ac7fd865de8b13c42bc080e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "abd4c7bb_751ce7f6",
        "filename": "src/go/types/NOTES",
        "patchSetId": 15
      },
      "lineNbr": 46,
      "author": {
        "id": 30903
      },
      "writtenOn": "2020-04-10T08:10:49Z",
      "side": 1,
      "message": "After tried the current contract implementation for about a month, I am a little bit wondering what are the destiny for the existing built-in functions. All of them can be implemented in a generic way:\n\n```\nfunc Append(type T)(slice []T, elems ...T) []T {...}\nfunc Copy(type T)(dst, src []T) int {...}\nfunc Delete(type K, V)(m map[K]V, k K) {...}\nfunc Make(type T, I Integer(I))(siz ...I) T {...}\nfunc New(type T)() *T {...}\nfunc Close(type T)(c chan\u003c- T) {...}\nfunc Panic(type T)(v T) {...}\nfunc Recover(type T)() T {...}\nfunc Print(type ...T)(args ...T) {...}\nfunc Println(type ...T)(args ...T) {...}\n```\n\nWill they be gone in Go2? How could Go 2 deal with such a huge impact on the existing Go 1 codebase? These seem to be open questions.\n\nMoreover, these two are a little bit special:\n\n```\nfunc Len(type T C)(t T) int {...}\nfunc Cap(type T C)(t T) int {...}\n```\n\nHow to implement such a contract `C`, such that a type parameter can only be generic slice `[]Ts`, map `map[Tk]Tv`, and channel `chan Tc` where `T Ts Tk Tv Tc` are different?",
      "revId": "64065059ea5c43751ac7fd865de8b13c42bc080e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc0a5b36_f0aeb82b",
        "filename": "src/go/types/NOTES",
        "patchSetId": 15
      },
      "lineNbr": 46,
      "author": {
        "id": 5206
      },
      "writtenOn": "2020-04-10T19:06:35Z",
      "side": 1,
      "message": "Let\u0027s not discuss details of the draft design here.  Let\u0027s discuss them on golang-nuts or on https://golang.org/issue/15292.  Thanks.",
      "parentUuid": "abd4c7bb_751ce7f6",
      "revId": "64065059ea5c43751ac7fd865de8b13c42bc080e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7569b717_133568bc",
        "filename": "src/go/types/subst.go",
        "patchSetId": 15
      },
      "lineNbr": 149,
      "author": {
        "id": 24715
      },
      "writtenOn": "2020-04-10T20:22:07Z",
      "side": 1,
      "message": "I\u0027m not sure if this is just an implementation oversight or an outstanding design decision that should be discussed on GitHub, but the comparable contract\u0027s behavior doesn\u0027t quite match what I would expect for interfaces.\n\nTake for example:\n\n```\npackage comparable_err\n\nfunc Equals(type T comparable)(a, b T) bool {\n    return a \u003d\u003d b\n}\n```\n\nIf you instantiate this with an interface (e.g. `Equals(error)`), you get an error:\n\n```\n./comparable_err.go2:7:16: error does not satisfy comparable\n```\n\nIn one sense, this is correct because it is possible to create non-comparable errors. However, monomorphic Go 1 code comparing errors compiles just fine (but may panic at runtime), so I would think the most consistent / least surprising thing would be if this compiled.",
      "revId": "64065059ea5c43751ac7fd865de8b13c42bc080e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3eb1cbc7_3d04a700",
        "filename": "src/go/types/subst.go",
        "patchSetId": 15
      },
      "lineNbr": 149,
      "author": {
        "id": 5210
      },
      "writtenOn": "2020-04-10T22:44:18Z",
      "side": 1,
      "message": "This boils down to the question whether interfaces are comparable with respect to the comparable contract.   TBD. Thanks for pointing this out.",
      "parentUuid": "7569b717_133568bc",
      "revId": "64065059ea5c43751ac7fd865de8b13c42bc080e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}