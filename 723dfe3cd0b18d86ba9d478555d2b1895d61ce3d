{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "644b785a_2e04131a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-07-27T00:17:43Z",
      "side": 1,
      "message": "Maybe I missed it, but I don\u0027t see anything clearing the system stack.  That is necessary for, at least, 1) cgo calls to some C function that takes secret values passed on the stack; 2) registers saved during the cgo process that hold secret values; 3) registers saved during a non-cgo call in the runtime that uses the system stack.",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "610c989a_47dc24b4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-07-27T00:20:26Z",
      "side": 1,
      "message": "Nice work, by the way.",
      "parentUuid": "644b785a_2e04131a",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63b76f61_662f619f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 6875
      },
      "writtenOn": "2024-07-27T00:45:39Z",
      "side": 1,
      "message": "I haven\u0027t considered how cgo would work yet. I presume the caller would be on their own for the c side of things. I suppose we could zero the whole c stack (4MB?) on every return to Go code.\n\nWe could figure out what to do on the Go side.\n\nFor most other switches to the g0 stack, I don\u0027t think there is much to do. User data doesn\u0027t normally cross that boundary. Just things like morestack, which have some G pointers, stack pointers, and such, but nothing secret from the g stack or registers. Unless we get down to C abi when callee-save registers might have (dead) secret stuff in them that gets saved to the stack?\n\nSpeaking of which, I\u0027m worried about signals, which is related but not the same. When we get a signal (SIGURG from the GC, probably, but this applies for any signal), where does the OS write the register state? Is that on the signal stack? How do we erase that information? The signal handler can\u0027t erase it because it would corrupt the registers when the handler returns. Can we ask the OS to zero out the register info in memory after it copies that info into the OS\u0027s thread state? Or do we have to remember that we got a signal somehow and figure out how to zero that information later?\n\nLots of tricky corners.",
      "parentUuid": "610c989a_47dc24b4",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8f214a1_d30fcfcf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-07-27T03:27:01Z",
      "side": 1,
      "message": "Good point that we don\u0027t know how far down to zero the system stack, and it would be painful to zero out the whole thing even if know the size.  One step we can take is to zero out all registers not used to pass arguments to cgo functions.  And then I guess we have to document that the user is responsible for the C stack of any functions called from Go.\n\nFor non-cgo uses of the system stack I\u0027m thinking of cases where a register might hold user secret data itself, and we might save that register value on the system stack when we switch to it.  Perhaps that doesn\u0027t happen.\n\nFor signals, registers are saved on the signal stack.  So if we zero the top of the signal stack when we exit secret.Do we should be OK.  The amount we have to zero out is the size of the signal context.  We currently give that a name like \"type sigcontext\" or \"type ucontext\", but frankly I think that our current definitions are wrong--they are good enough for us dump some registers when we crash, but they aren\u0027t the full amount of data that the signal handler stashes.  Also at least on x86 it seems that the signal handler actually saves the data in two pieces: first the FPU state, then the regular register state, with the latter pointing to the former.  In any case, it seems likely that if we record the stack pointer in sigtramp or sigtrampgo, then we will be OK if zero out everything from the top of the signal stack to the point of the saved stack pointer.",
      "parentUuid": "63b76f61_662f619f",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49b397a3_1aa802d6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-07-27T04:34:12Z",
      "side": 1,
      "message": "The problem I see with signals is that by the time runtime.Do returns, we don\u0027t know which signal stack was used. We may have moved between Ms in the meantime. So maybe it is not the current thread\u0027s signal stack. It could be several other signal stacks.\nSomehow we\u0027d have to record which signal stacks were used during a secret.Do so we could zero them at the end? And then do that zeroing somehow safely?\nThis problem seems not limited to Go (although our async preemption makes it worse), so I would be curious how other languages solve this problem, if at all.\n\nWorst case, maybe we just zero signal stacks periodically, if any secret.Do were executed recently?",
      "parentUuid": "c8f214a1_d30fcfcf",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a814b1da_f027139b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-07-27T04:37:19Z",
      "side": 1,
      "message": "Another option for the cgo case is to just forbid (by panicking) cgo calls from within secret.Do.",
      "parentUuid": "49b397a3_1aa802d6",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09e83fcc_f7efd9df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-07-27T14:51:11Z",
      "side": 1,
      "message": "It might be a pain but when we get a signal we can see if the current g is in secret mode and put the current m on a list to have its signal stack cleared sometime after the g leaves secret mode.",
      "parentUuid": "a814b1da_f027139b",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b0b5045_05ce6e48",
        "filename": "src/runtime/secret.go",
        "patchSetId": 18
      },
      "lineNbr": 29,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-07-27T00:17:43Z",
      "side": 1,
      "message": "Are we still asking the question?  Presumably this CL has an answer.",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c772b559_3fbd1627",
        "filename": "src/runtime/secret.go",
        "patchSetId": 18
      },
      "lineNbr": 145,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-07-27T00:17:43Z",
      "side": 1,
      "message": "Convention is a plain \"//\" before the \"go:linkname\" line.",
      "revId": "723dfe3cd0b18d86ba9d478555d2b1895d61ce3d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}