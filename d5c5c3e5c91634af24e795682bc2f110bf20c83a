{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e18d4263_29e0d3f5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-29T04:02:54Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dd5c5c3e5\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dc4ec54b_b48b63ca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-29T04:02:54Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "84a64370_b15e31e9",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5c22c550_baf4c6e1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-29T04:15:31Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "e18d4263_29e0d3f5",
      "tag": "autogenerated:trybots~happy",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e7452920_abbfaf71",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2022-09-29T05:25:42Z",
      "side": 1,
      "message": "Hi Matthew, I think the same approach can apply to hashfor/genhash. But since when it relies on sym.Def, I want you to give it a review first ðŸ˜Š",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2ec04e4_87c33961",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-09-29T19:03:30Z",
      "side": 1,
      "message": "Thanks Cuong. Can you elaborate on why you believe this CL is desirable? I\u0027m not opposed to it, but I don\u0027t immediately see the benefit or long-term goal here either.",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "feae93e4_f80f7f53",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2022-09-29T19:25:22Z",
      "side": 1,
      "message": "IIRC, we were beaten in the past when adding regabi, due to the fact that the frontend generate ONAME node with nil Func, thereâ€™s code in the backend that workaround for this.\n\nWith this fix (and next for genhash when this CL is approved), the only case left is interface method, which I believe will also be fixed when Unified IR is fully replaced the old frontend.\n\nWith all of them fixed, I think we can simplify the backend code by removing the workaround.",
      "parentUuid": "c2ec04e4_87c33961",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f4b89b0_13a74d7e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-09-29T20:12:24Z",
      "side": 1,
      "message": "\u003e IIRC, we were beaten in the past when adding regabi, due to the fact that the frontend generate ONAME node with nil Func, thereâ€™s code in the backend that workaround for this.\n\nI see. Thanks for elaborating.\n\n\u003e With this fix (and next for genhash when this CL is approved), the only case left is interface method, which I believe will also be fixed when Unified IR is fully replaced the old frontend.\n\nMaybe I misunderstand what you mean here, but I don\u0027t think unified IR creates `ir.Func`s for interface methods either.\n\n\u003e With all of them fixed, I think we can simplify the backend code by removing the workaround.\n\nAre you able to prepare a CL stack demonstrating the full cleanup? That would help evaluate whether this is worthwhile.\n\nFor demo purposes, I think it\u0027s fine if it fails on the -nounified builder. Alternatively, you can keep the workaround, and just put it behind `if base.Debug.Unified \u003d\u003d 0`.",
      "parentUuid": "feae93e4_f80f7f53",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0f6a32e_93c4dead",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2022-09-30T02:46:38Z",
      "side": 1,
      "message": "\u003e Maybe I misunderstand what you mean here, but I don\u0027t think unified IR creates ir.Funcs for interface methods either.\n\nOps, you\u0027re right. Specifically, the check in (*SelectorExpr).FuncName() is still required.",
      "parentUuid": "6f4b89b0_13a74d7e",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d6a7fe6_a7dc5202",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2022-09-30T03:11:00Z",
      "side": 1,
      "message": "To clarify, I thought we used to generate the Func for interface method in reflectdata.methodWrapper, which happens late in the compiler phases. I would re-check that, but I think it\u0027s still worth to eliminate case that having ONAME with nil Func as much as possible.",
      "parentUuid": "a0f6a32e_93c4dead",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40d81d56_febdf767",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2022-09-30T07:28:34Z",
      "side": 1,
      "message": "\u003e Maybe I misunderstand what you mean here, but I don\u0027t think unified IR creates ir.Funcs for interface methods either.\n\nI re-read the Unified IR code to generate wrapper func. So for current package interface method, Unified IR actually generates the ir.Func, it just don\u0027t attach the Func to the method.\n\nWith this diff:\n\n```\n@@ -3833,6 +3835,7 @@ func newWrapperFunc(pos src.XPos, sym *types.Sym, wrapper *types.Type, method *t\n        name.Func \u003d fn\n        name.Defn \u003d fn\n        fn.Nname \u003d name\n+       method.Nname \u003d fn.Nname\n\n        sig :\u003d newWrapperType(wrapper, method)\n        setType(name, sig)\n```\n\nThen for this code:\n\n```\npackage p\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\ntype MyReader interface {\n\tRead([]byte) (int, error)\n}\n\nfunc g(b *bytes.Buffer) {\n\t_, _ \u003d MyReader.Read(b, make([]byte, 10))\n\t_, _ \u003d io.Reader.Read(b, make([]byte, 10))\n}\n```\n\nWe have the ir.Func for MyReader.Read, but not io.Reader.Read method.",
      "parentUuid": "7d6a7fe6_a7dc5202",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d950e440_1c7bd8d8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2022-10-10T07:11:00Z",
      "side": 1,
      "message": "\u003e We have the ir.Func for MyReader.Read, but not io.Reader.Read method.\n\nFor more context, io.Reader.Read is from imported package, so we assume its receiver \"haveWrapperTypes\", not \"needWrapperTypes\". I can\u0027t think offhand how to solve this, since when adding more thing to \"needWrapperTypes\" would make Unified IR more slow, which we don\u0027t want.\n\nBut at least, I think the CL to hand runtime hash function should be land, so it reduce the pain to deal with ONAME with nil Func.",
      "parentUuid": "40d81d56_febdf767",
      "revId": "d5c5c3e5c91634af24e795682bc2f110bf20c83a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}