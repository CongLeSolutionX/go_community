{
  "comments": [
    {
      "key": {
        "uuid": "ad72168f_f7bd7a22",
        "filename": "doc/go_spec.html",
        "patchSetId": 2
      },
      "lineNbr": 4583,
      "author": {
        "id": 5015
      },
      "writtenOn": "2015-07-29T23:44:54Z",
      "side": 1,
      "message": "is this line redundant?",
      "range": {
        "startLine": 4583,
        "startChar": 3,
        "endLine": 4583,
        "endChar": 5
      },
      "revId": "42e0feb66221a47838237a184d9468f26e7bdea1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ea24f4a5_5ff0275b",
        "filename": "doc/go_spec.html",
        "patchSetId": 2
      },
      "lineNbr": 4583,
      "author": {
        "id": 5210
      },
      "writtenOn": "2015-07-30T00:38:19Z",
      "side": 1,
      "message": "yes and no.\n\nThe phrasing is copied almost exactly from the language used for initializing variables with no explicit type. There as here, we distinguish between untyped _constants_, and untyped _values_ (which may not be constant; e.g. x \u003d\u003d y results in an untyped bool that may not be constant). We could just merge it into \"untyped values\", but I think we didn\u0027t do it there to make it clear that we can have only non-constant untyped booleans.\n\nI didn\u0027t want to change that here because it will be easier to see (down the road) that we have the same rule here.\n\nI think we might be able to factor this out at some point and use a reference in several places (for a cleanup CL).",
      "parentUuid": "ad72168f_f7bd7a22",
      "range": {
        "startLine": 4583,
        "startChar": 3,
        "endLine": 4583,
        "endChar": 5
      },
      "revId": "42e0feb66221a47838237a184d9468f26e7bdea1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ad72168f_17c3d69f",
        "filename": "doc/go_spec.html",
        "patchSetId": 2
      },
      "lineNbr": 4590,
      "author": {
        "id": 5015
      },
      "writtenOn": "2015-07-29T23:44:54Z",
      "side": 1,
      "message": "does the next sentence cover this?",
      "range": {
        "startLine": 4590,
        "startChar": 3,
        "endLine": 4590,
        "endChar": 6
      },
      "revId": "42e0feb66221a47838237a184d9468f26e7bdea1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a11e441_0e6a7bde",
        "filename": "doc/go_spec.html",
        "patchSetId": 2
      },
      "lineNbr": 4590,
      "author": {
        "id": 5210
      },
      "writtenOn": "2015-07-30T00:38:19Z",
      "side": 1,
      "message": "It\u0027s somewhat asymmetric to comparisons because in a switch, an untyped switch expression is always first converted to it\u0027s default type (independent of the case expressions), and it\u0027s that converted expression with concrete type that is used in each comparison x \u003d\u003d t.\nIn an ordinary comparison, both operands are treated symmetrically.\n\nThus, I wanted to be explicit what conversion (if any) is applied to case expressions; and that it is applied _after_ the switch expression has been converted.\n\nLeft away the \"; otherwise...\", because that\u0027s implied.",
      "parentUuid": "ad72168f_17c3d69f",
      "range": {
        "startLine": 4590,
        "startChar": 3,
        "endLine": 4590,
        "endChar": 6
      },
      "revId": "42e0feb66221a47838237a184d9468f26e7bdea1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}