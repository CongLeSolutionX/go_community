{
  "comments": [
    {
      "key": {
        "uuid": "a110e0a0_ea4d7237",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2246,
      "author": {
        "id": 7850
      },
      "writtenOn": "2019-05-01T14:14:11Z",
      "side": 1,
      "message": "This loop can take a non-trivial amount of time for largish values of GOMAXPROCS. Local timers could expire while these loops run. Consider adding a call to checkTimers somewhere in these loops to avoid the expense of stealing G\u0027s or timers from other P\u0027s when a local timer expires and would schedule a G while we\u0027re spinning.\n\nIt seems reasonable to me to prefer scheduling a G from local timers over stealing work or timers from other Ps because it avoids costly locking and queue churn.\n\nI believe this addition would help resolve the issue described in #28808.",
      "revId": "1de77eb925054bd11432229b332baf07296db541",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12664968_30f5cda4",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2246,
      "author": {
        "id": 5206
      },
      "writtenOn": "2019-05-01T14:35:41Z",
      "side": 1,
      "message": "Interesting.  Thanks for the comment.  With the current implementation, adding more calls to checkTimers won\u0027t make any difference, because they will all use the same value for \"now\".  What would make a difference would be periodic calls to nanotime to update the current \"now\", which we could then compare with \"pollUntil\".  But nanotime is not free, so I would worry that the CPU cost of calling nanotime would exceed the benefit of slightly more accurate timers.  In practice we can\u0027t expect timer resolution to be any better than the scheduling quantum of 20 microseconds.  Is this loop plausibly going to take longer than that?",
      "parentUuid": "a110e0a0_ea4d7237",
      "revId": "1de77eb925054bd11432229b332baf07296db541",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28737a93_fb96d0c7",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2246,
      "author": {
        "id": 7850
      },
      "writtenOn": "2019-05-01T14:52:06Z",
      "side": 1,
      "message": "Yes, I think it is possible for these loops to take longer than 20 microseconds, but I don\u0027t have hard data on that particular point. But consider that the inner part of these loops is executed up to 4*(GOMAXPROCS-1) times. For the hardware mentioned in #28808 that\u0027s 220 iterations. That leaves only ~91 nanoseconds for each iteration in the worst  case. Less for larger values of GOMAXPROCS.",
      "parentUuid": "12664968_30f5cda4",
      "revId": "1de77eb925054bd11432229b332baf07296db541",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c57ce1b7_e956ea33",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2246,
      "author": {
        "id": 7850
      },
      "writtenOn": "2019-05-01T18:41:53Z",
      "side": 1,
      "message": "I think it makes sense to call `nanotime` at least one time for each iteration of the outer loop. I suggest that if no work can be stollen after one pass over all the other Ps then it makes sense to check if any local timers have expired and made local Gs runnable before making another pass over the other Ps.",
      "parentUuid": "28737a93_fb96d0c7",
      "revId": "1de77eb925054bd11432229b332baf07296db541",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}