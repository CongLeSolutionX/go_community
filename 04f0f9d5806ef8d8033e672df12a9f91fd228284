{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3eeeff78_b589aa2a",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4943,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "Note that execLock protects setting this bit? Otherwise the logic below would be buggy given multiple racing exec calls.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40cdf304_dd4386b8",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4943,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3eeeff78_b589aa2a",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea143b90_3bcb14f0",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4966,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-11T16:58:55Z",
      "side": 1,
      "message": "Only fiddle with pendingPreemptSignals on darwin and ios.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8e33440_35b140f4",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4966,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ea143b90_3bcb14f0",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89f616b3_5111b416",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 6332,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "Hm, it looks my \"return false\" suggestion was bad. This function actually returns true if gp.preempt is set (i.e., morestack will cooperatively preempt) even if we don\u0027t send a signal.\n\nSo I think this should remain as-is, returning true even if no signal was sent.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "494e71c1_0b389963",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 6332,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "89f616b3_5111b416",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b00378b5_b3ef992d",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "I think this races with the cleanup logic at https://cs.opensource.google/go/go/+/master:src/runtime/proc.go;l\u003d1975-1977;drc\u003daf0c40311e2ee33ecd24971257606f42a49cf593;bpv\u003d1;bpt\u003d1.\n\ni.e., both locations could decrement pendingPreemptSignals, making it negative.\n\nThis problem is very messy :/",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "87fecab8_c3c95cb2",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "As I understand it, pendingPreemptSignals is usually incremented once before sending a signal, and decremented once after receiving a signal. So each signal sent/received has a matching increment/decrement.\n\nThe path here skips sending the signal when pendingPreemptSignals\u003ependingPreemptDisabled. In this case, we perform the decrement before returning.",
      "parentUuid": "b00378b5_b3ef992d",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d6d62f2_1521e368",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-12T21:38:19Z",
      "side": 1,
      "message": "The linked cleanup in mexit is there is handle a race between preemptM and thread exit. Specifically:\n\nM1: calls preemptM(M2)\nM1: Sets mp.signalPending \u003d 1\nM1: Increments pendingPreemptSignals\nM2: Exits: mexit -\u003e exitThread -\u003e exit syscall\nM1: Calls signalM(M2)\n\nIn the last step, no signal is delivered since M2 doesn\u0027t exist anymore. Thus the normal reset of mp.signalPending / decrement of pendingPreemptSignals in `doSigPreempt` never runs.\n\nThus, we have this extra cleanup in mexit to reset the state if we\u0027re about to exit and missed / will miss a signal. (Note that this check is after sigblock, so we can\u0027t receive more signals at this point).\n\nThat said, why can\u0027t M1 just set mp.signalPending / pendingPreemptSignals after this check and then the same race could occur?\n\nThat is a wonderful question, I\u0027m glad you asked! mknyszek@ and I discussed this  and we don\u0027t see why it couldn\u0027t happen. (One might expect some form of synchronization that prevents preemptM from getting an M that is far enough through mexit, but that doesn\u0027t exist). Most of the callers of preemptM don\u0027t care about this case because if the M is exiting there is nothing to preempt anyway. It is just these implementation internals that care.\n\nSo this race would leave mp.signalPending and pendingPreemptSignals stale. Stale mp.signalPending is not a problem, since the M object won\u0027t be used again, but the global pendingPreemptSignals is problematic. It would result in syscall_runtime_BeforeExec spinning indefinitely.\n\nI think this could be fixed by changing pendingPreemptSignals from a global to a field on the M. I think that means that syscall_runtime_BeforeExec would need to loop over `allm` and check every M [1]. Note that mexit does remove the M from `allm` before exiting. ðŸ˜Š\n\nOnce pendingPreemptSignals is on the M, I feel like it could just be merged with mp.signalPending, though I haven\u0027t thought enough to be certain.\n\n[1] Unless this bug only applies if the thread calling exec receives a signal? I assume any thread is a problem.\n\n\u003cThis comment started as a way that a similar bug could be triggered specific to pendingPreemptDisabled. But then I found this more general issue.\u003e",
      "parentUuid": "87fecab8_c3c95cb2",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e4e7c3f_aa9b5e2f",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-12T21:45:46Z",
      "side": 1,
      "message": "Perhaps slightly simpler, we could add a flag to m.signalsPending, similar to the one being added to pendingPreemptSignals, that says that the thread will no longer be accepting signals.  Then preemptM won\u0027t increment pendingPreemptSignals.",
      "parentUuid": "5d6d62f2_1521e368",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4c7a8bf_b30b6513",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-30T23:07:09Z",
      "side": 1,
      "message": "I don\u0027t see how to make adding a flag to m.signalsPending work.\n\nIf mexit sets a flag, then it still needs to decrement pendingPreemptSignals if there\u0027s a pending signal, because preemptM didn\u0027t see the flag. But preemptM might be decrementing pendingPreemptSignals if it sees that preemption is blocked.\n\nIf we iterate `allm` in syscall_runtime_BeforeExec, then I think it:\n1. Sets a bit in mp.signalPending for every m, indicating preemption is disabled.\n2. Loops until no m has a signal pending.\n\nDo we need to acquire any locks when iterating `allm`? I see that some code just atomically loads \u0026allm, but I don\u0027t understand how iterating through `mp.alllink` is safe in that case.",
      "parentUuid": "0e4e7c3f_aa9b5e2f",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60231fda_6a79462c",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-30T23:45:00Z",
      "side": 1,
      "message": "I\u0027m thinking that in mexit we write\n\n    var pending int32\n    for {\n        old :\u003d atomic.Load(\u0026m.signalPending)\n        new :\u003d old | 2\n        if atomic.Cas(\u0026m.signalPending, old, new) {\n            pending \u003d old\n            break\n        }\n    }\n    // At this point preemptM will no longer change signalPending.\n    // pending is non-zero if it was already set.\n    if pending !\u003d 0 {\n        atomic.Xadd(\u0026pendingPreemptSignals, -1)\n    }\n\npreemptM is unchanged: we if pendingPreemptSignals is 0, we set it to 1.  If pendingPreemptSignals \u0026 1 !\u003d 0 then we are already sending a signal.  If pendingPreemptSignals \u0026 2 !\u003d 0 then the thread is exiting and we should not send a signal.\n\nIn doSigPreempt we do\n\n    for {\n       old :\u003d atomic.Load(\u0026gp.m.signalPending)\n       if old\u00261 \u003d\u003d 0 {\n           // No signal pending; thread is exiting.\n           break\n       }\n       new \u003d old \u0026^ 1\n       if atomic.Cas(\u0026gp.m.SignalPending, old, new) {\n           atomic.Xadd(\u0026pendingPreemptSignals, -1)\n           break\n       }\n    }",
      "parentUuid": "b4c7a8bf_b30b6513",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8544878b_22cd213e",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 376,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "mp.signalPending is still 1 here, but we aren\u0027t actually sending a signal. This will prevent future calls from sending a signal.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "57eb314d_fb7e345d",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 376,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Oops, I forgot to set signalPending back to 0. I believe this is safe, through the same reasoning as decrementing pendingPreemptSignals. Fixed.",
      "parentUuid": "8544878b_22cd213e",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "258639e3_a384327f",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 454,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-30T23:07:09Z",
      "side": 1,
      "message": "Does this case indicate that some m now has its signalPending set wrong (since we just received the signal destined for it) and will remain unpreemptable?\n\nIf so, this causes a problem if we iterate ms looking for pending signals.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c75e2439_1969616f",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 454,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-30T23:45:00Z",
      "side": 1,
      "message": "I think you\u0027re right.  This code has to do whatever doSigPreempt does.",
      "parentUuid": "258639e3_a384327f",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}