{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3eeeff78_b589aa2a",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4943,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "Note that execLock protects setting this bit? Otherwise the logic below would be buggy given multiple racing exec calls.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40cdf304_dd4386b8",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4943,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3eeeff78_b589aa2a",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea143b90_3bcb14f0",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4966,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-11T16:58:55Z",
      "side": 1,
      "message": "Only fiddle with pendingPreemptSignals on darwin and ios.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8e33440_35b140f4",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 4966,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ea143b90_3bcb14f0",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89f616b3_5111b416",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 6332,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "Hm, it looks my \"return false\" suggestion was bad. This function actually returns true if gp.preempt is set (i.e., morestack will cooperatively preempt) even if we don\u0027t send a signal.\n\nSo I think this should remain as-is, returning true even if no signal was sent.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "494e71c1_0b389963",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 6332,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "89f616b3_5111b416",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b00378b5_b3ef992d",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "I think this races with the cleanup logic at https://cs.opensource.google/go/go/+/master:src/runtime/proc.go;l\u003d1975-1977;drc\u003daf0c40311e2ee33ecd24971257606f42a49cf593;bpv\u003d1;bpt\u003d1.\n\ni.e., both locations could decrement pendingPreemptSignals, making it negative.\n\nThis problem is very messy :/",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "87fecab8_c3c95cb2",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "As I understand it, pendingPreemptSignals is usually incremented once before sending a signal, and decremented once after receiving a signal. So each signal sent/received has a matching increment/decrement.\n\nThe path here skips sending the signal when pendingPreemptSignals\u003ependingPreemptDisabled. In this case, we perform the decrement before returning.",
      "parentUuid": "b00378b5_b3ef992d",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d6d62f2_1521e368",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-12T21:38:19Z",
      "side": 1,
      "message": "The linked cleanup in mexit is there is handle a race between preemptM and thread exit. Specifically:\n\nM1: calls preemptM(M2)\nM1: Sets mp.signalPending \u003d 1\nM1: Increments pendingPreemptSignals\nM2: Exits: mexit -\u003e exitThread -\u003e exit syscall\nM1: Calls signalM(M2)\n\nIn the last step, no signal is delivered since M2 doesn\u0027t exist anymore. Thus the normal reset of mp.signalPending / decrement of pendingPreemptSignals in `doSigPreempt` never runs.\n\nThus, we have this extra cleanup in mexit to reset the state if we\u0027re about to exit and missed / will miss a signal. (Note that this check is after sigblock, so we can\u0027t receive more signals at this point).\n\nThat said, why can\u0027t M1 just set mp.signalPending / pendingPreemptSignals after this check and then the same race could occur?\n\nThat is a wonderful question, I\u0027m glad you asked! mknyszek@ and I discussed this  and we don\u0027t see why it couldn\u0027t happen. (One might expect some form of synchronization that prevents preemptM from getting an M that is far enough through mexit, but that doesn\u0027t exist). Most of the callers of preemptM don\u0027t care about this case because if the M is exiting there is nothing to preempt anyway. It is just these implementation internals that care.\n\nSo this race would leave mp.signalPending and pendingPreemptSignals stale. Stale mp.signalPending is not a problem, since the M object won\u0027t be used again, but the global pendingPreemptSignals is problematic. It would result in syscall_runtime_BeforeExec spinning indefinitely.\n\nI think this could be fixed by changing pendingPreemptSignals from a global to a field on the M. I think that means that syscall_runtime_BeforeExec would need to loop over `allm` and check every M [1]. Note that mexit does remove the M from `allm` before exiting. ðŸ˜Š\n\nOnce pendingPreemptSignals is on the M, I feel like it could just be merged with mp.signalPending, though I haven\u0027t thought enough to be certain.\n\n[1] Unless this bug only applies if the thread calling exec receives a signal? I assume any thread is a problem.\n\n\u003cThis comment started as a way that a similar bug could be triggered specific to pendingPreemptDisabled. But then I found this more general issue.\u003e",
      "parentUuid": "87fecab8_c3c95cb2",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e4e7c3f_aa9b5e2f",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 375,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-12T21:45:46Z",
      "side": 1,
      "message": "Perhaps slightly simpler, we could add a flag to m.signalsPending, similar to the one being added to pendingPreemptSignals, that says that the thread will no longer be accepting signals.  Then preemptM won\u0027t increment pendingPreemptSignals.",
      "parentUuid": "5d6d62f2_1521e368",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8544878b_22cd213e",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 376,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-09-11T17:02:56Z",
      "side": 1,
      "message": "mp.signalPending is still 1 here, but we aren\u0027t actually sending a signal. This will prevent future calls from sending a signal.",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "57eb314d_fb7e345d",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 376,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-09-11T21:23:16Z",
      "side": 1,
      "message": "Oops, I forgot to set signalPending back to 0. I believe this is safe, through the same reasoning as decrementing pendingPreemptSignals. Fixed.",
      "parentUuid": "8544878b_22cd213e",
      "revId": "04f0f9d5806ef8d8033e672df12a9f91fd228284",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}