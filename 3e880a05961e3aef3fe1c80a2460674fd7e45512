{
  "comments": [
    {
      "key": {
        "uuid": "441eda5a_54592cfe",
        "filename": "src/cmd/compile/internal/gc/ssa.go",
        "patchSetId": 3
      },
      "lineNbr": 1451,
      "author": {
        "id": 6875
      },
      "writtenOn": "2015-08-31T17:10:29Z",
      "side": 1,
      "message": "Do we need to decompose these operations here?  Can we introduce Mul64C/Mul128C and implement this using rewrite rules (in generic.rules, or maybe a new pass)?",
      "range": {
        "startLine": 1451,
        "startChar": 2,
        "endLine": 1451,
        "endChar": 25
      },
      "revId": "3e880a05961e3aef3fe1c80a2460674fd7e45512",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "242e4691_6b2461f2",
        "filename": "src/cmd/compile/internal/gc/ssa.go",
        "patchSetId": 3
      },
      "lineNbr": 1451,
      "author": {
        "id": 7061
      },
      "writtenOn": "2015-08-31T21:48:28Z",
      "side": 1,
      "message": "This seemed simpler, from the point-of-view of register allocation, because we could perhaps avoid the need to implement \"complex\"-valued register pairs, and elide the extract/make steps in a general-purpose phase so that it just looks like floats-to-floats.\n\nGiven that the code is machine-independent, why wouldn\u0027t we want to go directly to the floating-point equivalents?\n\nUnlike most of the transformations in generic.rules, this would also not be an optimization, but a mere expansion.\n\nThe same case for negate is not as strong since there might be floating point hardware somewhere with a negate instruction -- would you expect that expansion in generic.rules, or in the machine-specific rules?",
      "parentUuid": "441eda5a_54592cfe",
      "range": {
        "startLine": 1451,
        "startChar": 2,
        "endLine": 1451,
        "endChar": 25
      },
      "revId": "3e880a05961e3aef3fe1c80a2460674fd7e45512",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8497f201_e1bc2043",
        "filename": "src/cmd/compile/internal/gc/ssa.go",
        "patchSetId": 3
      },
      "lineNbr": 1451,
      "author": {
        "id": 5200
      },
      "writtenOn": "2015-08-31T22:49:03Z",
      "side": 1,
      "message": "I\u0027m not saying complex should make it to register allocation.  Everything should be lowered to float at some point.  I\u0027m just saying I\u0027d rather do that with rules than with Go code.  ssa.go is already very unwieldy.\n\n(Mul128f x y) -\u003e (ComplexMake\n  (Sub64f\n     (Mul64f (ComplexReal x) (ComplexReal y))\n     (Mul64f (ComplexImag x) (ComplexImag y)))\n  (Add64f\n     (Mul64f (ComplexReal x) (ComplexImag y))\n     (Mul64f (ComplexImag x) (ComplexReal y))))\n\nThis seems much easier to understand.\nThis could go in generic.rules, or we could make it another rules-generated pass (right before/after decompose?) if you\u0027d like.\n\nIf some platforms can do negate with an instruction, then we should have a Neg64f machine-independent opcode, then put\n\n(Neg64f x) -\u003e (Mul64f x (Const64f {-1.0}))\n\nIn AMD64.rules.\n\nCan\u0027t we do floating negation with pxor 0x8000000000000000?",
      "parentUuid": "242e4691_6b2461f2",
      "range": {
        "startLine": 1451,
        "startChar": 2,
        "endLine": 1451,
        "endChar": 25
      },
      "revId": "3e880a05961e3aef3fe1c80a2460674fd7e45512",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "242e4691_ae1b777a",
        "filename": "src/cmd/compile/internal/gc/ssa.go",
        "patchSetId": 3
      },
      "lineNbr": 1451,
      "author": {
        "id": 7061
      },
      "writtenOn": "2015-09-01T00:47:20Z",
      "side": 1,
      "message": "As long as  generic.rules comes before CSE, I am okay writing these expansions in CSE.  The one for complex64 multiply introduces CSEs otherwise, and I think that adding an entire pass for the sake of incrementally beautifying ssa.go is not worth it.\n\nBut if you have a strong preference, I\u0027ll do it in generic.rules.  ssa.go might also profit from a round of cleanup -- for example, I\u0027ve been substituting opregreg wherever I notice the opportunity.\n\nFor negation, I was copying what the existing compiler does.  I don\u0027t see why PXOR should not work, and I guess I can try that and see if any tests fail.\n\nOne glitch I am running into as I start to implement this is \"well, if you have a special opcode for multiplication, what about division?  What about addition and subtraction?\"  I think we shouldn\u0027t discount the advantage of not even specifying nodes for complex arithmetic operations.  If don\u0027t exist, they can\u0027t ever be used incorrectly or documented wrong.",
      "parentUuid": "8497f201_e1bc2043",
      "range": {
        "startLine": 1451,
        "startChar": 2,
        "endLine": 1451,
        "endChar": 25
      },
      "revId": "3e880a05961e3aef3fe1c80a2460674fd7e45512",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "441eda5a_f4471815",
        "filename": "src/cmd/compile/internal/gc/ssa.go",
        "patchSetId": 3
      },
      "lineNbr": 1602,
      "author": {
        "id": 6875
      },
      "writtenOn": "2015-08-31T17:10:29Z",
      "side": 1,
      "message": "Same here, introduce Neg64F and rewrite it to the multiply required.",
      "range": {
        "startLine": 1602,
        "startChar": 3,
        "endLine": 1602,
        "endChar": 21
      },
      "revId": "3e880a05961e3aef3fe1c80a2460674fd7e45512",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}