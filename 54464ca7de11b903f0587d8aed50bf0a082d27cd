{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "78ded31c_cff94557",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-04-18T15:55:29Z",
      "side": 1,
      "message": "These rules all look fine.\n\nI\u0027m confused as to why you\u0027re seeing the assembly differences. What architecture are you looking at? Both amd64 and arm64 do the x+(-y)\u003d\u003ex-y rewrite in the architecture-dependent rules. So also doing that in the generic rules (which is a good idea, thanks) shouldn\u0027t make a difference.\n",
      "revId": "54464ca7de11b903f0587d8aed50bf0a082d27cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dcc6bc0_e18af27f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-18T15:55:50Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d54464ca7",
      "tag": "autogenerated:trybots~beginning",
      "revId": "54464ca7de11b903f0587d8aed50bf0a082d27cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb5d8c41_25e53902",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-18T16:08:27Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "6dcc6bc0_e18af27f",
      "tag": "autogenerated:trybots~happy",
      "revId": "54464ca7de11b903f0587d8aed50bf0a082d27cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "38134e03_d92b106a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 55763
      },
      "writtenOn": "2022-04-18T17:01:04Z",
      "side": 1,
      "message": "I was looking at amd64. I can\u0027t find the original snippet.\nHere is an example that is improved by this patch:\n  func A(x,b uint64) uint64 {\n    return (x + -b) + b // \u003d\u003e x\n  }\n\nBefore:\n\n  SUB BX, AX\n  ADD BX, AX\n  RET\n\nAfter:\n\n  RET\n\nThat because the compiler only knows how to remove x-b+b in the generic pass.\nHowever in the generic pass the code still looks like this x+(-b)+b which isn\u0027t directly optimisable.\nSo then later in the AMD64 pass x+(-b) \u003d\u003e x-b is performed, but not x-b+b because only generic knows how to do that.\n\nOther possible reasons (speculative, I don\u0027t have any example), is that if the ADD gets replaced by an LEA for whatever reason, the x+(-b) \u003d\u003e x-b would only understand ADD instructions, not LEAs.",
      "parentUuid": "78ded31c_cff94557",
      "revId": "54464ca7de11b903f0587d8aed50bf0a082d27cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}