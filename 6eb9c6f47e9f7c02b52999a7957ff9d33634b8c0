{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b887a515_9a525592",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 58123
      },
      "writtenOn": "2024-11-19T09:14:42Z",
      "side": 1,
      "message": "PTAL.",
      "revId": "6eb9c6f47e9f7c02b52999a7957ff9d33634b8c0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "672d21ac_f189998e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-11-19T21:49:06Z",
      "side": 1,
      "message": "I\u0027m not sure I understand why this would be ok. Suppose we have:\n```\np1 \u003d (LocalAddr [a] mem1)\nmem2 \u003d (Store p1 0 mem1)   // initial zeroing\np2 : (LocalAddr [a] mem2)\nmem3 \u003d (Store p2 ptr mem2)   // user\u0027s code a\u003dptr\n```\n\nIf we determine that the zeroing is dead, then we get rid of it (and p1, as it is now dead). But then we\u0027re in a situation where we materialize the address of `a` before it has been initialized. If we suspend between the second LocalAddr and the last Store, p2 points to an uninitialized slot. That is not great.\n\nOf course, this happens already with the first 2 instructions. We\u0027re saved by the fact that there are no calls or any other suspension points between the LocalAddr and the zeroing, and that scanning during an interrupt is conservative. I\u0027m not 100% sure that the same guarantee is available for the second two instructions. But maybe?\n```\nvar a *int\n.. other stuff ..\na \u003d ptr\n```\n\nThe compiler guarantees that there\u0027s nothing bad in between the LocalAddr and the zeroing of `a`. But can there be bad stuff between the LocalAddr and the store in the assignment to `a`? I suspect there can\u0027t be, and this is ok, but I\u0027m not certain.\n\nThis would be a lot safer if it only pertained to pointerless objects.",
      "revId": "6eb9c6f47e9f7c02b52999a7957ff9d33634b8c0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "faf5238d_62f115fd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 58123
      },
      "writtenOn": "2024-11-20T09:45:42Z",
      "side": 1,
      "message": "Yeah, I think pointers are a point that needs more attention. But first I want to say that there is a piece of code confuses me.\n\nI found, since [CL 578376](https://go-review.googlesource.com/c/go/+/578376), the DSE code has ignored the OpLocalAddrs which has the same Aux, except the first one in value order. For this code:\n```\nif v.Op \u003d\u003d OpLocalAddr {\n\tif _, ok :\u003d localAddrs[v.Aux]; !ok {\n\t\tlocalAddrs[v.Aux] \u003d v\n\t} else {\n\t\tcontinue\n\t}\n}\n```\nThe `continue` in the `else` block skips the following code which adds the memory arg of OpLocalAddr to `loadUse`. So, only the first OpLocalAddr in value order is not ignored, and its memory arg is added to `loadUse`.\n\nAccording to my understanding, if we just want to teach DSE about equivalent LocalAddrs, then there should be no `else` and `continue` here, and all OpLocalAddrs will be treat as load. Like this:\n```\nif v.Op \u003d\u003d OpLocalAddr {\n\tif _, ok :\u003d localAddrs[v.Aux]; !ok {\n\t\tlocalAddrs[v.Aux] \u003d v\n\t}\n}\n```\nIf we do not want to treat OpLocalAddr as load, then we should remove the else block and put the `continue` in the outter if block. Just like what I did in this CL.\n\nSo, what\u0027s the point of only treat the first OpLocalAddr in value order as load? This confuses me. This code also rely on the order of the values, and the compiler behaves differently when compile with or w/o `-gcflags\u003d-d\u003dssa/check/on`, as I described in [issue 70409](https://go.dev/issue/70409).\n\nIs there something wrong with my understanding?\n\nFinally, for the pointer, I\u0027m not sure if it\u0027s a risk here. If so, it looks the HEAD code also has this risk. Maybe?",
      "parentUuid": "672d21ac_f189998e",
      "revId": "6eb9c6f47e9f7c02b52999a7957ff9d33634b8c0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "833b4dca_b2273584",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-11-21T16:57:55Z",
      "side": 1,
      "message": "I agree, probably continuing unconditionally is the right thing to do.\n\n\u003e This code also rely on the order of the values, and the compiler behaves differently when compile with or w/o -gcflags\u003d-d\u003dssa/check/on, as I described in issue 70409.\n\nI think if we fixed the continue this would be ok. Which representative LocalAddr is chosen doesn\u0027t matter, so that part is fine.",
      "parentUuid": "faf5238d_62f115fd",
      "revId": "6eb9c6f47e9f7c02b52999a7957ff9d33634b8c0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9cb049c0_c1d72e83",
        "filename": "test/codegen/issue70409.go",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 55763
      },
      "writtenOn": "2024-11-18T10:05:42Z",
      "side": 1,
      "message": "I don\u0027t understand the point of this test.\nShould not that be `// amd64:\"MOVQ\",-\"MOVB\"` ? Also I\u0027m surprised this is not one line down.",
      "revId": "6eb9c6f47e9f7c02b52999a7957ff9d33634b8c0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69216441_d2082cee",
        "filename": "test/codegen/issue70409.go",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 58123
      },
      "writtenOn": "2024-11-18T10:55:07Z",
      "side": 1,
      "message": "Thanks for reply. This tests whether the zeroing code for the return value can be removed. Please  see my description for [issue 70409](https://go.dev/issue/70409).",
      "parentUuid": "9cb049c0_c1d72e83",
      "revId": "6eb9c6f47e9f7c02b52999a7957ff9d33634b8c0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1fd90d9c_0fc2f8a0",
        "filename": "test/codegen/issue70409.go",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 55763
      },
      "writtenOn": "2024-11-18T11:01:44Z",
      "side": 1,
      "message": "I see thx",
      "parentUuid": "69216441_d2082cee",
      "revId": "6eb9c6f47e9f7c02b52999a7957ff9d33634b8c0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}