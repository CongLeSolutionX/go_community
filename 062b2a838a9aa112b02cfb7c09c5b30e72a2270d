{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "546cdac9_b3224fff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-09T15:22:56Z",
      "side": 1,
      "message": "Please make sure you have adhered to all the items in this list.",
      "range": {
        "startLine": 33,
        "startChar": 2,
        "endLine": 33,
        "endChar": 63
      },
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22cb57fa_f6513e11",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-09T15:22:56Z",
      "side": 1,
      "message": "It is not clear to me that we want to do this.\n\nWe might want pointers that have different types to return true here. For instance, *struct{uint32} and *uint32.\n\nAlso, in the compiler type identity isn\u0027t pointer equality. The same program type might be represented several times as different objects (with the same content). See cmd/compile/internal/types/identity.go.\n\nAre there any cases where isSamePtr would have returned true, but this change causes it to return false? (Instrument the compiler for that and run all.bash to see.)",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a04543bf_b60583a5",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 64033
      },
      "writtenOn": "2023-11-10T12:28:34Z",
      "side": 1,
      "message": "I downloaded this CL and ran all.bash, but no issues were found.",
      "parentUuid": "22cb57fa_f6513e11",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8063b191_50f56927",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 66353
      },
      "writtenOn": "2023-11-11T15:01:31Z",
      "side": 1,
      "message": "I did those experiments:\n1. replace `if p1.Op !\u003d p2.Op` with `if p1.Op !\u003d p2.Op || p1.Type !\u003d p2.Type` and run all.bash, all is ok;\n2. when the original isSamePtr implement returned true, p1.Type is equal to p2.Type in all cases when running all.bash;\nso I think if p1.Type is not equal to p2.Type, they must not be the same ptr. and this pr will optimize the performance of function `isSamePtr`.\nI didn\u0027t understand why we might want pointers that have different types to return true here. For instance, *struct{uint32} and *uint32? Could you please give some more comments?",
      "parentUuid": "a04543bf_b60583a5",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fed76d27_35f7c7cd",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-11T16:01:34Z",
      "side": 1,
      "message": "\u003e when the original isSamePtr implement returned true, p1.Type is equal to p2.Type in all cases when running all.bash;\n\nThanks, if that\u0027s the case then this should be ok.\n\n\u003e I didn\u0027t understand why we might want pointers that have different types to return true here. For instance, *struct{uint32} and *uint32? Could you please give some more comments?\n\nI was thinking about cases like:\n\nfunc f() {\n\tvar x struct{ a uint32 }\n\tp :\u003d \u0026x\n\tp.a \u003d 0\n\tg(p)\n}\n\n//go:noescape\nfunc g(p any)\n\nDoes it get rid of the duplicate write of 0? In this case we\u0027re writing to a uint32 but the zeroing happened on a struct{uint32}.\nThat particular case we already don\u0027t do a good job on, unfortunately. But that\u0027s the kind of thing I was worried about.",
      "parentUuid": "8063b191_50f56927",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}