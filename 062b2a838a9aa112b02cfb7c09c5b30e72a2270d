{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "546cdac9_b3224fff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-09T15:22:56Z",
      "side": 1,
      "message": "Please make sure you have adhered to all the items in this list.",
      "range": {
        "startLine": 33,
        "startChar": 2,
        "endLine": 33,
        "endChar": 63
      },
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22cb57fa_f6513e11",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-09T15:22:56Z",
      "side": 1,
      "message": "It is not clear to me that we want to do this.\n\nWe might want pointers that have different types to return true here. For instance, *struct{uint32} and *uint32.\n\nAlso, in the compiler type identity isn\u0027t pointer equality. The same program type might be represented several times as different objects (with the same content). See cmd/compile/internal/types/identity.go.\n\nAre there any cases where isSamePtr would have returned true, but this change causes it to return false? (Instrument the compiler for that and run all.bash to see.)",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a04543bf_b60583a5",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 64033
      },
      "writtenOn": "2023-11-10T12:28:34Z",
      "side": 1,
      "message": "I downloaded this CL and ran all.bash, but no issues were found.",
      "parentUuid": "22cb57fa_f6513e11",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8063b191_50f56927",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 66353
      },
      "writtenOn": "2023-11-11T15:01:31Z",
      "side": 1,
      "message": "I did those experiments:\n1. replace `if p1.Op !\u003d p2.Op` with `if p1.Op !\u003d p2.Op || p1.Type !\u003d p2.Type` and run all.bash, all is ok;\n2. when the original isSamePtr implement returned true, p1.Type is equal to p2.Type in all cases when running all.bash;\nso I think if p1.Type is not equal to p2.Type, they must not be the same ptr. and this pr will optimize the performance of function `isSamePtr`.\nI didn\u0027t understand why we might want pointers that have different types to return true here. For instance, *struct{uint32} and *uint32? Could you please give some more comments?",
      "parentUuid": "a04543bf_b60583a5",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fed76d27_35f7c7cd",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-11T16:01:34Z",
      "side": 1,
      "message": "\u003e when the original isSamePtr implement returned true, p1.Type is equal to p2.Type in all cases when running all.bash;\n\nThanks, if that\u0027s the case then this should be ok.\n\n\u003e I didn\u0027t understand why we might want pointers that have different types to return true here. For instance, *struct{uint32} and *uint32? Could you please give some more comments?\n\nI was thinking about cases like:\n\nfunc f() {\n\tvar x struct{ a uint32 }\n\tp :\u003d \u0026x\n\tp.a \u003d 0\n\tg(p)\n}\n\n//go:noescape\nfunc g(p any)\n\nDoes it get rid of the duplicate write of 0? In this case we\u0027re writing to a uint32 but the zeroing happened on a struct{uint32}.\nThat particular case we already don\u0027t do a good job on, unfortunately. But that\u0027s the kind of thing I was worried about.",
      "parentUuid": "8063b191_50f56927",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "585b2df8_3d80b1a6",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 66353
      },
      "writtenOn": "2023-11-13T15:11:11Z",
      "side": 1,
      "message": "Hi Keith Randall, I wrote an example and observe its ssa html, here is the detail：\n`\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a struct{ ele int32 }\n\tp :\u003d \u0026a\n\tp.ele \u003d 0\n\tfmt.Println(p)\n}\n`\nand the ssa.html is here:\n\nb1:-\nv1 (?) \u003d InitMem \u003cmem\u003e\nv2 (?) \u003d SP \u003cuintptr\u003e\nv3 (?) \u003d SB \u003cuintptr\u003e\nv4 (?) \u003d Addr \u003c*uint8\u003e {type:struct { main.ele int32 }} v3\nv5 (6) \u003d StaticLECall \u003c*struct { ele int32 },mem\u003e {AuxCall{runtime.newobject}} [16] v4 v1\nv6 (6) \u003d SelectN \u003cmem\u003e [1] v5\nv7 (6) \u003d SelectN \u003c*struct { ele int32 }\u003e [0] v5 (\u0026a[*struct { ele int32 }], p[*struct { ele int32 }])\nv9 (?) \u003d Const32 \u003cint32\u003e [0]\nv12 (8) \u003d OffPtr \u003c*int32\u003e [0] v7\nv14 (?) \u003d ConstInterface \u003cany\u003e\nv15 (?) \u003d ArrayMake1 \u003c[1]any\u003e v14\nv20 (?) \u003d Addr \u003c*uint8\u003e {type:*struct { main.ele int32 }} v3\nv21 (9) \u003d IMake \u003cany\u003e v20 v7\nv23 (?) \u003d Const64 \u003cint\u003e [0] (fmt.n[int])\nv24 (?) \u003d Const64 \u003cint\u003e [1]\nv29 (9) \u003d IsSliceInBounds \u003cbool\u003e v23 v24\nv34 (?) \u003d ConstInterface \u003cerror\u003e (fmt.err[error])\nv37 (?) \u003d Addr \u003c*uint8\u003e {go:itab.*os.File,io.Writer} v3\nv38 (?) \u003d Addr \u003c**os.File\u003e {os.Stdout} v3\nv8 (?) \u003d StructMake1 \u003cstruct { ele int32 }\u003e v9\nv10 (6) \u003d Store \u003cmem\u003e {struct { ele int32 }} v7 v8 v6\nv11 (8) \u003d NilCheck \u003cvoid\u003e v7 v10\nv13 (8) \u003d Store \u003cmem\u003e {int32} v12 v9 v10\nv16 (9) \u003d VarDef \u003cmem\u003e {.autotmp_10} v13\nv17 (9) \u003d LocalAddr \u003c*[1]any\u003e {.autotmp_10} v2 v16\nv18 (9) \u003d Store \u003cmem\u003e {[1]any} v17 v15 v16\nv19 (9) \u003d LocalAddr \u003c*[1]any\u003e {.autotmp_10} v2 v18\nv22 (9) \u003d NilCheck \u003cvoid\u003e v19 v18\nv25 (9) \u003d PtrIndex \u003c*any\u003e v19 v23\nv26 (9) \u003d Store \u003cmem\u003e {any} v25 v21 v18\nv27 (9) \u003d NilCheck \u003cvoid\u003e v19 v26\nv28 (9) \u003d Copy \u003c*any\u003e v19\nIf v29 → b2 b3 (likely) (9)\n\nwe can see that address v12 is equal to v7, they are actually both point to a.ele, but their type is not the same. So I think this pr is not solid, how do you think?\n@khr@golang.org",
      "parentUuid": "fed76d27_35f7c7cd",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8577cc11_542a3a10",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-13T16:20:06Z",
      "side": 1,
      "message": "Does the v13 store (or the v10 one, not sure which gets removed by dead-store elimination) not get removed with this CL, but does without this CL?",
      "parentUuid": "585b2df8_3d80b1a6",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f7b050b_e736e2ab",
        "filename": "src/cmd/compile/internal/ssa/rewrite.go",
        "patchSetId": 2
      },
      "lineNbr": 825,
      "author": {
        "id": 66353
      },
      "writtenOn": "2023-11-14T01:38:36Z",
      "side": 1,
      "message": "Hi Keith Randall, v13 was removed in opt pass:\n\nb1:-\n v1 (?) \u003d InitMem \u003cmem\u003e\n v2 (?) \u003d SP \u003cuintptr\u003e\n v3 (?) \u003d SB \u003cuintptr\u003e\n v4 (?) \u003d Addr \u003c*uint8\u003e {type:struct { main.ele int32 }} v3\n v5 (+6) \u003d StaticLECall \u003c*struct { ele int32 },mem\u003e {AuxCall{runtime.newobject}} \n [16] v4 v1\n v6 (6) \u003d SelectN \u003cmem\u003e [1] v5\n v7 (6) \u003d SelectN \u003c*struct { ele int32 }\u003e [0] v5 (p[*struct { ele int32 }], \n \u0026a[*struct { ele int32 }])\n v16 (9) \u003d VarDef \u003cmem\u003e {.autotmp_10} v6\n v17 (9) \u003d LocalAddr \u003c*[1]any\u003e {.autotmp_10} v2 v16\n v20 (?) \u003d Addr \u003c*uint8\u003e {type:*struct { main.ele int32 }} v3\n v21 (9) \u003d IMake \u003cany\u003e v20 v7\n v23 (?) \u003d Const64 \u003cint\u003e [0] (fmt.n[int])\n v24 (?) \u003d Const64 \u003cint\u003e [1]\n v37 (?) \u003d Addr \u003c*uint8\u003e {go:itab.*os.File,io.Writer} v3\n v38 (?) \u003d Addr \u003c**os.File\u003e {os.Stdout} v3\n v30 (?) \u003d ConstNil \u003cuintptr\u003e\n v45 (?) \u003d ConstNil \u003c*uint8\u003e\n v14 (?) \u003d IMake \u003cany\u003e v30 v45\n v18 (9) \u003d Store \u003cmem\u003e {any} v17 v14 v16\n v19 (9) \u003d LocalAddr \u003c*[1]any\u003e {.autotmp_10} v2 v18\n v22 (+9) \u003d NilCheck \u003cvoid\u003e v19 v18\n v25 (9) \u003d OffPtr \u003c*any\u003e [0] v19\n v26 (9) \u003d Store \u003cmem\u003e {any} v25 v21 v18\n v27 (9) \u003d NilCheck \u003cvoid\u003e v19 v26\nFirst → b4 b3 (likely) (9)",
      "parentUuid": "8577cc11_542a3a10",
      "revId": "062b2a838a9aa112b02cfb7c09c5b30e72a2270d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}