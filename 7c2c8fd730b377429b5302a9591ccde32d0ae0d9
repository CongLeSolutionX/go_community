{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9033d20b_74c65f9f",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-09-01T16:15:02Z",
      "side": 1,
      "message": "This seems like an incomplete solution ‚Äî we shouldn\u0027t make the tests 2x slower in JSON mode either.\n\nI think we need to better understand why this sequencing was thought to be needed in CL 448357 in the first place. (Maybe we can just remove it?)",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ee91cb0_48b97f19",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 52073
      },
      "writtenOn": "2023-09-01T16:42:53Z",
      "side": 1,
      "message": "I agree we should fix both cases as well; this seemed like an easy win in the meantime while we discussed the longer term solution.\n\nMy understanding is it is to make sure the `{\"Action\":\"start\"}` are printed in order. I don\u0027t know why we need that, though -- seems reasonable to allow them out of order. That being said the `print` action is ordered so maybe that is the motivation.\n\nIf we do really want to keep it, I think we can do it efficiently, we would just need a new explicit \"Start\" action that tests can depend on instead of this implicit dependency that isn\u0027t handled buy the actiongraph. But that seems like a lot of work if we do not actually need to sequence them.\n\nI am open to either approach or alternatives, let me know which is preferred",
      "parentUuid": "9033d20b_74c65f9f",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09511b09_16b3e186",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 5167
      },
      "writtenOn": "2023-09-01T17:45:03Z",
      "side": 1,
      "message": "The start events are ordered because that\u0027s the only way a consumer of the JSON output can reconstruct the order that packages were passed to the go tool itself. This is valuable when presenting test results to a user, especially across multiple runs (like in a CI system).\n\nFor some context, this originally came out of work I was doing in dist to do a streaming conversion of the JSON test output back to the text format. There was no way to make this deterministic and to match the package sequence of the text format without these ordered start events.\n\nI agree that blocking workers is certainly an unfortunate (and unintended!) consequence and we should find some other way to implement this.\n\nFWIW, I had a similar problem in dist in one of the many rewrites I was doing it to. I wound up adding a separate buffer sequencing layer that understood the first line of each buffer had to be released to the output stream in order, and the lines within any buffer had to be released in order, but that otherwise lines could be released immediately. That resulted in potentially unbounded buffering, but didn\u0027t require anything to block.",
      "parentUuid": "6ee91cb0_48b97f19",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73221925_ee87ce5a",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 52073
      },
      "writtenOn": "2023-09-01T18:46:58Z",
      "side": 1,
      "message": "Now that I think about it, my idea of a new Start action isn\u0027t great. It does ensure the starts are printed in order but the actual test run may happen way later.\n\nOne way around this could be to add some mechanism to ensure an action happens immediately after another one. That seems fairly complex though, so I would want some. directional agreement before going down that route",
      "parentUuid": "09511b09_16b3e186",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4dbb4f7_917e1c57",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 52073
      },
      "writtenOn": "2023-09-01T18:46:58Z",
      "side": 1,
      "message": "Hmm now that I think about it - my proposed fix to this if we wanted to keep the ordering was to make a new Start action. But that doesn\u0027t *really* solve the problem. It ensures we print the starts in order, but we may not schedule the actual work until an arbitrary later time. Seems like for it to work we would need a way to have 2 actions that are guaranteed to be started back-to-back maybe.",
      "parentUuid": "09511b09_16b3e186",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a684a6fb_dfb129ad",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-09-01T18:47:32Z",
      "side": 1,
      "message": "Ah, that sounds very similar to the approach we took in CL 317975.\n\n(The `sequencer` and `reporter` added in that CL form a sort of ‚Äúoutput monad‚Äù that buffers up the fragments.)",
      "parentUuid": "09511b09_16b3e186",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6f4fd68_f67f2b84",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 52073
      },
      "writtenOn": "2023-09-01T19:05:42Z",
      "side": 1,
      "message": "\u003e But that doesn\u0027t really solve the problem\n\nI suppose it does solve \"can reproduce text format from json\", just not \"Start means the test started\". Not sure if we care about the latter",
      "parentUuid": "a684a6fb_dfb129ad",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1cfab62_970f2dc7",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-09-01T19:40:18Z",
      "side": 1,
      "message": "Yeah. I would kind of prefer to have the property ‚Äústart means the test started‚Äù, which suggests that we need some other approach for reconstructing the non-JSON output.",
      "parentUuid": "b6f4fd68_f67f2b84",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c0c434e_2276b222",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 5167
      },
      "writtenOn": "2023-09-03T20:29:01Z",
      "side": 1,
      "message": "That does look similar to the `sequencer`/`reporter` in CL 317975, except that if I\u0027m reading that code right, it looks like it blocks the writer until its turn, whereas my approach in dist buffers when necessary so writers never block.\n\n\u003e I would kind of prefer to have the property ‚Äústart means the test started‚Äù, which suggests that we need some other approach for reconstructing the non-JSON output.\n\nSorry, I\u0027m not sure I understand the distinction being made here. Why can\u0027t the start event both mean that the test started and be released to stdout in package order? That means some buffering is necessary (or blocking, but that\u0027s what we\u0027re trying to fix üòä), but I don\u0027t see the problem with that.",
      "parentUuid": "a1cfab62_970f2dc7",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e170779_e95ce4d5",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 52073
      },
      "writtenOn": "2023-09-06T16:51:44Z",
      "side": 1,
      "message": "\u003e Sorry, I\u0027m not sure I understand the distinction being made here. Why can\u0027t the start event both mean that the test started and be released to stdout in package order?\n\nI don\u0027t think this is impossible hypothetically, but referring to my idea above to solve it by introducing a new standalone Start action; the problem with that would be we may execute the Start and the Run action very far apart.\n\nAn alternative approach like buffering would likely solve that.\n\n--\n\nI worked a bit on a prototype. Instead of blocking on `r.prev`, I had text2json buffer up write events while r.prev is open; on exit it flushes out events. This fixes the blocking but doesn\u0027t fully retain the ordering, since we flush the events when the action is complete. It seems like to solve this we would need a global buffer, not a per-action one. This adds up to quite a bit of complexity.\n\nGiven the original intent was just to be able to order the events from the JSON output, do we really need this to be \"Start\"? Can we just print out all the packages at the start with some `Processed` action type or something?",
      "parentUuid": "8c0c434e_2276b222",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9cbbf78_b2128b39",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-09-06T17:02:00Z",
      "side": 1,
      "message": "\u003e Why can\u0027t the start event both mean that the test started and be released to stdout in package order?\n\nThat would mean that the events could be written very far out of order compared to their timestamps.\n\nMore importantly, though, if something times out (or gets killed ‚Äî perhaps due to an OOM condition) before the buffer is flushed, that could mean that someone reading the logs ends up missing a very relevant event.\n\nAustin, could you give some more detail about your goal in reconstructing the output? It\u0027s not immediately obvious to me why a consumer of the log would need to reconstruct the `go` command line rather than, say, prepending that command line to the output as another JSON event.",
      "parentUuid": "1e170779_e95ce4d5",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "512b4b18_79c10554",
        "filename": "src/cmd/go/internal/test/test.go",
        "patchSetId": 2
      },
      "lineNbr": 1221,
      "author": {
        "id": 5167
      },
      "writtenOn": "2023-09-06T19:22:57Z",
      "side": 1,
      "message": "That\u0027s true that buffering would cause them to be out of timestamp order. Each individual package would still be in timestamp order, so I\u0027m not sure if that matters or not.\n\nIf an individual test times out, that information should go into its buffer and eventually be flushed out by the go tool. If there\u0027s some higher-level timeout imposed by, say, a CI system, or an OOM, then I agree that it would lose buffered information. That\u0027s true in the current text output, too, right?\n\nMy goal in reconstructing the output isn\u0027t about the full `go` command line, just the order of packages. What started all of this was dist\u0027s `go test std cmd` invocation. My goal is just that any user presentation of the output of `go test std cmd` be able to maintain the deterministic and original order of the packages from run to run. In dist, I was specifically converting the JSON output back to text on the fly, and was getting non-deterministic package order before we added the start events. By the same applies in, for example, LUCI\u0027s test results list.\n\nI\u0027m not opposed to adding some other mechanism for this. It\u0027s just that this is the primary reason the start events were added in the first place (getting a little more timing information was a secondary benefit). We could emit some other event, perhaps without a timestamp, that serves only to provide the order. One nice property of \"start\" events is that a consumer can put packages in \"first seen\" order, which still works reasonable well without \"start\" events. I suppose one nice thing about emitting a complete package list up front would be that an interactive \"test progress\" tool (e.g., https://github.com/aclements/gotest) could show progress through packages.",
      "parentUuid": "d9cbbf78_b2128b39",
      "revId": "7c2c8fd730b377429b5302a9591ccde32d0ae0d9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}