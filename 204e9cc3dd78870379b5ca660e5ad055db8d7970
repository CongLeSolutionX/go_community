{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0dc8700d_2d83e45e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-11T15:04:29Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d204e9cc3",
      "tag": "autogenerated:trybots~beginning",
      "revId": "204e9cc3dd78870379b5ca660e5ad055db8d7970",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72dc2b98_dcf7a3db",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-11T15:16:29Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "0dc8700d_2d83e45e",
      "tag": "autogenerated:trybots~happy",
      "revId": "204e9cc3dd78870379b5ca660e5ad055db8d7970",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6443586c_623cfadc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 7061
      },
      "writtenOn": "2022-04-11T17:40:45Z",
      "side": 1,
      "message": "I am not 100% sure of this CL, because though it does nicely solve the storage consumption problem (95% reduction in heap size for the example buggy program), it slows down compilation about 2% on average, but as much as 35% for one outlier benchmark program (CommonMark Markdown).\n\nSee https://perf.golang.org/search?q\u003dupload:20220411.12\n\nThe debugging quality seems to be about the same; I hand-verified a few examples, and fixed one particularly in-your-face error that I cam across.  The differences come from a minor change to \"canMerge\" (I think the old one allowed a merge when registers did not overlap properly) and in buildLocationLists I moved processing of changedVars out from under a conditional, because otherwise there was a risk of those changes getting processed at an endpoint that was not BlockStart.  These should be improvements, but they are also changes.\n\nI have ideas for further work, but I\u0027ve already put a lot of time into this and wonder if this should go in to deal with the space problem solved, and then deal with the time spent as a separate problem.\n\nI\u0027ve looked into the extra cost, and it appears to come from tree iterators.  It does not come from the use of an interface for the \"value\" field in the tree; I\u0027ve done that experiment already.  I have three ideas for cutting the time used\n\n(1) hack on the tree iterator.\n\n(2) currently there is linear-sized transformation out of the shared data structure coming into either the liveness analysis or the location list generation.  Add register sets to the begin/end block state information and merge those, modify the other code to use the shared (applicative tree) data structures, and eliminate the transformations.  This is the most tempting thing to try.\n\n(3) the whole thing still does linear work to obtain the \"changed\" set at the beginning of each block, hence it is potentially quadratic.  I think we could do something propagating deltas up and down dominator trees -- the difference between a block and its textual predecessor can be formulated as the difference in deltas from their common dominator.  There\u0027s issues of path compression and hand waving that need to be figured out.",
      "revId": "204e9cc3dd78870379b5ca660e5ad055db8d7970",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}