{
  "comments": [
    {
      "key": {
        "uuid": "ab0ee3c7_6c21e72a",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 180,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "Why is this separate (not a) map necessary? If I understand correctly, the necessary sequence is:\n\n1. disableSignal, which sets the action in the kernel\n2. Wait for signal quiescence.\n3. Remove the signal channel.\n\nCan you just leave the handler in handlers.m while waiting for quiescence, and then remove it from handlers.m?",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "142ecc34_10a3f501",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 180,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Code in, e.g., cancel will loop through the map and make decisions based on h.want.  That code could of course run during signalWaitUntilIdle.  If we leave the channel in handlers.m without changing h.want, then cancel will do the wrong thing.  If we leave the channel in handlers.m and clear h.want, then the code in process won\u0027t know which channels should receive the signal.\n\nAdded a comment on the stopping field in handlers.",
      "parentUuid": "ab0ee3c7_6c21e72a",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95fa72b1_108f9fd2",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T20:24:36Z",
      "side": 1,
      "message": "Is there a risk of starvation here? (What happens if the signal.loop goroutine can\u0027t keep up with the rate of arriving signals?)\n\nAs far as I can tell, we\u0027re guaranteed to eventually hit sigIdle and sigSending, but not necessarily sigReceiving (which is whal signalWaitUntilIdle blocks on).",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5cfb101_89fa6930",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 320,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "No \\n",
      "range": {
        "startLine": 320,
        "startChar": 35,
        "endLine": 320,
        "endChar": 38
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c6b1930_7429f339",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 320,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a5cfb101_89fa6930",
      "range": {
        "startLine": 320,
        "startChar": 35,
        "endLine": 320,
        "endChar": 38
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0e1ec24_10a1588c",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 355,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "Comment what the sleep is doing.",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e78c91cd_d3148d60",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 355,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0e1ec24_10a1588c",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a76c1bd_2cec9c31",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T20:24:36Z",
      "side": 1,
      "message": "It appears that \"recv\" is not accessed atomically (because it is synchronized externally).\n\nI have some lingering confusion around \"mask\" and \"recv\". Why are they separate arrays at all, given that the mask is updated atomically? (Is it so that we can avoid atomic ops in the fast path of signal_recv, to avoid cas-loop-induced starvation somewhere, or some other reason?)",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 37,
        "endChar": 66
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "818ecc91_e3e92e15",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "Could you elaborate on what\u0027s reading/writing these fields that needs the atomic synchronization? What\u0027s ensuring there are no write races on wanted and ignored? The comment is written from the perspective of \"what\u0027s not strictly necessary\", which I think turns the argument on its head.",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4cfee79c_de4569ac",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "818ecc91_e3e92e15",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a6f80bdc_f2d6d81f",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "These loads don\u0027t have to be atomic, right?",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb8a5004_811b1cf5",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a6f80bdc_f2d6d81f",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65fec4a0_2a4082fd",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 215,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T20:24:36Z",
      "side": 1,
      "message": "It looks like \"wanted\" and \"ignored\" are more-or-less complements of each other.\nIs there a risk of races from the skew between these atomic updates?\n\nsig.wanted is read in sigsend, and sig.ignored is read in signal_ignored (which is called after sigsend returns).\n\nI think that implies a (rare) race if signal_ignore executes simultaneously with sighandler for a signal for which _SigKill or _SigThrow is set.\n\n1) signal_ignore clears sig.wanted\n2) sighandler returns false from sigsend\n3) sighandler calls signal_ignored and returns false\n4) sighandler begins killing or throwing\n5) signal_ignore sets sig.ignored\n\nI can see two alternatives.\n\nA) We could combine \"wanted\" and \"ignored\" into a single interleaved array (so that updates to \"wanted\" and \"ignored\" for the same signal occur in a single atomic op). That somewhat complicates the code, but I don\u0027t see anything that makes it downright infeasible.\n\nB) We could set \"wanted\" instead of \"ignored\" for ignored signals. That would produce spurious wakeups in signal_recv, but as far as I can tell they turn into no-ops anyway. But perhaps I\u0027m missing a more subtle interaction between _SigNotify and signal_ignore.",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 215,
        "endChar": 36
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}