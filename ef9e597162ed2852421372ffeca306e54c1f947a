{
  "comments": [
    {
      "key": {
        "uuid": "ab0ee3c7_6c21e72a",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 180,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "Why is this separate (not a) map necessary? If I understand correctly, the necessary sequence is:\n\n1. disableSignal, which sets the action in the kernel\n2. Wait for signal quiescence.\n3. Remove the signal channel.\n\nCan you just leave the handler in handlers.m while waiting for quiescence, and then remove it from handlers.m?",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "142ecc34_10a3f501",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 180,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Code in, e.g., cancel will loop through the map and make decisions based on h.want.  That code could of course run during signalWaitUntilIdle.  If we leave the channel in handlers.m without changing h.want, then cancel will do the wrong thing.  If we leave the channel in handlers.m and clear h.want, then the code in process won\u0027t know which channels should receive the signal.\n\nAdded a comment on the stopping field in handlers.",
      "parentUuid": "ab0ee3c7_6c21e72a",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95fa72b1_108f9fd2",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T20:24:36Z",
      "side": 1,
      "message": "Is there a risk of starvation here? (What happens if the signal.loop goroutine can\u0027t keep up with the rate of arriving signals?)\n\nAs far as I can tell, we\u0027re guaranteed to eventually hit sigIdle and sigSending, but not necessarily sigReceiving (which is whal signalWaitUntilIdle blocks on).",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e746b2c_25185641",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T21:00:02Z",
      "side": 1,
      "message": "There is a theoretical risk of starvation if signals are coming in very rapidly, but that is always true for a Unix program.  If you can send a process a signal each time it enters the signal handlers, it will do nothing except run the signal handler.  So I don\u0027t think this introduces a new problem, it just makes a theoretical problem slightly easier to trigger.",
      "parentUuid": "95fa72b1_108f9fd2",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac1ce561_dc9226be",
        "filename": "src/os/signal/signal.go",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T22:49:57Z",
      "side": 1,
      "message": "The particular detail that I\u0027m worried about is that a single thread receiving a thread-specific signal can now starve the program globally, whereas before it could only starve itself.\n\nA signal-starved Go thread would starve the whole program anyway (because it would prevent the GC from entering a safe point), but the potential for a self-signaling C thread to now starve the Go runtime makes things a bit more interesting.\n\nI suppose that\u0027s unusual enough that we needn\u0027t worry about it for now, though.",
      "parentUuid": "2e746b2c_25185641",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a5cfb101_89fa6930",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 320,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "No \\n",
      "range": {
        "startLine": 320,
        "startChar": 35,
        "endLine": 320,
        "endChar": 38
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c6b1930_7429f339",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 320,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a5cfb101_89fa6930",
      "range": {
        "startLine": 320,
        "startChar": 35,
        "endLine": 320,
        "endChar": 38
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0e1ec24_10a1588c",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 355,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "Comment what the sleep is doing.",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e78c91cd_d3148d60",
        "filename": "src/os/signal/signal_test.go",
        "patchSetId": 1
      },
      "lineNbr": 355,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0e1ec24_10a1588c",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a76c1bd_2cec9c31",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T20:24:36Z",
      "side": 1,
      "message": "It appears that \"recv\" is not accessed atomically (because it is synchronized externally).\n\nI have some lingering confusion around \"mask\" and \"recv\". Why are they separate arrays at all, given that the mask is updated atomically? (Is it so that we can avoid atomic ops in the fast path of signal_recv, to avoid cas-loop-induced starvation somewhere, or some other reason?)",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 37,
        "endChar": 66
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1daf3819_d79c3790",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T21:00:02Z",
      "side": 1,
      "message": "I corrected the comment.\n\nI think that mask and recv are separate fields so that signal_recv has a clear point at which to sleep to receive more data: after it has sent all the signals in recv.  But I didn\u0027t write this code.",
      "parentUuid": "3a76c1bd_2cec9c31",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 37,
        "endChar": 66
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6ae3add_b8201ebe",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T22:49:57Z",
      "side": 1,
      "message": "\u003e I think that mask and recv are separate fields so that signal_recv has a clear point at which to sleep to receive more data: after it has sent all the signals in recv.  But I didn\u0027t write this code.\n\nAh, it looks like separating the masks has the effect of preventing one signal from starving the others. If we used the same mask for both, we\u0027d have to choose which of the set bits to report next, and the obvious approach (\"send the lowest set bit and clear it\") would fail to deliver higher signals if lower signals arrive at a fast enough rate.\n\n(That might be a subtle enough point to merit a mention in either this comment or the earlier file-level comment.)",
      "parentUuid": "1daf3819_d79c3790",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 37,
        "endChar": 66
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "818ecc91_e3e92e15",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "Could you elaborate on what\u0027s reading/writing these fields that needs the atomic synchronization? What\u0027s ensuring there are no write races on wanted and ignored? The comment is written from the perspective of \"what\u0027s not strictly necessary\", which I think turns the argument on its head.",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4cfee79c_de4569ac",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "818ecc91_e3e92e15",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a6f80bdc_f2d6d81f",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-06-21T18:56:04Z",
      "side": 1,
      "message": "These loads don\u0027t have to be atomic, right?",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb8a5004_811b1cf5",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T20:21:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a6f80bdc_f2d6d81f",
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65fec4a0_2a4082fd",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 215,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T20:24:36Z",
      "side": 1,
      "message": "It looks like \"wanted\" and \"ignored\" are more-or-less complements of each other.\nIs there a risk of races from the skew between these atomic updates?\n\nsig.wanted is read in sigsend, and sig.ignored is read in signal_ignored (which is called after sigsend returns).\n\nI think that implies a (rare) race if signal_ignore executes simultaneously with sighandler for a signal for which _SigKill or _SigThrow is set.\n\n1) signal_ignore clears sig.wanted\n2) sighandler returns false from sigsend\n3) sighandler calls signal_ignored and returns false\n4) sighandler begins killing or throwing\n5) signal_ignore sets sig.ignored\n\nI can see two alternatives.\n\nA) We could combine \"wanted\" and \"ignored\" into a single interleaved array (so that updates to \"wanted\" and \"ignored\" for the same signal occur in a single atomic op). That somewhat complicates the code, but I don\u0027t see anything that makes it downright infeasible.\n\nB) We could set \"wanted\" instead of \"ignored\" for ignored signals. That would produce spurious wakeups in signal_recv, but as far as I can tell they turn into no-ops anyway. But perhaps I\u0027m missing a more subtle interaction between _SigNotify and signal_ignore.",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 215,
        "endChar": 36
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f41718b_b47d353f",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 215,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-06-21T21:00:02Z",
      "side": 1,
      "message": "The wanted and ignored fields aren\u0027t complements of each other.  The wanted field means that somebody called os/signal.Notify for the signal, meaning that the signal should be sent to one or more channels.  The ignored field means that somebody called os/signal.Ignore, meaning that the signal should be ignored entirely--even the default behavior should not take place.  If wanted is set for a signal, then ignored should be zero for that signal, and if ignored is set, then wanted should be zero.  But both wanted and ignored can be zero for the same signal, and in fact that is the normal case at program startup.\n\nI don\u0027t think your race is a real problem, because signal_ignore first calls sigignore, which sets the signal handler for the signal to SIG_IGN.  So the only way the race can occur is if we are already processing the signal at the time that the program calls os/signal.Ignore.  In other words, while the race you describe can occur, there is already a race anyhow.\n\nThat said, I think you\u0027re right that we could remove the ignored array, and just use wanted.  Want to file an issue?",
      "parentUuid": "65fec4a0_2a4082fd",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 215,
        "endChar": 36
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03978d71_00c6c76b",
        "filename": "src/runtime/sigqueue.go",
        "patchSetId": 1
      },
      "lineNbr": 215,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-06-21T22:49:57Z",
      "side": 1,
      "message": "\u003e I don\u0027t think your race is a real problem, because signal_ignore first calls sigignore, which sets the signal handler for the signal to SIG_IGN.  So the only way the race can occur is if we are already processing the signal at the time that the program calls os/signal.Ignore.  In other words, while the race you describe can occur, there is already a race anyhow.\n\nIt\u0027s true that there is already a race, and if the program hasn\u0027t previously called signal.Notify for the signal, the behavior is equivalent to the signal arriving slightly earlier (before the execution of the Ignore call). That\u0027s fairly benign.\n\nHowever, if the program previously called signal.Notify for the signal in question, the inherent race is between \"send the signal on the channel\" and \"do not send the signal on the channel\". The skew here introduces a third behavior (\"terminate the process due to unhandled signal\") that does not correspond to either the pre-Ignore or post-Ignore state.\n\nThat seems like it should be an easy race to reproduce, but the \"obvious\" reproducer turns out to trigger a different race and crash with a SIGSEGV (https://golang.org/issue/20748).\n\nSince the failure mode is already pretty bad, I don\u0027t think it needs to block this CL.\n\n\n\u003e That said, I think you\u0027re right that we could remove the ignored array, and just use wanted.  Want to file an issue?\n\nLet\u0027s start with https://golang.org/issue/20748 and see where we go from there.",
      "parentUuid": "6f41718b_b47d353f",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 215,
        "endChar": 36
      },
      "revId": "ef9e597162ed2852421372ffeca306e54c1f947a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}