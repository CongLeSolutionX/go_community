{
  "comments": [
    {
      "key": {
        "uuid": "de26b337_4a74662a",
        "filename": "src/runtime/sys_linux_386.s",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 28783
      },
      "writtenOn": "2020-02-11T21:19:18Z",
      "side": 1,
      "message": "FYI, if I look at the actual generated code, this translates to LEAL 0x4(SP), DX, which is different from the previous (line 238 to the left), which translates to LEAL 0x0(SP), DX.  However, this new address actually seems more correct -- it gives the SP pointing to the start of the first arg (sec) [the value of SP right before doing the call], whereas LEAL 0x0(SP), DX gives the address of the return address [the value of the SP just after entering this routine].",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b19e65a3_a37cced5",
        "filename": "src/runtime/sys_linux_386.s",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-02-11T21:33:05Z",
      "side": 1,
      "message": "Yes. The old code works correctly if the frame size is 0, but not otherwise. The new code should work no matter the frame size is 0 or not. And it is still good to use FP offset for argument anyway (as we generally do).",
      "parentUuid": "de26b337_4a74662a",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ddab16c4_3b48d386",
        "filename": "src/runtime/sys_linux_386.s",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 28783
      },
      "writtenOn": "2020-02-11T21:39:42Z",
      "side": 1,
      "message": "No, my point is you are actually changing the address being stored in m_vdsoSP for 386, but it does seem more correct (now points to the first arg slot, rather than to the return address slot).",
      "parentUuid": "b19e65a3_a37cced5",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da52311c_c046cc9d",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-02-11T20:52:10Z",
      "side": 1,
      "message": "It\u0027s weird that we generate a new frame pointer, only to immediately overwrite it.\nWhat if we get a signal at the next instruction?\nWe may need to just be explicit about the save/restore instead of using the frame size to dictate it.\nOr store the old SP somewhere else?",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8c61eb8_7230f68c",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-02-11T21:18:23Z",
      "side": 1,
      "message": "I think this BP is to save the current SP so we can restore it when we return from VDSO, at line 247. I agree that this clobbers the frame pointer we just saved. Maybe we want to choose a different register.\n\nIt is okay if we get a signal here, where vdsoSP is still 0 so we\u0027ll use the current PC/SP for unwinding, and the SP delta is correct here before we switch the stack and align the SP. But frame-pointer based unwinding may go off.\n\nI agree that it might be better to just explicitly save/restore frame pointer.",
      "parentUuid": "da52311c_c046cc9d",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ac37e3c_f3cb233b",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 28783
      },
      "writtenOn": "2020-02-11T21:19:18Z",
      "side": 1,
      "message": "We could save the SP now in the single local variable slot in the frame that has been created, but not sure if we want to do that change in 1.14, or more in 1.15.",
      "parentUuid": "da52311c_c046cc9d",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ed77381_204769a8",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 5167
      },
      "writtenOn": "2020-02-13T19:47:09Z",
      "side": 1,
      "message": "It just needs to be saved in some callee-save C register.\n\nThere are two different issues here, though: correct Go unwinding and correct frame-pointer-based unwinding. I think the Go unwinding is higher priority, and we should go ahead and fix for 1.14. I think we should fix the FP unwinding, too, but I don\u0027t think it\u0027s worth holding up the release for that, so it should just be a separate CL (maybe we land it in a point release).",
      "parentUuid": "9ac37e3c_f3cb233b",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34fc634d_3fd2b3e6",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-02-13T19:50:34Z",
      "side": 1,
      "message": "I\u0027ll make a separate CL for that.",
      "parentUuid": "7ed77381_204769a8",
      "revId": "5ab625578b40611a1e0cec0461539c2a8c851078",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}