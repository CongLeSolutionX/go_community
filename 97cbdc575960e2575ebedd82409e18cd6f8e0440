{
  "comments": [
    {
      "key": {
        "uuid": "4c694c8a_2b4e6bd4",
        "filename": "src/cmd/compile/internal/ssa/gen/AMD64.rules",
        "patchSetId": 4
      },
      "lineNbr": 2281,
      "author": {
        "id": 26817
      },
      "writtenOn": "2018-07-06T17:00:02Z",
      "side": 1,
      "message": "Do we need this? Shouldn\u0027t (ADDL (MOVLload)) always be converted into ADDLload, which is handled above?",
      "revId": "97cbdc575960e2575ebedd82409e18cd6f8e0440",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "faefd45c_bd8c27d4",
        "filename": "src/cmd/compile/internal/ssa/gen/AMD64.rules",
        "patchSetId": 4
      },
      "lineNbr": 2281,
      "author": {
        "id": 16935
      },
      "writtenOn": "2018-07-07T00:23:43Z",
      "side": 1,
      "message": "((ADD|SUB|AND|OR|XOR)Q x l:(MOVQload [off] {sym} ptr mem)) \u0026\u0026 canMergeLoad(v, l, x) \u0026\u0026 clobber(l) -\u003e ((ADD|SUB|AND|OR|XOR)Qload x [off] {sym} ptr mem)\n\nThe above rule has an extra condition canMergeLoad(v, l, x).\n\nBut my new rule need not that one.\n\n(MOVQstore {sym} [off] ptr y:((ADD|SUB|AND|OR|XOR)Q l:(MOVQload [off] {sym} ptr mem) x) mem) \u0026\u0026 y.Uses\u003d\u003d1 \u0026\u0026 l.Uses\u003d\u003d1 \u0026\u0026 clobber(y) \u0026\u0026 clobber(l) -\u003e ((ADD|SUB|AND|OR|XOR)Qmodify [off] {sym} ptr x mem)",
      "parentUuid": "4c694c8a_2b4e6bd4",
      "revId": "97cbdc575960e2575ebedd82409e18cd6f8e0440",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31577951_3607dcfd",
        "filename": "src/cmd/compile/internal/ssa/gen/AMD64.rules",
        "patchSetId": 4
      },
      "lineNbr": 2281,
      "author": {
        "id": 5200
      },
      "writtenOn": "2018-08-07T17:08:32Z",
      "side": 1,
      "message": "I can\u0027t imagine a case where your second rule would fire, but the canMergeLoad test would fail.  The tricky part of canMergeLoad is if x depends on a later memory state, but that can\u0027t happen because the store\u0027s indirect use of x guarantees that x can\u0027t depend on a later memory state.\n\nThat is, I think Ilya is right, this rule is redundant.",
      "parentUuid": "faefd45c_bd8c27d4",
      "revId": "97cbdc575960e2575ebedd82409e18cd6f8e0440",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97704400_39b4db0b",
        "filename": "src/cmd/compile/internal/ssa/gen/AMD64.rules",
        "patchSetId": 4
      },
      "lineNbr": 2281,
      "author": {
        "id": 16935
      },
      "writtenOn": "2018-08-08T13:33:39Z",
      "side": 1,
      "message": "Indeed, without this \"redundant\" rule, the following test will fail.\nfunc SubMem(arr []int, b int) int {\n\t// amd64:`SUBQ\\s[A-Z]+,\\s16\\([A-Z]+\\)`\n\tarr[2] -\u003d b\n\t// amd64:`SUBQ\\s[A-Z]+,\\s24\\([A-Z]+\\)`\n\tarr[3] -\u003d b\n}\n\nThe generated asm will fall into ordinary\n v16    00012 (4)       MOVQ    16(AX), CX\n v23    00013 (4)       MOVQ    \"\".b+24(SP), DX\n v18    00014 (4)       SUBQ    DX, CX\n v25    00015 (4)       PCDATA  $2, $0\n v25    00016 (4)       MOVQ    CX, 16(AX)\n\nCould you please have a try?",
      "parentUuid": "31577951_3607dcfd",
      "revId": "97cbdc575960e2575ebedd82409e18cd6f8e0440",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}