{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "40ed019c_04893d7b",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-07T21:44:07Z",
      "side": 1,
      "message": "I don\u0027t understand why you need the [b.Len():] here.  What happens if you omit it?",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "995e4215_35793a4f",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-07T22:05:48Z",
      "side": 1,
      "message": "It\u0027s there to truncate off the unread portion, otherwise you will accidentally write it again.\n\nConsider the following:\n* https://play.golang.org/p/oOBNgazUa7-\n* https://play.golang.org/p/VD6U4IW5Zo0",
      "parentUuid": "40ed019c_04893d7b",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03bc5a4b_d2fb5340",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-07T22:28:28Z",
      "side": 1,
      "message": "Thanks.  This seems rather tricky.  Do we really want to commit to supporting this?  Is this really what Buffer is for?",
      "parentUuid": "995e4215_35793a4f",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5513fe80_1d99a743",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-08T22:28:18Z",
      "side": 1,
      "message": "\u003e Do we really want to commit to supporting this?\n\nWe should avoid any semantic that would prevent Buffer from making changes to its internal implementation. However, in this situation, the Bytes API already leaks the fact that Buffer uses a single contiguous buffer (as opposed to segmented buffers or a ring buffer). Thus, I don\u0027t believe guaranteeing this semantic ties our hands in any particular way that we\u0027ll regret.\n\n\u003e Is this really what Buffer is for?\n\nIn a situation where some code has a bytes.Buffer on hand and wants to write into it, there is currently no way to write into the Buffer without allocating a separate buffer of your own that is then passed to bytes.Buffer.Write. This CL aims to document that it\u0027s permissible to append directly into the Buffer. This would codify that existing patterns doing this are correct.",
      "parentUuid": "03bc5a4b_d2fb5340",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72d04d1a_8f4217fc",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-08T22:36:41Z",
      "side": 1,
      "message": "\u003e We should avoid any semantic that would prevent Buffer from making changes to its internal implementation. However, in this situation, the Bytes API already leaks the fact that Buffer uses a single contiguous buffer (as opposed to segmented buffers or a ring buffer). Thus, I don\u0027t believe guaranteeing this semantic ties our hands in any particular way that we\u0027ll regret.\n\nAgreed, but the way that this code uses append and then passes the buffer back to Write seems somewhat convoluted.\n\n\n\u003e \u003e Is this really what Buffer is for?\n\u003e \n\u003e In a situation where some code has a bytes.Buffer on hand and wants to write into it, there is currently no way to write into the Buffer without allocating a separate buffer of your own that is then passed to bytes.Buffer.Write. This CL aims to document that it\u0027s permissible to append directly into the Buffer. This would codify that existing patterns doing this are correct.\n\nWhat do you think of something like\n\nfunc (b *Buffer) Append(p ...byte) (n int, err error) {\n\tb.lastRead \u003d opInvalid\n\tif len(b.buf) + len(p) \u003c\u003d cap(b.buf) {\n\t\tb.buf \u003d append(b.buf, p...)\n\t\treturn len(p), nil\n\t}\n\treturn b.Write(p)\n}\n\nOr do you particularly want to support computing p and then setting p[0], p[1], etc.?",
      "parentUuid": "5513fe80_1d99a743",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdc30af9_b0509ce1",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-08T22:44:44Z",
      "side": 1,
      "message": "\u003e seems somewhat convoluted.\n\nAgreed.\n\n\u003e What do you think of something like ... Buffer.Append\n\nHow would this method interoperate with append-like functionality such as strconv.AppendFloat, hash.Hash.Sum, or proto.MarshalOptions.MarshalAppend?\n\nThese functions take in a []byte, append to it, and return back a []byte. That seems to suggest that we need 1) a way to get a []byte from the Buffer (which we can do with Bytes), and 2) a way to inform Buffer that we appended some number of bytes (which we can do with Write).",
      "parentUuid": "72d04d1a_8f4217fc",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e810c385_ab5c3c0c",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-08T22:49:08Z",
      "side": 1,
      "message": "We could add:\n\n\t// BytesUnused returns an empty slice with possibly non-empty capacity.\n\t// The caller may append to this slice and pass it back to Write.\n\tfunc (b *Buffer) BytesUnused() []byte {\n\t\treturn b.Bytes()[b.Len():]\n\t}\n\nthat would take care of truncating off the unread portion. Thus usage would be more readable as:\n\n\tp :\u003d b.BytesUnused()\n\tp \u003d append(p, \"world\\n\"...)\n\tb.Write(p)",
      "parentUuid": "cdc30af9_b0509ce1",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}