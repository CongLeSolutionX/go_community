{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "40ed019c_04893d7b",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-07T21:44:07Z",
      "side": 1,
      "message": "I don\u0027t understand why you need the [b.Len():] here.  What happens if you omit it?",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "995e4215_35793a4f",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-07T22:05:48Z",
      "side": 1,
      "message": "It\u0027s there to truncate off the unread portion, otherwise you will accidentally write it again.\n\nConsider the following:\n* https://play.golang.org/p/oOBNgazUa7-\n* https://play.golang.org/p/VD6U4IW5Zo0",
      "parentUuid": "40ed019c_04893d7b",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03bc5a4b_d2fb5340",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-07T22:28:28Z",
      "side": 1,
      "message": "Thanks.  This seems rather tricky.  Do we really want to commit to supporting this?  Is this really what Buffer is for?",
      "parentUuid": "995e4215_35793a4f",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5513fe80_1d99a743",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-08T22:28:18Z",
      "side": 1,
      "message": "\u003e Do we really want to commit to supporting this?\n\nWe should avoid any semantic that would prevent Buffer from making changes to its internal implementation. However, in this situation, the Bytes API already leaks the fact that Buffer uses a single contiguous buffer (as opposed to segmented buffers or a ring buffer). Thus, I don\u0027t believe guaranteeing this semantic ties our hands in any particular way that we\u0027ll regret.\n\n\u003e Is this really what Buffer is for?\n\nIn a situation where some code has a bytes.Buffer on hand and wants to write into it, there is currently no way to write into the Buffer without allocating a separate buffer of your own that is then passed to bytes.Buffer.Write. This CL aims to document that it\u0027s permissible to append directly into the Buffer. This would codify that existing patterns doing this are correct.",
      "parentUuid": "03bc5a4b_d2fb5340",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72d04d1a_8f4217fc",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-08T22:36:41Z",
      "side": 1,
      "message": "\u003e We should avoid any semantic that would prevent Buffer from making changes to its internal implementation. However, in this situation, the Bytes API already leaks the fact that Buffer uses a single contiguous buffer (as opposed to segmented buffers or a ring buffer). Thus, I don\u0027t believe guaranteeing this semantic ties our hands in any particular way that we\u0027ll regret.\n\nAgreed, but the way that this code uses append and then passes the buffer back to Write seems somewhat convoluted.\n\n\n\u003e \u003e Is this really what Buffer is for?\n\u003e \n\u003e In a situation where some code has a bytes.Buffer on hand and wants to write into it, there is currently no way to write into the Buffer without allocating a separate buffer of your own that is then passed to bytes.Buffer.Write. This CL aims to document that it\u0027s permissible to append directly into the Buffer. This would codify that existing patterns doing this are correct.\n\nWhat do you think of something like\n\nfunc (b *Buffer) Append(p ...byte) (n int, err error) {\n\tb.lastRead \u003d opInvalid\n\tif len(b.buf) + len(p) \u003c\u003d cap(b.buf) {\n\t\tb.buf \u003d append(b.buf, p...)\n\t\treturn len(p), nil\n\t}\n\treturn b.Write(p)\n}\n\nOr do you particularly want to support computing p and then setting p[0], p[1], etc.?",
      "parentUuid": "5513fe80_1d99a743",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdc30af9_b0509ce1",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-08T22:44:44Z",
      "side": 1,
      "message": "\u003e seems somewhat convoluted.\n\nAgreed.\n\n\u003e What do you think of something like ... Buffer.Append\n\nHow would this method interoperate with append-like functionality such as strconv.AppendFloat, hash.Hash.Sum, or proto.MarshalOptions.MarshalAppend?\n\nThese functions take in a []byte, append to it, and return back a []byte. That seems to suggest that we need 1) a way to get a []byte from the Buffer (which we can do with Bytes), and 2) a way to inform Buffer that we appended some number of bytes (which we can do with Write).",
      "parentUuid": "72d04d1a_8f4217fc",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e810c385_ab5c3c0c",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-08T22:49:08Z",
      "side": 1,
      "message": "We could add:\n\n\t// BytesUnused returns an empty slice with possibly non-empty capacity.\n\t// The caller may append to this slice and pass it back to Write.\n\tfunc (b *Buffer) BytesUnused() []byte {\n\t\treturn b.Bytes()[b.Len():]\n\t}\n\nthat would take care of truncating off the unread portion. Thus usage would be more readable as:\n\n\tp :\u003d b.BytesUnused()\n\tp \u003d append(p, \"world\\n\"...)\n\tb.Write(p)",
      "parentUuid": "cdc30af9_b0509ce1",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6893e63c_3769ba39",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-09T17:44:28Z",
      "side": 1,
      "message": "I guess I\u0027m worried that bytes.Buffer right now is a fairly simple type, at least if we ignore UnreadByte and UnreadRune which may have been mistakes.  bytes.Buffer is a kind of wrapper around []byte that lets you easily append data to a slice in various forms, and then pull the data out again.\n\nThis new functionality is a way to make bytes.Buffer more efficient for certain cases, but it\u0027s not general.  It can only be used in a very stylized way, in which you get the byte slice and then call Write.  It doesn\u0027t seem to be part of the basic idea of layering over a []byte.  It\u0027s kind of a way of switching back and forth between a bytes.Buffer and a []byte.  Why not pick one or the other?\n\nSince this seems to be about switching back and forth, what about\n    p :\u003d b.Bytes()\n    p \u003d append(p, \"...\")\n    b.Set(p)\n?",
      "parentUuid": "e810c385_ab5c3c0c",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68148a19_31804d4d",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 9735
      },
      "writtenOn": "2021-04-09T19:58:31Z",
      "side": 1,
      "message": "\u003e what about ... Buffer.Set\n\nI like the API simplicity of that, but I suspect it would have unintended performance detriments.\n\nThe Buffer is functionally split into 3 segments:\n* The read portion in b.buf[0:b.off]\n* The unread portion in b.buf[b.off:len(b.buf)]\n* The unwritten portion in b.buf[len(b.buf):cap(b.buf)]\n\nThe Buffer.Bytes API only returns the unread and unwritten portions, while the already read portion is truncated off.\n\nThus:\n\n    p :\u003d b.Bytes()\n    p \u003d append(p, \"...\")\n    b.Set(p)\n\nwould cause the capacity for the already read portion to be lost. When a subsequent Buffer.Reset call occurs, it would not be able to reuse that lost capacity.",
      "parentUuid": "6893e63c_3769ba39",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfce417f_935aae69",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 65,
      "author": {
        "id": 5206
      },
      "writtenOn": "2021-04-10T00:06:33Z",
      "side": 1,
      "message": "Do we care?  Whenever I use a bytes.Buffer the \"read\" portion is empty until writing is complete.  Are there common scenarios where that is not the case?",
      "parentUuid": "68148a19_31804d4d",
      "revId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one Code-Review+2 is required. Self review is not allowed."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Do-Not-Review",
        "description": {
          "value": "Changes that have DO NOT REVIEW in their commit message are not submittable."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Do-Not-Submit",
        "description": {
          "value": "Changes that have DO NOT SUBMIT in their commit message are not submittable."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "No-Holds",
        "description": {
          "value": "Changes with a Hold+1 vote are not submittable."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "NOT label:Hold\u003d1"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"NOT label:Hold=1"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Hold=1"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "No-Unresolved-Comments",
        "description": {
          "value": "Changes that have unresolved comments are not submittable, unless overriden by adding the hashtag allow-unresolved-comments."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "has:unresolved"
          }
        },
        "submittabilityExpression": {
          "expressionString": "-has:unresolved"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "hashtag:allow-unresolved-comments"
          }
        },
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:unresolved"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:unresolved"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"-has:unresolved"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":["has:unresolved"],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"hashtag:allow-unresolved-comments"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["hashtag:allow-unresolved-comments"]}
      },
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "No-Wait-Release",
        "description": {
          "value": "Changes with the hashtag wait-release cannot be submitted."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "hashtag:wait-release"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"hashtag:wait-release"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["hashtag:wait-release"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["is:review-enforced_gerrit"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforcement-satisfied_gerrit"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "TryBots-Pass",
        "description": {
          "value": "Changes must pass TryBots unless TryBot-Bypass+1 is set."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "-branch:refs/meta/config -label:TryBot-Result\u003dMAX"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:TryBot-Bypass\u003dMAX"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"-branch:refs/meta/config -label:TryBot-Result=MAX"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["branch:refs/meta/config","label:TryBot-Result=MAX"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:false"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:TryBot-Bypass=MAX"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:TryBot-Bypass=MAX"]}
      },
      "patchSetCommitId": "1a82a0dbe9e5319d3d1b266fd543d60a38594fe7",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}