{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8ecbe2b5_604eceb5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 68008
      },
      "writtenOn": "2024-10-26T21:53:54Z",
      "side": 1,
      "message": "Hello,\nThe updates have been completed and are ready for your review. Please take a look when you have a chance. Thanks!",
      "revId": "10ee4b52cf9af5bf10c0354b80feb69a98a9edc5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4c97d282_880930d8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-10-29T17:58:00Z",
      "side": 1,
      "message": "Ok, I think I\u0027m satisfied with the code.\n\nI\u0027m still trying to figure out if there\u0027s really any benefit to this CL. I reran your benchmarks in the CL description, and I get different results:\n\ngoos: linux\ngoarch: amd64\npkg: github.com/aws/aws-sdk-go/private/protocol/json/jsonutil\ncpu: 12th Gen Intel(R) Core(TM) i7-12700\n              │  control1   │             experiment1             │\n              │   sec/op    │    sec/op     vs base               │\nBuildJSON-20    3.854µ ± 7%   3.681µ ± 10%       ~ (p\u003d0.305 n\u003d10)\nStdlibJSON-20   2.940µ ± 5%   3.121µ ±  4%  +6.17% (p\u003d0.023 n\u003d10)\ngeomean         3.366µ        3.389µ        +0.69%\n\ngoos: linux\ngoarch: amd64\npkg: github.com/benhoyt/goawk/interp\ncpu: 12th Gen Intel(R) Core(TM) i7-12700\n                       │   control1   │             experiment1             │\n                       │    sec/op    │    sec/op     vs base               │\nRecursiveFunc-20         8.045µ ±  9%   7.817µ ±  9%       ~ (p\u003d0.305 n\u003d10)\nRegexMatch-20            540.4n ±  3%   534.4n ±  0%  -1.12% (p\u003d0.000 n\u003d10)\nRepeatExecProgram-20     24.45µ ±  7%   25.51µ ±  5%       ~ (p\u003d0.105 n\u003d10)\nRepeatNew-20             46.30n ±  5%   42.54n ±  3%  -8.13% (p\u003d0.000 n\u003d10)\nRepeatIOExecProgram-20   65.60µ ± 12%   65.28µ ± 28%       ~ (p\u003d0.393 n\u003d10)\nRepeatIONew-20           561.6n ±  9%   598.2n ±  5%       ~ (p\u003d0.143 n\u003d10)\ngeomean                  2.379µ         2.370µ        -0.40%\n\nThese benchmarks are kind of noisy, and I really don\u0027t trust that there\u0027s any signal among this noise. Any thoughts on how we might convince ourselves this CL is worth it?",
      "revId": "10ee4b52cf9af5bf10c0354b80feb69a98a9edc5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "02883f95_e721fd1f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 68008
      },
      "writtenOn": "2024-10-31T13:30:21Z",
      "side": 1,
      "message": "I tried some more benchmarking with current version on a Kunpeng 920 machine, it seems to have reproduced similar result to what I had on x86 laptop (~ -2%) on StdlibJSON but did not reproduce any improvement on benhoyt_goawk_1_18. However, I found another interesting example:\n```\nshortname: kanzi\ntoolchain: Cse1-rand\ngoos: linux\ngoarch: arm64\npkg: github.com/flanglet/kanzi-go/benchmark\n        │ Orig-rand.stdout │          Cse1-rand.stdout          │\n        │      sec/op      │   sec/op     vs base               │\nFPAQ-4         26.11m ± 0%   25.61m ± 0%  -1.93% (p\u003d0.000 n\u003d10)\nLZ-4           1.461m ± 1%   1.445m ± 1%       ~ (p\u003d0.105 n\u003d10)\nMTFT-4         1.197m ± 0%   1.201m ± 0%  +0.36% (p\u003d0.000 n\u003d10)\ngeomean        3.574m        3.543m       -0.88%\n```\n\nOriginal version has several re-loads, e.g. from `[x0, #168]` (the output is from `perf report` with percentage of \u0027cycles\u0027 events on instructions):\n```\ngithub.com/flanglet/kanzi-go/entropy.(*FPAQEncoder).encodeBit\nPercent│             // Update probabilities\n       │             if bit \u003d\u003d 0 {\n  0.04 │       ubfx   x5, x1, #0, #8\n  8.95 │     ↓ cbnz   w5, 78\n       │                     this.low +\u003d (split + 1)\n  0.14 │       add    x3, x4, x3, lsr #8\n  0.14 │       add    x3, x3, #0x1\n  0.36 │       str    x3, [x0]\n       │                     this.p[pIdx] -\u003d (this.p[pIdx] \u003e\u003e 6)\n  5.12 │       ldr    x1, [x0, #176]\n  0.02 │       cmp    x2, x1\n       │     ↓ b.cs   14c\n  2.35 │       ldr    x3, [x0, #168]\n  0.76 │       ldr    x4, [x3, x2, lsl #3]\n  0.01 │       sub    x4, x4, x4, asr #6\n  3.49 │       str    x4, [x3, x2, lsl #3]\n  0.04 │     ↓ b      e0\n       │             } else {\n       │                     this.high \u003d this.low + split\n  0.17 │ 78:   add    x3, x4, x3, lsr #8\n  0.19 │       str    x3, [x0, #8]\n       │                     this.p[pIdx] -\u003d ((this.p[pIdx] - _FPAQ_PSCALE + 64) \u003e\u003e 6)\n  5.22 │       ldr    x1, [x0, #176]\n  0.04 │       cmp    x2, x1\n  0.02 │     ↓ b.cs   144\n  1.32 │       ldr    x3, [x0, #168]\n  0.94 │       ldr    x4, [x3, x2, lsl #3]\n  0.01 │       mov    x5, #0xffc0                     // #65472\n  0.01 │       sub    x5, x4, x5\n       │       sub    x4, x4, x5, asr #6\n  3.73 │       str    x4, [x3, x2, lsl #3]\n  0.01 │     ↓ b      e0\n       │\n       │             return count, nil\n       │     }\n\t   ...\n```\n\nThe version with this change has CSEd that pointer and keeps in register (and also it was able to remove some bound checks):\n```\nPercent│             // Update probabilities\n       │             if bit \u003d\u003d 0 {\n  0.04 │       ubfx   x6, x1, #0, #8\n  7.26 │     ↓ cbnz   w6, 68\n       │                     this.low +\u003d (split + 1)\n  0.20 │       add    x3, x4, x3, lsr #8\n  0.08 │       add    x3, x3, #0x1\n  0.66 │       str    x3, [x0]\n       │                     this.p[pIdx] -\u003d (this.p[pIdx] \u003e\u003e 6)\n  5.13 │       ldr    x3, [x5, x2, lsl #3]\n  0.03 │       sub    x3, x3, x3, asr #6\n  2.37 │       str    x3, [x5, x2, lsl #3]\n       │     ↓ b      c0\n       │             } else {\n       │                     this.high \u003d this.low + split\n  0.18 │ 68:   add    x3, x4, x3, lsr #8\n  0.22 │       str    x3, [x0, #8]\n       │                     this.p[pIdx] -\u003d ((this.p[pIdx] - _FPAQ_PSCALE + 64) \u003e\u003e 6)\n  5.16 │       ldr    x3, [x5, x2, lsl #3]\n  0.02 │       mov    x4, #0xffc0                     // #65472\n  0.01 │       sub    x4, x3, x4\n       │       sub    x3, x3, x4, asr #6\n  2.06 │       str    x3, [x5, x2, lsl #3]\n       │     ↓ b      c0\n       │\n       │             return count, nil\n       │     }\n\t\t...\n```\n\nAlso keeping more values in registers should be potentially useful for enabling/improving other optimizations after CSE. Currently the most benefits is from the `prove` pass, but the others (e.g. dead stores elimination, misc. opt patterns) should also be able to optimize more cases with this CL.",
      "parentUuid": "4c97d282_880930d8",
      "revId": "10ee4b52cf9af5bf10c0354b80feb69a98a9edc5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}