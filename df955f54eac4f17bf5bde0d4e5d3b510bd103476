{
  "comments": [
    {
      "key": {
        "uuid": "0d53ed1e_e06d5bf8",
        "filename": "src/cmd/internal/objabi/symkind.go",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-09-07T18:19:51Z",
      "side": 1,
      "message": "Why does this require a new symbol type at all? What prevents us from using SDWARFINFO for these?\n\n(If we really do need this, don\u0027t forget to regenerate symkind_string.go)",
      "revId": "df955f54eac4f17bf5bde0d4e5d3b510bd103476",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d1425af_f63ad5bd",
        "filename": "src/cmd/internal/objabi/symkind.go",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 17090
      },
      "writtenOn": "2017-09-07T18:31:48Z",
      "side": 1,
      "message": "Yeah, that\u0027s what I was trying to suggest earlier. Looking harder, I\u0027m not sure yet how to collect them, but I still think it\u0027s better than an explosion of symbol types.",
      "parentUuid": "0d53ed1e_e06d5bf8",
      "revId": "df955f54eac4f17bf5bde0d4e5d3b510bd103476",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "483afe4c_063f00ac",
        "filename": "src/cmd/internal/objabi/symkind.go",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 5821
      },
      "writtenOn": "2017-09-07T19:00:12Z",
      "side": 1,
      "message": "SDWARFINFO symbols are included in the final binary only if their corresponding function is reachable, these symbols should instead be included unconditionally (they never are reachable).",
      "parentUuid": "8d1425af_f63ad5bd",
      "revId": "df955f54eac4f17bf5bde0d4e5d3b510bd103476",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15716b36_99d8ee6a",
        "filename": "src/cmd/internal/objabi/symkind.go",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 17090
      },
      "writtenOn": "2017-09-07T20:18:14Z",
      "side": 1,
      "message": "Right. I was hoping that we could change the linker\u0027s DWARF processing so it started from the SDWARFINFO symbols instead of the functions, but then it\u0027s hard to figure out whether the symbol is the DIE for a function, and whether that function is actually reachable in the final binary. We could use a naming convention for that, but maybe a new symbol type is easier?\n\nIf so, I wonder if it would be better to have the new type be SDWARFFUNCINFO (or some such) and use SDWARFINFO for the constants. Hopefully that would convey the idea that the FUNCINFO ones are processed specially (for reachability) and then the linker could convert them to just INFO in writelines(). I dunno.",
      "parentUuid": "483afe4c_063f00ac",
      "revId": "df955f54eac4f17bf5bde0d4e5d3b510bd103476",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d406006a_e333d5bd",
        "filename": "src/cmd/internal/objabi/symkind.go",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-09-07T20:55:34Z",
      "side": 1,
      "message": "I just chatted with Russ a bit about this.\n\nMaybe what would be cleanest is to put together a *single* SDWARFINFO symbol in the compiler that contains all of the const DIEs and give it a well-known name like \"go.dwarfconsts\". Then when the linker reads in the object, when it sees this name, just add it to the list of global symbols.",
      "parentUuid": "15716b36_99d8ee6a",
      "revId": "df955f54eac4f17bf5bde0d4e5d3b510bd103476",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9405c6ca_959c2a50",
        "filename": "src/cmd/internal/objabi/symkind.go",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 17090
      },
      "writtenOn": "2017-09-07T21:12:47Z",
      "side": 1,
      "message": "As long as there\u0027s no reason we would need to emit a relocation to a specific DIE, that seems okay, though IMO unpleasant.\n\nMaybe reachability should be a flag in the object file format. I guess right now the linker just knows to start from main() and everything else is implicit?",
      "parentUuid": "d406006a_e333d5bd",
      "revId": "df955f54eac4f17bf5bde0d4e5d3b510bd103476",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8d6240a_9e3c4e4e",
        "filename": "src/cmd/internal/objabi/symkind.go",
        "patchSetId": 2
      },
      "lineNbr": 61,
      "author": {
        "id": 5167
      },
      "writtenOn": "2017-09-07T21:26:45Z",
      "side": 1,
      "message": "I think even if we needed to emit a relocation to a specific DIE this would be fine, but since we don\u0027t have to, it\u0027s even more fine.\n\nReachability isn\u0027t always implicit from main. For example, if you search for AttrReachable in cmd/link/internal/ld, you\u0027ll find a lot of things that are explicitly marked reachable. For example (*Link).loadlib and (*Link).symtab do this for several symbols.",
      "parentUuid": "9405c6ca_959c2a50",
      "revId": "df955f54eac4f17bf5bde0d4e5d3b510bd103476",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}