{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0df3d8b6_28e0e5f9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-15T20:49:18Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d5021e60f",
      "tag": "autogenerated:trybots~beginning",
      "revId": "5021e60fde18e817d787e76385c9c1f8faf02999",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af0ce388_8ecc2ef5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-15T21:01:46Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "0df3d8b6_28e0e5f9",
      "tag": "autogenerated:trybots~happy",
      "revId": "5021e60fde18e817d787e76385c9c1f8faf02999",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53c0cddd_24f56a8a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 25391
      },
      "writtenOn": "2022-04-15T21:12:29Z",
      "side": 1,
      "message": "regardless of my comment, it looks like having preemption signals enabled on Go threads is currently a requirement, and this fixes a corner case. so, I don\u0027t see why we shouldn\u0027t land this.",
      "revId": "5021e60fde18e817d787e76385c9c1f8faf02999",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d0ecbc3_092133a2",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 1250,
      "author": {
        "id": 25391
      },
      "writtenOn": "2022-04-15T21:09:11Z",
      "side": 1,
      "message": "this resolves the issue for ensureSigM, but is it possible that, e.g. a C thread that calls into Go blocks sigPreempt on return from Go, but the runtime already sent a signal to that thread?\n\nI suppose I\u0027m wondering if this is a more general issue. one perspective on all of this is that the Go application should work equally well if sigPreempt was disabled everywhere, because it\u0027s ultimately an optimization, not a critical piece of functionality. I\u0027m not sure if that\u0027s the right perspective, but it feels like it could be.",
      "revId": "5021e60fde18e817d787e76385c9c1f8faf02999",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8777a3b7_2a3ed2d6",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 1250,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-04-15T21:14:38Z",
      "side": 1,
      "message": "When a C thread calls into Go we call minit -\u003e minitSignals -\u003e minitSignalMask which unblocks all signals for which blockableSig returns false, so this same CL fixes that problem as well.\n\nI agree that in general things should work if the preemption signal is blocked, and as far as I know that is mostly true.  However, on macOS specifically it\u0027s not quite true because of #41702.",
      "parentUuid": "3d0ecbc3_092133a2",
      "revId": "5021e60fde18e817d787e76385c9c1f8faf02999",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}