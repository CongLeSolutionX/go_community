{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a801cd03_1e724fe8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 36863
      },
      "writtenOn": "2024-08-02T18:48:52Z",
      "side": 1,
      "message": "Ping? Lynn has retired, so I think I am the only active PPC64 maintainer now.",
      "revId": "a045681c9e5de344379ebf0a78989c87c2145091",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6fcdd12_3897e4b1",
        "filename": "src/cmd/compile/internal/ssa/_gen/PPC64.rules",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-08-02T19:29:23Z",
      "side": 1,
      "message": "I\u0027m not sure it\u0027s a good idea to change a Value\u0027s type. It may be okay if this is the only use of y, but if y has other uses, those may get confuse. Maybe a possibility is to issue a \"copy\", like\n\n(MOVBZreg (ANDconst [c] z)) \u0026\u0026 uint64(c) \u003c\u003d 0xFF \u003d\u003e (ANDconst [c] z)\n\nThe ANDconst value on the RHS will get the same type of LHS.",
      "range": {
        "startLine": 579,
        "startChar": 58,
        "endLine": 579,
        "endChar": 71
      },
      "revId": "a045681c9e5de344379ebf0a78989c87c2145091",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48d9b8db_796f6edd",
        "filename": "src/cmd/compile/internal/ssa/_gen/PPC64.rules",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 36863
      },
      "writtenOn": "2024-08-05T19:56:55Z",
      "side": 1,
      "message": "In general, yes. In this limited case (for logical ops) shouldn\u0027t it always be safe to widen the type? The significant bits of a larger type should be ignored by other users.\n\nIt\u0027s not perfect, but avoiding extra copies allows the latelower pass to recombine into ANDCCconst.",
      "parentUuid": "c6fcdd12_3897e4b1",
      "range": {
        "startLine": 579,
        "startChar": 58,
        "endLine": 579,
        "endChar": 71
      },
      "revId": "a045681c9e5de344379ebf0a78989c87c2145091",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d490aa2e_4e64c359",
        "filename": "src/cmd/compile/internal/ssa/_gen/PPC64.rules",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-08-05T20:11:33Z",
      "side": 1,
      "message": "Maybe. But I\u0027m still not very comfortable with changing a Value\u0027s type. Why extra copy would interfere latelower to convert to ANDCCconst? I don\u0027t see a rule in latelower that depends on number of copies of uses. If that matters, we could also consider running some CSE before latelower.\n\nAnother possibility is changing the type only when it is the only use. Would that cover most cases?",
      "parentUuid": "48d9b8db_796f6edd",
      "range": {
        "startLine": 579,
        "startChar": 58,
        "endLine": 579,
        "endChar": 71
      },
      "revId": "a045681c9e5de344379ebf0a78989c87c2145091",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "385f177b_c451b832",
        "filename": "src/cmd/compile/internal/ssa/_gen/PPC64.rules",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 36863
      },
      "writtenOn": "2024-08-05T21:40:28Z",
      "side": 1,
      "message": "I\u0027ll investigate the impact. As for the latelower rules, the rules calling convertPPC64OpToOpCC works best if the logical/arithmetic op isn\u0027t duplicated.\n\nIf a copy is created with a different type, would a CSE pass immediately afterwards recombine these despite the type difference? If so, what type would it have?",
      "parentUuid": "d490aa2e_4e64c359",
      "range": {
        "startLine": 579,
        "startChar": 58,
        "endLine": 579,
        "endChar": 71
      },
      "revId": "a045681c9e5de344379ebf0a78989c87c2145091",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fa4a71c_ea4a76c1",
        "filename": "src/cmd/compile/internal/ssa/_gen/PPC64.rules",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-08-05T21:44:33Z",
      "side": 1,
      "message": "\u003e If a copy is created with a different type, would a CSE pass immediately afterwards recombine these despite the type difference?\n\nNo, it won\u0027t combine ones with different types. If there are multiple copies with same type, e.g. the rule that generates a copy gets fired multiple times, it will combine them. If the old y becomes dead after the rule rewrites, which is likely in many cases, it will have only the copy with the new type.",
      "parentUuid": "385f177b_c451b832",
      "range": {
        "startLine": 579,
        "startChar": 58,
        "endLine": 579,
        "endChar": 71
      },
      "revId": "a045681c9e5de344379ebf0a78989c87c2145091",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4dae1175_7804b546",
        "filename": "src/cmd/compile/internal/ssa/_gen/PPC64.rules",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 36863
      },
      "writtenOn": "2024-08-09T19:54:50Z",
      "side": 1,
      "message": "Hrm, that is unfortunate in this particular case. By copying instead of widening the type, the non-compiler tools collectively grow by 1291 instructions.",
      "parentUuid": "2fa4a71c_ea4a76c1",
      "range": {
        "startLine": 579,
        "startChar": 58,
        "endLine": 579,
        "endChar": 71
      },
      "revId": "a045681c9e5de344379ebf0a78989c87c2145091",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}