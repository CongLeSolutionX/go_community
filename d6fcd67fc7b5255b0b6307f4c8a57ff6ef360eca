{
  "comments": [
    {
      "key": {
        "uuid": "b2342216_c4dbc8b7",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 1016,
      "author": {
        "id": 16006
      },
      "writtenOn": "2019-02-25T09:10:03Z",
      "side": 1,
      "message": "Is an atomic.Store here needed to accompany the atomic.Load?",
      "range": {
        "startLine": 1016,
        "startChar": 1,
        "endLine": 1016,
        "endChar": 15
      },
      "revId": "d6fcd67fc7b5255b0b6307f4c8a57ff6ef360eca",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "969a8c5d_19ff5765",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 1016,
      "author": {
        "id": 27994
      },
      "writtenOn": "2019-02-25T09:41:47Z",
      "side": 1,
      "message": "I don\u0027t know. It does work like this. I think the lock around it is enough. \nMy first version (not submitted) was with a lock instead of an atomic.Load but I think only the SYNC instruction is needed in order to wait remaining updates on these values. Therefore, I don\u0027t think atomic.Store is needed (at least not on ppc64, but maybe other OSes need it).",
      "parentUuid": "b2342216_c4dbc8b7",
      "range": {
        "startLine": 1016,
        "startChar": 1,
        "endLine": 1016,
        "endChar": 15
      },
      "revId": "d6fcd67fc7b5255b0b6307f4c8a57ff6ef360eca",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70dde14d_1f2dc86d",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 1016,
      "author": {
        "id": 16006
      },
      "writtenOn": "2019-02-25T10:34:39Z",
      "side": 1,
      "message": "There are more knowledgeable developers here for memory ordering so I would be happy if they can clarify for the final version of the CL:\nI think inside the lock there is no guarantee in which order the normal memory updates will be seen from outside where an atomic.Load happens. e.g. do we need stopwait to be updated before sched.gcwaiting with atomic.Store below this line? If so it seems safer to also do a atomic.Store here. With concurrency should be better to err on the side of caution.",
      "parentUuid": "969a8c5d_19ff5765",
      "range": {
        "startLine": 1016,
        "startChar": 1,
        "endLine": 1016,
        "endChar": 15
      },
      "revId": "d6fcd67fc7b5255b0b6307f4c8a57ff6ef360eca",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22c298ab_a05d541e",
        "filename": "src/runtime/proc.go",
        "patchSetId": 1
      },
      "lineNbr": 1016,
      "author": {
        "id": 27994
      },
      "writtenOn": "2019-03-11T16:39:07Z",
      "side": 1,
      "message": "I have tried with atomic.Store and everything seems alright too.\nAre the other stores needed to be atomic too ? (all sched.stopwait-- for example ) ? \nIt seems to work without but it can be safer if you think so.",
      "parentUuid": "70dde14d_1f2dc86d",
      "range": {
        "startLine": 1016,
        "startChar": 1,
        "endLine": 1016,
        "endChar": 15
      },
      "revId": "d6fcd67fc7b5255b0b6307f4c8a57ff6ef360eca",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}