{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0e184263_f0d55b74",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 55800
      },
      "writtenOn": "2022-03-11T15:18:58Z",
      "side": 1,
      "message": "I have a couple of comments on specific examples, but very broadly I like the shape of this.\n\nThanks,\nJames",
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aed4f49e_dfdc38c6",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 172,
      "author": {
        "id": 56068
      },
      "writtenOn": "2022-02-16T20:44:11Z",
      "side": 1,
      "message": "This statement does not prevent \"out-of-thin-air\" or acausal results. See my prior comment for a counterexample. It is hard to define what \"out of thin air\" means and to disallow it. But if you disallow data races and there are no relaxed atomics, there is no need to.",
      "range": {
        "startLine": 172,
        "startChar": 0,
        "endLine": 172,
        "endChar": 74
      },
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "347cad61_9690f0d7",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 172,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-05-06T18:10:33Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aed4f49e_dfdc38c6",
      "range": {
        "startLine": 172,
        "startChar": 0,
        "endLine": 172,
        "endChar": 74
      },
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97f88bd1_5c3e52b5",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 662,
      "author": {
        "id": 15922
      },
      "writtenOn": "2022-03-10T13:37:58Z",
      "side": 1,
      "message": "Can we have a table to describe whether we can reorder the different operations, like JSR-133 Cookbook? http://gee.cs.oswego.edu/dl/jmm/cookbook.html",
      "range": {
        "startLine": 662,
        "startChar": 21,
        "endLine": 662,
        "endChar": 42
      },
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3900ca9_921a6ba2",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 662,
      "author": {
        "id": 56068
      },
      "writtenOn": "2022-03-10T16:27:34Z",
      "side": 1,
      "message": "That was an admirable attempt to write down general rules early on. But I think it has become clear since then that things are actually more complicated. Some machine architectures, especially \"non-multicopy-atomic\" ones, really require a careful analysis of each specific architecture. It took years, and an incorrect \"theorem\" or two, to understand if and how it was possible to restore sequential consistency on Power/ARMv7. (I don\u0027t mean to pick on those; they\u0027re the better-known representatives of a larger class.)\n\nThese days, I would generally point at https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html instead. That looks at C++ primitives, but at least for atomics, I think we\u0027re talking about a subset of those here.\n\nEven that is an oversimplification, since there are often somewhat arbitrary choices (e.g. \"leading fence\" vs \"trailing fence\", where the SFENCEs for x86 nontemporal operations). These choices really need to be made consistently across languages in a platform ABI spec, but usually are not.",
      "parentUuid": "97f88bd1_5c3e52b5",
      "range": {
        "startLine": 662,
        "startChar": 21,
        "endLine": 662,
        "endChar": 42
      },
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e437b97e_cc9f2071",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 662,
      "author": {
        "id": 5056
      },
      "writtenOn": "2022-06-04T15:37:09Z",
      "side": 1,
      "message": "Resolving.",
      "parentUuid": "d3900ca9_921a6ba2",
      "range": {
        "startLine": 662,
        "startChar": 21,
        "endLine": 662,
        "endChar": 42
      },
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5cec7183_d0b3ed9a",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 666,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-02-17T03:35:36Z",
      "side": 1,
      "message": "This description is too general, â€œGo programs\" here should not include those single-goroutine go programs.",
      "range": {
        "startLine": 666,
        "startChar": 93,
        "endLine": 666,
        "endChar": 104
      },
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35bd9eb7_c42e22ec",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 679,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-02-17T03:35:36Z",
      "side": 1,
      "message": "Should we mention that p is accessable by multiple goroutines?",
      "range": {
        "startLine": 679,
        "startChar": 1,
        "endLine": 679,
        "endChar": 2
      },
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f508f643_8a62882b",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 713,
      "author": {
        "id": 55800
      },
      "writtenOn": "2022-03-11T15:18:58Z",
      "side": 1,
      "message": "Similar to the change made to the first example, I\u0027d expect hoisting (possibly transiently as in a mis-predicted branch) the access to *p to be OK from a concurrency perspective [assuming usual compiler rules of not hoisting a conditional access that could access an invalid memory location].",
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9baa8934_4cd26c41",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 733,
      "author": {
        "id": 55800
      },
      "writtenOn": "2022-03-11T15:18:58Z",
      "side": 1,
      "message": "This one is a little confusing to me as a memory model example; I agree that the general case would outlaw this, and understand why synchronisation operations could create even more restrictions on moving past f than in a single-threaded program; but I think this just falls out of the base language definition *p could be modified. I\u0027d expect hardware (in absence of ordering in f) to sometimes create a read from *p here before all operations from f() complete. In my opinion this example could be dropped without losing any semantic content; but I\u0027d understand if it stayed!",
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfd68032_5358fef0",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 748,
      "author": {
        "id": 55800
      },
      "writtenOn": "2022-03-11T15:18:58Z",
      "side": 1,
      "message": "My gut reaction is \"spill\" is the wrong word here - I\u0027d use that for something destined for the stack. You want to outlaw rematerialisation through the pointer. I\u0027m not sure what word I\u0027d use for discarding something that is expected to be rematerialized; so can\u0027t offer an improvement!",
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a542228b_10f85e23",
        "filename": "doc/go_mem.html",
        "patchSetId": 4
      },
      "lineNbr": 768,
      "author": {
        "id": 55800
      },
      "writtenOn": "2022-03-11T15:18:58Z",
      "side": 1,
      "message": "Ah maybe this clarifies the above!",
      "revId": "6da6db95bb30d392169237c24e62441e3c2d63e8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}