{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9c0b1035_44126e1d",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 23,
      "author": {
        "id": 34993
      },
      "writtenOn": "2024-10-10T07:16:44Z",
      "side": 1,
      "message": "Some additional flags that we could support (probably not in this CL, but could be useful to implement `readReparseLinkAt` and for when we implement `LStatIn`:\n\n- `O_NOFOLLOW`: Implemented without `OBJ_DONT_REPARSE` but with `FILE_FLAG_OPEN_REPARSE_POINT` + a call to get the reparse point tag, and return `ELOOP` if the reparse point is a surrogate.\n- `O_NOFOLLOW` + `O_PATH`: Implemented without `OBJ_DONT_REPARSE` but with `FILE_FLAG_OPEN_REPARSE_POINT`.",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "314cd41b_308c45b6",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 23,
      "author": {
        "id": 34993
      },
      "writtenOn": "2024-10-10T11:40:14Z",
      "side": 1,
      "message": "Could you pull `Openat` into its own CL? I have a PoC that uses it instead of `syscall.Open` to implement `os.OpenFile`, and would like to mail it without having to wait for `Root`to be approved. The benefit of using `NtCreateFile` over `CreateFile` is that we can map more Unix flags to Windows options ðŸ˜Ž.",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7480c03_4a8325e4",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 23,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-10-10T18:35:30Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "314cd41b_308c45b6",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8a6264c_07eafe9b",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 23,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-10-10T18:35:30Z",
      "side": 1,
      "message": "For `O_NOFOLLOW`, when opening a non-surrogate reparse point should we behave as if `O_NOFOLLOW` wasn\u0027t present? In that case, I think we need to return the result of opening without `FILE_FLAG_OPEN_REPARSE_POINT`.",
      "parentUuid": "9c0b1035_44126e1d",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93cc352f_925ab108",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 23,
      "author": {
        "id": 34993
      },
      "writtenOn": "2024-10-10T20:22:15Z",
      "side": 1,
      "message": "\u003e For O_NOFOLLOW, when opening a non-surrogate reparse point should we behave as if O_NOFOLLOW wasn\u0027t present?\n\nYep.\n\n\u003e In that case, I think we need to return the result of opening without FILE_FLAG_OPEN_REPARSE_POINT.\n\nNon-surrogate reparse points can\u0027t be opened without the open_reparse_point flag, NtCreateFile returns `STATUS_REPARSE_POINT_ENCOUNTERED` in such case.\n\nSee this example:\n```\nfunc TestNonSurrogateReparsePoint(t *testing.T) {\n    dir :\u003d t.TempDir()\n    addr :\u003d filepath.Join(dir, \"sock\")\n    l, err :\u003d net.Listen(\"unix\", addr)\n    if err !\u003d nil {\n        t.Fatal(err)\n    }\n    defer l.Close()\n\n    r, err :\u003d os.OpenRoot(dir)\n    if err !\u003d nil {\n        t.Fatal(err)\n    }\n    defer r.Close()\n    f, err :\u003d r.Open(\"sock\")\n    if err !\u003d nil {\n        t.Fatal(err)\n    }\n    f.Close()\n}\n```",
      "parentUuid": "f8a6264c_07eafe9b",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a758103b_b889b8a3",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 23,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-10-10T20:42:42Z",
      "side": 1,
      "message": "So `O_NOFOLLOW` would open with `FILE_FLAG_OPEN_REPARSE_POINT`, and then:\n- Return the result if the file isn\u0027t a reparse point.\n- Return `ELOOP` if it\u0027s a surrogate.\n- Return `STATUS_REPARSE_POINT_ENCOUNTERED` if it isn\u0027t a surrogate (which is what we\u0027d do if `O_NOFOLLOW` wasn\u0027t present).\n\nIs that right?\n\n(And if a user actually do wants to open a reparse point as a file, they\u0027re doing something very Windows-specific and should use `NtCreateFile` directly. Or I suppose we could have a Windows-specific `O_` flag for this case.)",
      "parentUuid": "93cc352f_925ab108",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "abe89270_fd3e3210",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 58,
      "author": {
        "id": 34993
      },
      "writtenOn": "2024-10-10T05:14:26Z",
      "side": 1,
      "message": "This line should be removed.",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4c7093b8_86c24b76",
        "filename": "src/internal/syscall/windows/at_windows.go",
        "patchSetId": 32
      },
      "lineNbr": 58,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-10-10T18:35:30Z",
      "side": 1,
      "message": "Oops, fixed.",
      "parentUuid": "abe89270_fd3e3210",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6172f03_28850677",
        "filename": "src/os/root_openat.go",
        "patchSetId": 32
      },
      "lineNbr": 77,
      "author": {
        "id": 34993
      },
      "writtenOn": "2024-10-10T07:16:44Z",
      "side": 1,
      "message": "Idea (maybe not for this CL): On platforms with `O_NOFOLLOW_ANY`, if the path doesn\u0027t contain any `..` we could try to call `openat` first to see if it succeeds. If it does, we would be done and wouldn\u0027t have to do all the path traversal logic. Symlinks are rare (even more on Windows), so this could be a good speed up without impacting alot the symlink-case.",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f353205_6db994fe",
        "filename": "src/os/root_openat.go",
        "patchSetId": 32
      },
      "lineNbr": 77,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-10-10T18:35:30Z",
      "side": 1,
      "message": "I think that\u0027s a good idea; as you say, the common case doesn\u0027t involve symlinks.\n\n(This is a nice benefit to using OBJ_DONT_REPARSE; thanks for pointing me at it. I\u0027d missed that there\u0027s a way to disable reparse points anywhere on the path.)\n\nMy plan is to get the entire proposed API working portably first, and then go back to add fast paths. I\u0027d rather ship Root in Go 1.24 with the slower implementation and make it faster in 1.25 than slip the whole thing to 1.25.",
      "parentUuid": "c6172f03_28850677",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab7cbb73_f46f2bd5",
        "filename": "src/os/root_test.go",
        "patchSetId": 32
      },
      "lineNbr": 494,
      "author": {
        "id": 34993
      },
      "writtenOn": "2024-10-10T07:40:40Z",
      "side": 1,
      "message": "It\u0027s strange that this test passes on Windows builders, as it fails on my Windows box:\n\n```\n--- FAIL: TestRootConsistencyOpen (0.01s)\n    --- FAIL: TestRootConsistencyOpen/file_slash (0.01s)\n        root_test.go:538: with root:    err\u003dThe system cannot find the path specified.\n        root_test.go:539: without root: err\u003dThe directory name is invalid.\n        root_test.go:540: want consistent results, got mismatch\n--- FAIL: TestRootConsistencyCreate (0.02s)\n    --- FAIL: TestRootConsistencyCreate/file_slash (0.02s)\n        root_test.go:538: with root:    err\u003dThe system cannot find the path specified.\n        root_test.go:539: without root: err\u003dThe directory name is invalid.\n        root_test.go:540: want consistent results, got mismatch\n```\n\nI manage to fix the issue by modifing `ntCreateFileError` as follows:\n\n```\nfunc ntCreateFileError(err error, options uint32) error {\n\ts, ok :\u003d err.(NTStatus)\n\tif !ok {\n\t\t// Shouldn\u0027t really be possible, NtCreateFile always returns NTStatus.\n\t\treturn err\n\t}\n\tswitch s {\n\tcase STATUS_REPARSE_POINT_ENCOUNTERED:\n\t\treturn syscall.ELOOP\n\tcase STATUS_NOT_A_DIRECTORY:\n\t\tif options\u0026FILE_DIRECTORY_FILE !\u003d 0 {\n\t\t\treturn syscall.ENOTDIR\n\t\t}\n\tcase STATUS_FILE_IS_A_DIRECTORY:\n\t\treturn syscall.EISDIR\n\t}\n\treturn s.Errno()\n}\n```\n\nI think this change is principled, but it might be Windows-version dependent if it fails in the builders (which I haven\u0027t tested).",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af610056_bdc6abad",
        "filename": "src/os/root_test.go",
        "patchSetId": 32
      },
      "lineNbr": 494,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-10-10T18:35:30Z",
      "side": 1,
      "message": "I agree this is principled; done.\n\nReturning ENOTDIR when O_DIRECTORY isn\u0027t specified is especially confusing because syscall.ENOTDIR is mapped to ERROR_PATH_NOT_FOUND, which has a broader meaning than the Unix ENOTDIR.",
      "parentUuid": "ab7cbb73_f46f2bd5",
      "revId": "eeddd3448360d35ea6979511e029a3ab317c4617",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}