{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4d2bef13_384040ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-11-16T00:59:40Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003ddec60d56\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "dec60d56e94e56b359e64b1fcdb6bee48662a4d0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cf9482b9_d4c01ad8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-11-16T01:29:16Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "4d2bef13_384040ec",
      "tag": "autogenerated:trybots~happy",
      "revId": "dec60d56e94e56b359e64b1fcdb6bee48662a4d0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "edb0d852_6fdc0e1b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 7392
      },
      "writtenOn": "2022-11-16T22:51:40Z",
      "side": 1,
      "message": "Will abandon per your feedback and my reply.",
      "revId": "dec60d56e94e56b359e64b1fcdb6bee48662a4d0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a214ff26_b4c372dd",
        "filename": "src/cmd/compile/internal/types2/typestring.go",
        "patchSetId": 1
      },
      "lineNbr": 124,
      "author": {
        "id": 31647
      },
      "writtenOn": "2022-11-16T15:15:11Z",
      "side": 1,
      "message": "So, interestingly in the case of #56665, it is not the typewriter that was recursing infinitely. Rather, it was computeInterfaceTypeSet that was creating longer and longer instances. It just so happened that if I SIGQUIT, I was most likely to land in typeString.\n\nWe can keep this guard, if you want, but I would phrase it differently. Something like \"exceeded recursion limit writing \" + goTypeName(typ)",
      "range": {
        "startLine": 124,
        "startChar": 11,
        "endLine": 124,
        "endChar": 32
      },
      "revId": "dec60d56e94e56b359e64b1fcdb6bee48662a4d0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "876ecde0_e3e82fd9",
        "filename": "src/cmd/compile/internal/types2/typestring.go",
        "patchSetId": 1
      },
      "lineNbr": 124,
      "author": {
        "id": 7392
      },
      "writtenOn": "2022-11-16T22:51:40Z",
      "side": 1,
      "message": "Good point. This check would eventually trigger (because the types get deeper and deeper) but it\u0027s not because there\u0027s a problem with the types, but rather the generation of the types. Type cycles should be caught with the w.seen map.\n\nStill, because type writing (or hashing) is functionality that is commonly used by other parts of the system (which may have problems), an excessively long type would at least help catch those issues by stopping here. And lead an error message rather an \"endless compile\".\n\nBut such a check could be much simpler. We could just check if the size of the type is over a certain char length.",
      "parentUuid": "a214ff26_b4c372dd",
      "range": {
        "startLine": 124,
        "startChar": 11,
        "endLine": 124,
        "endChar": 32
      },
      "revId": "dec60d56e94e56b359e64b1fcdb6bee48662a4d0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}