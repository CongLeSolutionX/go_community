{
  "comments": [
    {
      "key": {
        "uuid": "ebbdfaca_f3d19073",
        "filename": "src/cmd/compile/internal/gc/parser.go",
        "patchSetId": 2
      },
      "lineNbr": 3016,
      "author": {
        "id": 5440
      },
      "writtenOn": "2016-04-12T17:15:57Z",
      "side": 1,
      "message": "This seems inconsistent:\n1. You added this code to parser.go\u0027s textual export data parsing, but not to bimport.go\u0027s binary export data parsing.\n2. You\u0027re not queueing s3 if it contains a TFORW type, so we don\u0027t end up checking it later.",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b524ead_e2aa624d",
        "filename": "src/cmd/compile/internal/gc/parser.go",
        "patchSetId": 2
      },
      "lineNbr": 3016,
      "author": {
        "id": 11915
      },
      "writtenOn": "2016-04-13T05:11:34Z",
      "side": 1,
      "message": "I added this code because it was previously part of typMap(). There\u0027s no call to typMap and no map type checking in the binary export, which brings me to your second point. If the parsing stage succeeds, this node gets checked again anyway during the full type check at which point the forward types are properly enqueued. This is why it\u0027s not in the binary export. This type check could be removed from the parsing stage, and maybe it\u0027s worth considering. The compiler would be less upfront about these errors, but we wouldn\u0027t have to check the type twice in the successful case and would make the textual and binary exports consistent.",
      "parentUuid": "ebbdfaca_f3d19073",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b524ead_85112877",
        "filename": "src/cmd/compile/internal/gc/parser.go",
        "patchSetId": 2
      },
      "lineNbr": 3016,
      "author": {
        "id": 5440
      },
      "writtenOn": "2016-04-13T06:30:17Z",
      "side": 1,
      "message": "I see, thanks. I would just omit it then. No need to proactively validate export data that we won\u0027t end up using, as long as we do validate the data that we do use.",
      "parentUuid": "0b524ead_e2aa624d",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebbdfaca_931bfc56",
        "filename": "src/cmd/compile/internal/gc/typecheck.go",
        "patchSetId": 2
      },
      "lineNbr": 426,
      "author": {
        "id": 5440
      },
      "writtenOn": "2016-04-12T17:15:57Z",
      "side": 1,
      "message": "Change mapqueue into something like []struct{n *Node; lno int32}, so that we can get rid of maplineno.",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b524ead_629f322c",
        "filename": "src/cmd/compile/internal/gc/typecheck.go",
        "patchSetId": 2
      },
      "lineNbr": 426,
      "author": {
        "id": 11915
      },
      "writtenOn": "2016-04-13T05:11:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ebbdfaca_931bfc56",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebbdfaca_335f88f0",
        "filename": "src/cmd/compile/internal/gc/typecheck.go",
        "patchSetId": 2
      },
      "lineNbr": 3546,
      "author": {
        "id": 5440
      },
      "writtenOn": "2016-04-12T17:15:57Z",
      "side": 1,
      "message": "Why?",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b524ead_02d74ec6",
        "filename": "src/cmd/compile/internal/gc/typecheck.go",
        "patchSetId": 2
      },
      "lineNbr": 3546,
      "author": {
        "id": 11915
      },
      "writtenOn": "2016-04-13T05:11:34Z",
      "side": 1,
      "message": "Removed.",
      "parentUuid": "ebbdfaca_335f88f0",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebbdfaca_d379f451",
        "filename": "src/cmd/compile/internal/gc/typecheck.go",
        "patchSetId": 2
      },
      "lineNbr": 3619,
      "author": {
        "id": 5440
      },
      "writtenOn": "2016-04-12T17:15:57Z",
      "side": 1,
      "message": "I\u0027m a little suspicious of this. In particular, I\u0027m nervous there could still be types queued that aren\u0027t fully resolved yet, which this would give false positives for.\n\nHowever, if it\u0027s true that at this point all of mapqueue is guarantee is fully resolved, then we can also add a \"mapqueue \u003d nil\" assignment after the loop.\n\nLastly, use:\n\n    if !n.Type.IsComparable() {\n\ninstead of checking for ANOEQ.",
      "revId": "5d327bd4dff7f77caf03d9be30447a56834ebef8",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}