{
  "comments": [
    {
      "key": {
        "uuid": "11eec58c_06e01615",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-03-20T20:20:58Z",
      "side": 1,
      "message": "This makes me wonder whether we should use a pointer-to-sync.Pool instead of a value: without the sync.Mutex to contend on, is there any advantage to having a separate pool per copy?",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b984768_481dac8a",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 26981
      },
      "writtenOn": "2018-03-20T20:28:06Z",
      "side": 1,
      "message": "That\u0027s a good point. However, if I made that change, I would want a test to ensure that we aren\u0027t hurting the performance for any user who currently relies on Copy to avoid lock contention, and I\u0027m not sure how to verify that.\n\nhttps://golang.org/pkg/regexp/#Regexp.Copy\n\"When using a Regexp in multiple goroutines, giving each goroutine its own copy helps to avoid lock contention.\"",
      "parentUuid": "11eec58c_06e01615",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e02628d_dcc19534",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-03-20T20:32:01Z",
      "side": 1,
      "message": "I think BenchmarkMatchParallelCopied measures that directly?\n\n(It may be that we should remove that second sentence entirely in this change: if we resolve the contention issues for non-copied Regexps, it is possible that Copy no longer provides an advantage at all.)",
      "parentUuid": "6b984768_481dac8a",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdb63df8_57c8bd9f",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 26981
      },
      "writtenOn": "2018-03-20T20:40:45Z",
      "side": 1,
      "message": "I\u0027ll defer that decision to you. It is tempting, because that means that existing programs that rely on Copy become more memory efficient because they can share the cache. On the other hand, I don\u0027t know anything about the scalability limits of sync.Pool. Say it doesn\u0027t scale well above 256 cores, what happens if a user complains that Copy performs worse on a 512-core machine?",
      "parentUuid": "5e02628d_dcc19534",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5fa62206_4e846127",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-03-20T21:03:51Z",
      "side": 1,
      "message": "If sync.Pool doesn\u0027t scale, we should fix it. :)\n(Pretty much the entire point of sync.Pool is to scale well with CPUs.)\n\nI suspect that the more likely mode of regression for this change would be an increase in memory usage for non-copied Regexps. (Running with the -benchmem flag would help to confirm or refute that.)\n\nIf a Regexp is used sequentially by goroutines running on N different cores, the sync.Mutex implementation will only allocate O(1) state machines. With sync.Pool, it may allocate O(N) machines. On the other hand, under contention sync.Mutex blows up to O(N) time per Lock/Unlock, while sync.Pool should remain O(1). This change is fundamentally a space/time tradeoff, but I think it moves that tradeoff in the right direction.",
      "parentUuid": "fdb63df8_57c8bd9f",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8db8c2a3_d1b3b346",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 26981
      },
      "writtenOn": "2018-03-20T21:24:34Z",
      "side": 1,
      "message": "Fair enough. Fixed.",
      "parentUuid": "5fa62206_4e846127",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}