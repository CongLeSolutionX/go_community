{
  "comments": [
    {
      "key": {
        "uuid": "11eec58c_06e01615",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-03-20T20:20:58Z",
      "side": 1,
      "message": "This makes me wonder whether we should use a pointer-to-sync.Pool instead of a value: without the sync.Mutex to contend on, is there any advantage to having a separate pool per copy?",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b984768_481dac8a",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 26981
      },
      "writtenOn": "2018-03-20T20:28:06Z",
      "side": 1,
      "message": "That\u0027s a good point. However, if I made that change, I would want a test to ensure that we aren\u0027t hurting the performance for any user who currently relies on Copy to avoid lock contention, and I\u0027m not sure how to verify that.\n\nhttps://golang.org/pkg/regexp/#Regexp.Copy\n\"When using a Regexp in multiple goroutines, giving each goroutine its own copy helps to avoid lock contention.\"",
      "parentUuid": "11eec58c_06e01615",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e02628d_dcc19534",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-03-20T20:32:01Z",
      "side": 1,
      "message": "I think BenchmarkMatchParallelCopied measures that directly?\n\n(It may be that we should remove that second sentence entirely in this change: if we resolve the contention issues for non-copied Regexps, it is possible that Copy no longer provides an advantage at all.)",
      "parentUuid": "6b984768_481dac8a",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdb63df8_57c8bd9f",
        "filename": "src/regexp/regexp.go",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 26981
      },
      "writtenOn": "2018-03-20T20:40:45Z",
      "side": 1,
      "message": "I\u0027ll defer that decision to you. It is tempting, because that means that existing programs that rely on Copy become more memory efficient because they can share the cache. On the other hand, I don\u0027t know anything about the scalability limits of sync.Pool. Say it doesn\u0027t scale well above 256 cores, what happens if a user complains that Copy performs worse on a 512-core machine?",
      "parentUuid": "5e02628d_dcc19534",
      "range": {
        "startLine": 114,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "a6c656427760921a7dfa6ff74bb6a2445faf2d79",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}