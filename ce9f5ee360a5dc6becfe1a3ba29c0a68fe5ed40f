{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3e4c5b1a_a526fbe2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 5137
      },
      "writtenOn": "2024-04-23T11:35:19Z",
      "side": 1,
      "message": "net: make sendfile work again with non-*os.File readers on macOS",
      "revId": "ce9f5ee360a5dc6becfe1a3ba29c0a68fe5ed40f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fc1028c_4bbdadb2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5137
      },
      "writtenOn": "2024-04-23T11:33:51Z",
      "side": 1,
      "message": "Thank you Philipp! Let\u0027s also lock-in with a regression test to ensure that this code doesn\u0027t trivially regress with this code (please modify as suits you) inside net/sendfile_unix_alt_test.go:\n\n// Copyright 2024 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build (darwin \u0026\u0026 !ios) || dragonfly || freebsd || solaris\n\npackage net\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"io/fs\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype sendFileMocker struct {\n\tcursor  int64\n\tcontent []byte\n\n\tseekInvoked        bool\n\tsyscallConnInvoked bool\n}\n\nvar _ fs.File \u003d (*sendFileMocker)(nil)\nvar _ syscall.Conn \u003d (*sendFileMocker)(nil)\n\nfunc TestSendFileWorksOnNonOsFilesToo(t *testing.T) {\n\tln, err :\u003d Listen(\"tcp\", \":0\")\n\tif err !\u003d nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tgo func() {\n\t\tconn, err :\u003d ln.Accept()\n\t\tif err !\u003d nil {\n\t\t\tpanic(err)\n\t\t}\n\t\t_, _ \u003d io.Copy(io.Discard, conn)\n\t}()\n\n\tc, err :\u003d Dial(\"tcp\", ln.Addr().String())\n\tif err !\u003d nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer c.Close()\n\n\tsfm :\u003d \u0026sendFileMocker{content: []byte(\"abcdefghijklmno\")}\n\n\ttcpConn :\u003d c.(*TCPConn)\n\t_, err, _ \u003d sendFile(tcpConn.fd, sfm)\n\tif err \u003d\u003d nil || err.Error() !\u003d \"purposefully not available\" {\n\t\tt.Fatal(\"Purposefully expected .SyscallConn to return an error\")\n\t}\n\n\t// After this invocation, sfm\u0027s variables must be set to true.\n\tif !sfm.seekInvoked {\n\t\tt.Error(\".Seek was not invoked!\")\n\t}\n\tif !sfm.syscallConnInvoked {\n\t\tt.Error(\".SyscallConn was not invoked!\")\n\t}\n}\n\nfunc (sfm *sendFileMocker) SyscallConn() (syscall.RawConn, error) {\n\tsfm.syscallConnInvoked \u003d true\n\treturn nil, errors.New(\"purposefully not available\")\n}\n\nfunc (sfm *sendFileMocker) Seek(offset int64, whence int) (int64, error) {\n\tsfm.seekInvoked \u003d true\n\tif whence \u003d\u003d io.SeekEnd {\n\t\toffset \u003d -offset\n\t} else if whence \u003d\u003d io.SeekStart {\n\t\tsfm.cursor \u003d 0\n\t}\n\tsfm.cursor +\u003d offset\n\treturn sfm.cursor, nil\n}\n\nfunc (sfm *sendFileMocker) Size() int64 {\n\treturn int64(len(sfm.content))\n}\n\nfunc (sfm *sendFileMocker) Close() error {\n\treturn nil\n}\n\nfunc (sfm *sendFileMocker) Stat() (fs.FileInfo, error) {\n\treturn \u0026mockFileInfo{sfm.Size()}, nil\n}\n\ntype mockFileInfo struct{ size int64 }\n\nvar _ fs.FileInfo \u003d (*mockFileInfo)(nil)\n\nfunc (mfi *mockFileInfo) Name() string       { return \"in-memory\" }\nfunc (mfi *mockFileInfo) Size() int64        { return mfi.size }\nfunc (mfi *mockFileInfo) IsDir() bool        { return false }\nfunc (mfi *mockFileInfo) Sys() any           { return nil }\nfunc (mfi *mockFileInfo) Mode() fs.FileMode  { return 0 }\nfunc (mfi *mockFileInfo) ModTime() time.Time { return time.Now() }\n\nfunc (sfm *sendFileMocker) Read(b []byte) (int, error) {\n\tn :\u003d copy(b, sfm.content[sfm.cursor:])\n\treturn n, nil\n}",
      "revId": "ce9f5ee360a5dc6becfe1a3ba29c0a68fe5ed40f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}