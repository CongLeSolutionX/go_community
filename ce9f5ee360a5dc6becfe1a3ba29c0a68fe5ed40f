{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3e4c5b1a_a526fbe2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 5137
      },
      "writtenOn": "2024-04-23T11:35:19Z",
      "side": 1,
      "message": "net: make sendfile work again with non-*os.File readers on macOS",
      "revId": "ce9f5ee360a5dc6becfe1a3ba29c0a68fe5ed40f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0cb8e5fa_854d0b0a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-04-26T17:08:21Z",
      "side": 1,
      "message": "Your phrasing is a bit better, but I think the one on the CL is good enough. I\u0027m going to resolve this comment so we can submit the fix CL and follow up with CL 581778 to add some tests.",
      "parentUuid": "3e4c5b1a_a526fbe2",
      "revId": "ce9f5ee360a5dc6becfe1a3ba29c0a68fe5ed40f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fc1028c_4bbdadb2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5137
      },
      "writtenOn": "2024-04-23T11:33:51Z",
      "side": 1,
      "message": "Thank you Philipp! Let\u0027s also lock-in with a regression test to ensure that this code doesn\u0027t trivially regress with this code (please modify as suits you) inside net/sendfile_unix_alt_test.go:\n\n// Copyright 2024 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build (darwin \u0026\u0026 !ios) || dragonfly || freebsd || solaris\n\npackage net\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"io/fs\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype sendFileMocker struct {\n\tcursor  int64\n\tcontent []byte\n\n\tseekInvoked        bool\n\tsyscallConnInvoked bool\n}\n\nvar _ fs.File \u003d (*sendFileMocker)(nil)\nvar _ syscall.Conn \u003d (*sendFileMocker)(nil)\n\nfunc TestSendFileWorksOnNonOsFilesToo(t *testing.T) {\n\tln, err :\u003d Listen(\"tcp\", \":0\")\n\tif err !\u003d nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tgo func() {\n\t\tconn, err :\u003d ln.Accept()\n\t\tif err !\u003d nil {\n\t\t\tpanic(err)\n\t\t}\n\t\t_, _ \u003d io.Copy(io.Discard, conn)\n\t}()\n\n\tc, err :\u003d Dial(\"tcp\", ln.Addr().String())\n\tif err !\u003d nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer c.Close()\n\n\tsfm :\u003d \u0026sendFileMocker{content: []byte(\"abcdefghijklmno\")}\n\n\ttcpConn :\u003d c.(*TCPConn)\n\t_, err, _ \u003d sendFile(tcpConn.fd, sfm)\n\tif err \u003d\u003d nil || err.Error() !\u003d \"purposefully not available\" {\n\t\tt.Fatal(\"Purposefully expected .SyscallConn to return an error\")\n\t}\n\n\t// After this invocation, sfm\u0027s variables must be set to true.\n\tif !sfm.seekInvoked {\n\t\tt.Error(\".Seek was not invoked!\")\n\t}\n\tif !sfm.syscallConnInvoked {\n\t\tt.Error(\".SyscallConn was not invoked!\")\n\t}\n}\n\nfunc (sfm *sendFileMocker) SyscallConn() (syscall.RawConn, error) {\n\tsfm.syscallConnInvoked \u003d true\n\treturn nil, errors.New(\"purposefully not available\")\n}\n\nfunc (sfm *sendFileMocker) Seek(offset int64, whence int) (int64, error) {\n\tsfm.seekInvoked \u003d true\n\tif whence \u003d\u003d io.SeekEnd {\n\t\toffset \u003d -offset\n\t} else if whence \u003d\u003d io.SeekStart {\n\t\tsfm.cursor \u003d 0\n\t}\n\tsfm.cursor +\u003d offset\n\treturn sfm.cursor, nil\n}\n\nfunc (sfm *sendFileMocker) Size() int64 {\n\treturn int64(len(sfm.content))\n}\n\nfunc (sfm *sendFileMocker) Close() error {\n\treturn nil\n}\n\nfunc (sfm *sendFileMocker) Stat() (fs.FileInfo, error) {\n\treturn \u0026mockFileInfo{sfm.Size()}, nil\n}\n\ntype mockFileInfo struct{ size int64 }\n\nvar _ fs.FileInfo \u003d (*mockFileInfo)(nil)\n\nfunc (mfi *mockFileInfo) Name() string       { return \"in-memory\" }\nfunc (mfi *mockFileInfo) Size() int64        { return mfi.size }\nfunc (mfi *mockFileInfo) IsDir() bool        { return false }\nfunc (mfi *mockFileInfo) Sys() any           { return nil }\nfunc (mfi *mockFileInfo) Mode() fs.FileMode  { return 0 }\nfunc (mfi *mockFileInfo) ModTime() time.Time { return time.Now() }\n\nfunc (sfm *sendFileMocker) Read(b []byte) (int, error) {\n\tn :\u003d copy(b, sfm.content[sfm.cursor:])\n\treturn n, nil\n}",
      "revId": "ce9f5ee360a5dc6becfe1a3ba29c0a68fe5ed40f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7169b67d_7fb607e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 26369
      },
      "writtenOn": "2024-04-24T08:55:59Z",
      "side": 1,
      "message": "Hi Emmanuel,\n\nThank you for providing the regression test!\n\nWhile I was integrating it into my CL, I noticed that there\u0027s already a `net/sendfile_test.go` that aims to test exactly what broke here (using `io.Copy(conn, f)`), but it only \"assumes\" that `io.Copy` uses sendfile and doesn\u0027t actually check whether it does. So the test passes even if sendfile is never used.\n\nFor extra fun, not only does it not catch the regression on macOS, this test doesn\u0027t even test the `sendFile` method in `net/sendfile_linux.go` either, because since CL 472475 `io.Copy` doesn\u0027t end up calling any code in `net`, instead it goes through `zero_copy_linux.go`, which has its own duplicated implementation of `sendFile`.\n\nI\u0027m too new to the Go project to judge whether this is all working as intended or should be cleaned up, but I think what we should definitely do is to fix `net/sendfile_test.go` to actually check what it thinks it\u0027s checking.\n\nI\u0027m currently trying to think of a way to do it cleanly, possibly based on the `hookSendFile` mechanism that `os/writeto_linux_test.go` uses. I won\u0027t be able to look into it today, though - if you have a good idea in the meantime, please let me know. :)\n\nBy the way, I noticed that `net/sendfile_linux.go` also currently checks explicitly for the type `os.File`... I wonder if I should change that, too, for consistency, even though it is currently (apparently) not causing issues.",
      "parentUuid": "9fc1028c_4bbdadb2",
      "revId": "ce9f5ee360a5dc6becfe1a3ba29c0a68fe5ed40f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26808805_d97c1a55",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-04-25T19:03:05Z",
      "side": 1,
      "message": "This is all a giant mess, and it seems to have gotten messier since CL 462475. (When copying from an *os.File to a *net.TCPConn, sendfile may now be called by either the net or os package depending on the GOOS. That\u0027s not confusing at all.)\n\nhttps://go.dev/cl/581778 adds validation that sendfile is called when expected to `net/sendfile_test.go`. Let\u0027s go ahead with your CL here as-is, which fixes the immediate issue of #66988, and then we can add the tests from CL 581778.",
      "parentUuid": "7169b67d_7fb607e0",
      "revId": "ce9f5ee360a5dc6becfe1a3ba29c0a68fe5ed40f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}