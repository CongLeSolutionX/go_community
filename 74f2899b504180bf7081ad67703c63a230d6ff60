{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9c2dd122_86430c22",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 533,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-12-23T05:51:00Z",
      "side": 1,
      "message": "If we\u0027re now using lockedfile.Create to write the file, should we be using lockedfile.Read to read from it?\n\n(robustio.ReadFile retries on failure, but it does not guarantee atomicity.)",
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d1370279_85e36420",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 533,
      "author": {
        "id": 10033
      },
      "writtenOn": "2021-03-11T23:23:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9c2dd122_86430c22",
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f91725c_c8e1123d",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 561,
      "author": {
        "id": 17092
      },
      "writtenOn": "2020-12-23T17:24:56Z",
      "side": 1,
      "message": "I\u0027m really nervous about this change in particular.\n\nWith renameio, we had the guarantee that under normal operation (no system crash), concurrent processes would only see complete .mod, .info, and .zip files in the module cache. We talked about proxies here, but that also includes previous versions of the go command sharing the cache.\n\nCould we get the same performance benefit by continuing to use renameio but removing the fsync? fsync should only protect against corruption after a system crash, and we probably aren\u0027t using it correctly since we aren\u0027t also calling fsync on the parent directory. In normal operation, fsync shouldn\u0027t make a difference.\n\nI\u0027d feel a lot safer if we didn\u0027t have to rely on file locking.",
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d5c4a9f_9213f374",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 561,
      "author": {
        "id": 10033
      },
      "writtenOn": "2021-03-11T23:23:10Z",
      "side": 1,
      "message": "Yeah, we could definitely get the same performance benefit by just removing the fsync. And I\u0027d prefer it because writing and renaming a file is easier to reason about than file locking.",
      "parentUuid": "5f91725c_c8e1123d",
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "964b6902_1267c202",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 574,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-12-23T05:51:00Z",
      "side": 1,
      "message": "Should writeDiskCache verify that `data` does not contain trailing zeroes, to ensure that we can distinguish successful writes from failed ones?\n\nShould readDiskCache return errNotCached if the data it reads does contain trailing zeroes? (If not, do we need to update any individual callers to re-fetch or regenerate files in case of corruption or truncation?)",
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5f30eb81_ca6d0b3b",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 574,
      "author": {
        "id": 10033
      },
      "writtenOn": "2021-03-11T23:23:10Z",
      "side": 1,
      "message": "is it sufficient to just check the last byte? Are the files guaranteed to be written sequentially?\n\nYeah, if we know the file doesn\u0027t contain trailing zeroes readDiskCache should definitely return errNotCache if the data does.",
      "parentUuid": "964b6902_1267c202",
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3eac3234_92f1d296",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 578,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-12-23T05:51:00Z",
      "side": 1,
      "message": "f.Write(data) should suffice. (Truncate does not change the file\u0027s offset.)",
      "range": {
        "startLine": 578,
        "startChar": 14,
        "endLine": 578,
        "endChar": 32
      },
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d8f5ec24_8cdf96bb",
        "filename": "src/cmd/go/internal/modfetch/cache.go",
        "patchSetId": 6
      },
      "lineNbr": 578,
      "author": {
        "id": 10033
      },
      "writtenOn": "2021-03-11T23:23:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3eac3234_92f1d296",
      "range": {
        "startLine": 578,
        "startChar": 14,
        "endLine": 578,
        "endChar": 32
      },
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c08a044_df949fa1",
        "filename": "src/cmd/go/internal/renameio/renameio.go",
        "patchSetId": 6
      },
      "lineNbr": 18,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-12-23T05:51:00Z",
      "side": 1,
      "message": "If we\u0027re not using renamio, then the calls to renameio.Pattern should go away too.\n\nThe only purpose of renamio.Pattern is to clean up files left over from failed calls to renameio.WriteFile, and it\u0027s probably not worth keeping the code around to clean up a constant number of existing files.\n\n(Especially given that — as discovered in https://go-review.googlesource.com/c/go/+/277412/12/src/cmd/go/internal/renameio/renameio.go#67 — the pattern probably no longer works for cleaning up files anyway.)",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 18,
        "endChar": 1
      },
      "revId": "74f2899b504180bf7081ad67703c63a230d6ff60",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}