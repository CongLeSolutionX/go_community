{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "965bc6eb_fdca77c1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 8495
      },
      "writtenOn": "2024-02-27T00:06:18Z",
      "side": 1,
      "message": "The new comment is more accurate in one dimension, but now less accurate in another dimension.\n\nWe need to capture two effects:\n* When matching a particular JSON name to a Go struct field, we prefer exact match over a case-insensitive match (e.g., https://go.dev/play/p/8PHUZJFqDHO).\n* JSON object members are unmarhaled in the order syntactically seen. Thus, latter members that matches a previously seen Go struct field will be \"merged\" into the field.\n\nI use the term \"merge\" loosely since it\u0027s neither true merging nor overriding. The exact semantics are complicated.",
      "revId": "c1304558528ae0b5191ee3e3f9142f69dda68dd0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66cefe5b_39973052",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 3325703
      },
      "writtenOn": "2024-02-27T06:50:20Z",
      "side": 1,
      "message": "Why is it to overwriting? See here: https://go.dev/play/p/2a3kQ03Ij10\n\nIn both cases the first field gets overwritten by the json field \"NAME\". I would not expect this and i think its a bug and not just an unprecise documentation.\n\nIn the example i would expect the output:\n\n{Foo Bar}\n{Bar Foo} \n\nbut it is \n\n{BAZ Bar}\n{BAR Foo}\n\nThe decoder is correctly assigning fields with exact matches. But if it has a field where no exact match can be found, it selects the first field in the struct and just writes its value, even if the value is already set.",
      "parentUuid": "965bc6eb_fdca77c1",
      "revId": "c1304558528ae0b5191ee3e3f9142f69dda68dd0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "470dea52_f34dadf6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 8495
      },
      "writtenOn": "2024-02-27T06:59:37Z",
      "side": 1,
      "message": "\u003e But if it has a field where no exact match can be found, it selects the first field in the struct and just writes its value\n\nThe first effect I stated can be further refined with \"In the event that multiple case-insensitive matches exist, the first one is selected.\" It doesn\u0027t just select the \"first field in the struct\", but the first field of all that have a case-insensitive match.\n\n\u003e Why is it to overwriting? In both cases the first field gets overwritten by the json field \"NAME\". \n\nThe \"overwriting\" is due to merge semantics for scalar values generally being equivalent to overwriting. What you are observing is the application of the second rule that I stated (i.e., duplicate fields are merged into previously seen fields).\n\nAll-in-all, the rules around this is a mess because case-insensitive matching is the default semantic in v1 \"encoding/json\". The proposed v2 design makes matching case-sensitive by default, which avoids this whole can of worms.",
      "parentUuid": "66cefe5b_39973052",
      "revId": "c1304558528ae0b5191ee3e3f9142f69dda68dd0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}