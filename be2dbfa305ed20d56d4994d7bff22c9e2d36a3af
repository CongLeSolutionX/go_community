{
  "comments": [
    {
      "key": {
        "uuid": "0251cd37_1fe1fec4",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-04-24T15:55:20Z",
      "side": 1,
      "message": "(nit)\n\ntype token struct{}\nsema :\u003d make(chan token, ‚Ä¶)\n\n\n(to make clear that the tokens carry no information)",
      "range": {
        "startLine": 57,
        "startChar": 14,
        "endLine": 57,
        "endChar": 23
      },
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4111959_cdc1486e",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 13550
      },
      "writtenOn": "2020-04-24T16:03:41Z",
      "side": 1,
      "message": "Sure. I\u0027m just lazy :)",
      "parentUuid": "0251cd37_1fe1fec4",
      "range": {
        "startLine": 57,
        "startChar": 14,
        "endLine": 57,
        "endChar": 23
      },
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "35f0ecaf_b7f5c649",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 17092
      },
      "writtenOn": "2020-04-24T14:01:05Z",
      "side": 1,
      "message": "Channeling bcmills, move the semaphore lock outside the goroutine. The semaphore should not only prevent goroutines from competing for limited resources, but it should also prevent the creation of goroutines that can\u0027t immediately do work.",
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ae8abaa0_e9b1bb3f",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 13550
      },
      "writtenOn": "2020-04-24T14:18:42Z",
      "side": 1,
      "message": "Good idea, though then that makes chanOK break, since its buffer is not big enough to hold all results.\n\nDo we simply use make(chan bool, len(mods))? Or do we just fall back to a waitgroup and a make([]bool, len(mods))?",
      "parentUuid": "35f0ecaf_b7f5c649",
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8dc042ed_94571d07",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-04-24T15:55:20Z",
      "side": 1,
      "message": "\u003e Channeling bcmills\n\nüíØ\n\n\u003e Do we simply use make(chan bool, len(mods))? Or do we just fall back to a waitgroup and a make([]bool, len(mods))?\n\nIdeally I think we should make the output deterministic, so I would be inclined to use a ‚Äúfuture pattern‚Äù: a slice of `\u003c-chan error` that we can then iterate in order, regardless of the order of completion, and then move the `base.Errorf` call from `verifyMod` to the caller side.\n(https://play.golang.org/p/4asM7eU0W-M)",
      "parentUuid": "ae8abaa0_e9b1bb3f",
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18258929_27206c01",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 13550
      },
      "writtenOn": "2020-04-24T16:03:41Z",
      "side": 1,
      "message": "I initially worried about determinism, but then convinced myself that it doesn\u0027t matter here. The output should generally be empty, and when there is an error, I struggle to think why anyone would care about its determinism. I don\u0027t think other mod commands like \u0027tidy\u0027 and \u0027download\u0027 are expected to be deterministic in their stdout/stderr.\n\nIf you feel strongly about this, happy to change it, though :) You\u0027ve clearly put more time in that playground link than I have in this entire CL, so I definitely don\u0027t mean to brush off your thoughts.\n\n\u003e a slice of chan...\n\nIt seems overkill to use a slice of channels than just a slice of boolean, though. Is that so that we can show errors as they appear, instead of all at the end? Is that really worth the effort given that the non-error case doesn\u0027t show any progress at all?\n\n(were \"effort\" here is both in code complexity, and in the overhead of more channels)",
      "parentUuid": "8dc042ed_94571d07",
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1b7df4a_085c47ab",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-04-24T16:08:52Z",
      "side": 1,
      "message": "\u003e It seems overkill to use a slice of channels than just a slice of boolean, though. Is that so that we can show errors as they appear, instead of all at the end?\n\nYes, and it also serves as the synchronization mechanism for the end of the run (instead of collecting all of the semaphore tokens or using a separate WaitGroup, either of which would also work for that purpose).\n\n\n\u003e Is that really worth the effort given that the non-error case doesn\u0027t show any progress at all?\n\nI think so? If you have a large `go mod verify` run, it seems useful to know that it failed as soon as possible. (If you plan to fix it by running `go clean -modcache`, you don\u0027t really need to wait for the rest of the run to complete in order to do that.)\n\n\n\u003e (were \"effort\" here is both in code complexity, and in the overhead of more channels)\n\nI suspect that the code complexity is basically a wash, since we need to wait for the goroutines to finish one way or the other. (The LoC impact is not much more than what we\u0027d have with a WaitGroup, or a loop to collect the tokens.)\n\nI would expect the synchronization and memory overhead of the channels themselves to be dwarfed by the actual verification (and the in-memory representation of the build list in the first place).",
      "parentUuid": "18258929_27206c01",
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ff25e6f_13acd512",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 13550
      },
      "writtenOn": "2020-04-26T19:50:59Z",
      "side": 1,
      "message": "SGTM. Just one minor problem: note that verifyMod can actually report multiple errors, because some simply set ok\u003dfalse instead of doing a \"return false\" directly.\n\nSo simply returning an error won\u0027t do. We could return []error, but that\u0027s where the code starts getting a bit weird. Any ideas?",
      "parentUuid": "f1b7df4a_085c47ab",
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b63683d3_176796d1",
        "filename": "src/cmd/go/internal/modcmd/verify.go",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 6365
      },
      "writtenOn": "2020-04-27T15:29:24Z",
      "side": 1,
      "message": "Returning `[]error` seems fine to me: that makes it clear that `verifyMod` can report multiple errors per module.\n\n(Besides, as long as we never return a non-nil zero-length slice, even callers that accidentally use `!\u003d nil` wouldn\u0027t actually be incorrect.)",
      "parentUuid": "1ff25e6f_13acd512",
      "revId": "be2dbfa305ed20d56d4994d7bff22c9e2d36a3af",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}