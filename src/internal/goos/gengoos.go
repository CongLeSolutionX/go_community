// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strconv"
	"strings"
)

func main() {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "../../go/build/syslist.go", nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	kos, ok := f.Scope.Objects["knownOS"]
	if !ok {
		log.Fatal("knownOS not found")
	}

	if kos.Kind != ast.Var {
		log.Fatal("knownOS is not a variable declaration")
	}

	valueSpec, ok := kos.Decl.(*ast.ValueSpec)
	if !ok {
		log.Fatal("knownOS is not a value assignement")
	}
	if len(valueSpec.Values) != 1 {
		log.Fatal("knownOS expected 1 value")
	}
	m, ok := valueSpec.Values[0].(*ast.CompositeLit)
	if !ok {
		log.Fatal("knownOS not a composite literal")
	}

	gooses := make([]string, len(m.Elts))
	for i, e := range m.Elts {
		kv, ok := e.(*ast.KeyValueExpr)
		if !ok {
			log.Fatal("expected key value pairs")
		}
		k, ok := kv.Key.(*ast.BasicLit)
		if !ok {
			log.Fatalf("unkown key at index %d; %T", i, kv.Key)
		}

		gooses[i], err = strconv.Unquote(k.Value)
		if err != nil {
			log.Fatal(err)
		}
	}

	for _, target := range gooses {
		if target == "nacl" {
			continue
		}
		var tags []string
		if target == "linux" {
			tags = append(tags, "!android") // must explicitly exclude android for linux
		}
		if target == "solaris" {
			tags = append(tags, "!illumos") // must explicitly exclude illumos for solaris
		}
		if target == "darwin" {
			tags = append(tags, "!ios") // must explicitly exclude ios for darwin
		}
		tags = append(tags, target) // must explicitly include target for bootstrapping purposes
		var buf bytes.Buffer
		fmt.Fprintf(&buf, "// Code generated by gengoos.go using 'go generate'. DO NOT EDIT.\n\n")
		fmt.Fprintf(&buf, "//go:build %s\n\n", strings.Join(tags, " && "))
		fmt.Fprintf(&buf, "package goos\n\n")
		fmt.Fprintf(&buf, "const GOOS = `%s`\n\n", target)
		for _, goos := range gooses {
			value := 0
			if goos == target {
				value = 1
			}
			fmt.Fprintf(&buf, "const Is%s = %d\n", strings.Title(goos), value)
		}
		err := os.WriteFile("zgoos_"+target+".go", buf.Bytes(), 0666)
		if err != nil {
			log.Fatal(err)
		}
	}
}
