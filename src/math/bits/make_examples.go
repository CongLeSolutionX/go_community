// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// This program generates example_test.go.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"math/bits"
	"sort"
)

var (
	header = []byte(`// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by go run make_examples.go. DO NOT EDIT.

package bits_test

import (
	"fmt"
	"math/bits"
)

`)

	baseF = `
func Example%s() {
	%%s
	// Output:
	%%s
}
`
)

func main() {
	buf := bytes.NewBuffer(header)

	for _, e := range bitsExamples {
		sizes := sortedSizes(e.results)

		for _, size := range sizes {
			fname := fmt.Sprintf("%s%d", e.name, size)
			format := fmt.Sprintf(baseF, fname)
			cond, out := e.f(fname, size, e.in, e.results[size])
			fmt.Fprintf(buf, format, cond, out)
		}
	}

	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile("example_test.go", out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

type condResFunc func(fname string, size uint, input interface{}, result interface{}) (cond, res string)

var bitsExamples = []struct {
	name    string
	in      interface{}
	results map[uint]interface{}
	f       condResFunc
}{
	{
		name: "LeadingZeros",
		in:   1,
		results: map[uint]interface{}{
			8:  bits.LeadingZeros8(1),
			16: bits.LeadingZeros16(1),
			32: bits.LeadingZeros32(1),
			64: bits.LeadingZeros64(1),
		},
		f: condResReg,
	}, {
		name: "TrailingZeros",
		in:   14,
		results: map[uint]interface{}{
			8:  bits.TrailingZeros8(14),
			16: bits.TrailingZeros16(14),
			32: bits.TrailingZeros32(14),
			64: bits.TrailingZeros64(14),
		},
		f: condResReg,
	}, {
		name: "OnesCount",
		in:   14,
		results: map[uint]interface{}{
			8:  bits.OnesCount8(14),
			16: bits.OnesCount16(14),
			32: bits.OnesCount32(14),
			64: bits.OnesCount64(14),
		},
		f: condResReg,
	}, {
		name: "RotateLeft",
		in:   []int{15, 2},
		results: map[uint]interface{}{
			8:  bits.RotateLeft8(15, 2),
			16: bits.RotateLeft16(15, 2),
			32: bits.RotateLeft32(15, 2),
			64: bits.RotateLeft64(15, 2),
		},
		f: condResRot,
	}, {
		name: "Reverse",
		in:   15,
		results: map[uint]interface{}{
			8:  bits.Reverse8(15),
			16: bits.Reverse16(15),
			32: bits.Reverse32(15),
			64: bits.Reverse64(15),
		},
		f: condResRev,
	}, {
		name: "ReverseBytes",
		in:   15,
		results: map[uint]interface{}{
			16: bits.ReverseBytes16(15),
			32: bits.ReverseBytes32(15),
			64: bits.ReverseBytes64(15),
		},
		f: condResRev,
	}, {
		name: "Len",
		in:   8,
		results: map[uint]interface{}{
			8:  bits.Len8(8),
			16: bits.Len16(8),
			32: bits.Len32(8),
			64: bits.Len64(8),
		},
		f: condResReg,
	},
}

func condResReg(fname string, size uint, in interface{}, res interface{}) (cond, out string) {
	condF := "fmt.Printf(\"%s(%%0%db) = %%d\\n\", %d, bits.%s(%d))"
	outF := fmt.Sprintf("// %%s(%%0%db) = %%d", size)
	cond = fmt.Sprintf(condF, fname, size, in, fname, in)
	out = fmt.Sprintf(outF, fname, in, res)
	return cond, out
}

func condResRev(fname string, size uint, in interface{}, res interface{}) (cond, out string) {
	condF := "fmt.Printf(\"%%0%db\\n\", %d)\n\tfmt.Printf(\"%%0%db\\n\", bits.%s(%d))"
	outF := fmt.Sprintf("// %%0%db\n\t// %%0%db", size, size)
	cond = fmt.Sprintf(condF, size, in, size, fname, in)
	out = fmt.Sprintf(outF, in, res)
	return cond, out
}

func condResRot(fname string, size uint, in interface{}, res interface{}) (cond, out string) {
	args := in.([]int)
	condF := "fmt.Printf(\"%%0%db\\n\", %d)\n\tfmt.Printf(\"%%0%db\\n\", bits.%s(%d, %d))"
	outF := fmt.Sprintf("// %%0%db\n\t// %%0%db", size, size)
	cond = fmt.Sprintf(condF, size, args[0], size, fname, args[0], args[1])
	out = fmt.Sprintf(outF, args[0], res)
	return cond, out
}

func sortedSizes(out map[uint]interface{}) []uint {
	sizes := make([]uint, 0, len(out))
	for size := range out {
		sizes = append(sizes, size)
	}

	sort.Slice(sizes, func(i, j int) bool {
		return sizes[i] < sizes[j]
	})

	return sizes
}
