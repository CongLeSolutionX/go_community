// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// Generate duff_*.s.
package main

import (
	"fmt"
	"io"
	"log"
	"os"
)

func main() {
	gen("amd64", "6", notags, zeroAMD64, copyAMD64)
	gen("386", "8", notags, zero386, copy386)
	gen("arm", "5", notags, zeroARM, copyARM)
	gen("arm64", "7", notags, zeroARM64, copyARM64)
	gen("ppc64x", "9", tagsPPC64x, zeroPPC64x, copyPPC64x)
}

const zerodoc = `
// runtime·duffzero is a Duff's device for zeroing memory.
// The compiler jumps to computed addresses within
// this routine to zero chunks of memory.
// Do not change this code without also
// changing clearfat in cmd/%sg/ggen.go.
//
`

const copydoc = `
// runtime·duffcopy is a Duff's device for copying memory.
// The compiler jumps to computed addresses within
// this routine to copy chunks of memory.
// Source and destination must not overlap.
// Do not change this code without also
// changing stackcopy in cmd/%sg/cgen.go.
//
`

func gen(arch, char string, tags, zero, copy func(io.Writer)) {
	f, err := os.Create("duff_" + arch + ".s")
	if err != nil {
		log.Fatal(err)
	}

	fmt.Fprintln(f, "// AUTO-GENERATED by mkduff.go")
	tags(f)
	fmt.Fprintln(f, "#include \"textflag.h\"")
	fmt.Fprintf(f, zerodoc, char)
	zero(f)
	fmt.Fprintf(f, copydoc, char)
	copy(f)
}

func notags(w io.Writer) { fmt.Fprintln(w) }

func zeroAMD64(w io.Writer) {
	fmt.Fprintln(w, `// AX: zero
// DI: ptr to memory to be zeroed
// DI is updated as a side effect.
TEXT runtime·duffzero(SB), NOSPLIT, $0-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tSTOSQ")
	}
	fmt.Fprintln(w, "\tRET")
}

func copyAMD64(w io.Writer) {
	fmt.Fprintln(w, `// SI: ptr to source memory
// DI: ptr to destination memory
// SI and DI are updated as a side effect.
//
// This is equivalent to a sequence of MOVSQ but
// for some reason that is 3.5x slower than this code.
// The STOSQ in duffzero seem fine, though.
TEXT runtime·duffcopy(SB), NOSPLIT, $0-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tMOVQ\t(SI), CX")
		fmt.Fprintln(w, "\tADDQ\t$8, SI")
		fmt.Fprintln(w, "\tMOVQ\tCX, (DI)")
		fmt.Fprintln(w, "\tADDQ\t$8, DI")
		fmt.Fprintln(w)
	}
	fmt.Fprintln(w, "\tRET")
}

func zero386(w io.Writer) {
	fmt.Fprintln(w, `// AX: zero
// DI: ptr to memory to be zeroed
// DI is updated as a side effect.
TEXT runtime·duffzero(SB), NOSPLIT, $0-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tSTOSL")
	}
	fmt.Fprintln(w, "\tRET")
}

func copy386(w io.Writer) {
	fmt.Fprintln(w, `// SI: ptr to source memory
// DI: ptr to destination memory
// SI and DI are updated as a side effect.
//
// This is equivalent to a sequence of MOVSL but
// for some reason MOVSL is really slow.
TEXT runtime·duffcopy(SB), NOSPLIT, $0-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tMOVL\t(SI), CX")
		fmt.Fprintln(w, "\tADDL\t$4, SI")
		fmt.Fprintln(w, "\tMOVL\tCX, (DI)")
		fmt.Fprintln(w, "\tADDL\t$4, DI")
		fmt.Fprintln(w)
	}
	fmt.Fprintln(w, "\tRET")
}

func zeroARM(w io.Writer) {
	fmt.Fprintln(w, `// R0: zero
// R1: ptr to memory to be zeroed
// R1 is updated as a side effect.
TEXT runtime·duffzero(SB), NOSPLIT, $0-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tMOVW.P\tR0, 4(R1)")
	}
	fmt.Fprintln(w, "\tRET")
}

func copyARM(w io.Writer) {
	fmt.Fprintln(w, `// R0: scratch space
// R1: ptr to source memory
// R2: ptr to destination memory
// R1 and R2 are updated as a side effect
TEXT runtime·duffcopy(SB), NOSPLIT, $0-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tMOVW.P\t4(R1), R0")
		fmt.Fprintln(w, "\tMOVW.P\tR0, 4(R2)")
		fmt.Fprintln(w)
	}
	fmt.Fprintln(w, "\tRET")
}

func zeroARM64(w io.Writer) {
	fmt.Fprintln(w, `// ZR: always zero
// R16 (aka REGRT1): ptr to memory to be zeroed - 8
// On return, R16 points to the last zeroed dword.
TEXT runtime·duffzero(SB), NOSPLIT, $-8-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tMOVD.W\tZR, 8(R16)")
	}
	fmt.Fprintln(w, "\tRET")
}

func copyARM64(w io.Writer) {
	fmt.Fprintln(w, "// TODO: Implement runtime·duffcopy.")
}

func tagsPPC64x(w io.Writer) {
	fmt.Fprintln(w)
	fmt.Fprintln(w, "// +build ppc64 ppc64le")
	fmt.Fprintln(w)
}

func zeroPPC64x(w io.Writer) {
	fmt.Fprintln(w, `// R0: always zero
// R3 (aka REGRT1): ptr to memory to be zeroed - 8
// On return, R3 points to the last zeroed dword.
TEXT runtime·duffzero(SB), NOSPLIT, $-8-0`)
	for i := 0; i < 128; i++ {
		fmt.Fprintln(w, "\tMOVDU\tR0, 8(R3)")
	}
	fmt.Fprintln(w, "\tRETURN")
}

func copyPPC64x(w io.Writer) {
	fmt.Fprintln(w, "// TODO: Implement runtime·duffcopy.")
}
