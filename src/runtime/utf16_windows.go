// Code generated by golang.org/x/tools/cmd/bundle command:
//   $ bundle unicode/utf16 runtime utf16

// Package utf16 implements encoding and decoding of UTF-16 sequences.
//
package runtime

import ()

const (
	utf16replacementChar = '\uFFFD'     // Unicode replacement character
	utf16maxRune         = '\U0010FFFF' // Maximum valid Unicode code point.
)

const (
	// 0xd800-0xdc00 encodes the high 10 bits of a pair.
	// 0xdc00-0xe000 encodes the low 10 bits of a pair.
	// the value is those 20 bits plus 0x10000.
	utf16surr1 = 0xd800
	utf16surr2 = 0xdc00
	utf16surr3 = 0xe000

	utf16surrSelf = 0x10000
)

// IsSurrogate reports whether the specified Unicode code point
// can appear in a surrogate pair.
func utf16IsSurrogate(r rune) bool {
	return utf16surr1 <= r && r < utf16surr3
}

// DecodeRune returns the UTF-16 decoding of a surrogate pair.
// If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns
// the Unicode replacement code point U+FFFD.
func utf16DecodeRune(r1, r2 rune) rune {
	if utf16surr1 <= r1 && r1 < utf16surr2 && utf16surr2 <= r2 && r2 < utf16surr3 {
		return (r1-utf16surr1)<<10 | (r2 - utf16surr2) + 0x10000
	}
	return utf16replacementChar
}

// EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.
// If the rune is not a valid Unicode code point or does not need encoding,
// EncodeRune returns U+FFFD, U+FFFD.
func utf16EncodeRune(r rune) (r1, r2 rune) {
	if r < utf16surrSelf || r > utf16maxRune || utf16IsSurrogate(r) {
		return utf16replacementChar, utf16replacementChar
	}
	r -= utf16surrSelf
	return utf16surr1 + (r>>10)&0x3ff, utf16surr2 + r&0x3ff
}

// Encode returns the UTF-16 encoding of the Unicode code point sequence s.
func utf16Encode(s []rune) []uint16 {
	n := len(s)
	for _, v := range s {
		if v >= utf16surrSelf {
			n++
		}
	}

	a := make([]uint16, n)
	n = 0
	for _, v := range s {
		switch {
		case v < 0, utf16surr1 <= v && v < utf16surr3, v > utf16maxRune:
			v = utf16replacementChar
			fallthrough
		case v < utf16surrSelf:
			a[n] = uint16(v)
			n++
		default:
			r1, r2 := utf16EncodeRune(v)
			a[n] = uint16(r1)
			a[n+1] = uint16(r2)
			n += 2
		}
	}
	return a[0:n]
}

// Decode returns the Unicode code point sequence represented
// by the UTF-16 encoding s.
func utf16Decode(s []uint16) []rune {
	a := make([]rune, len(s))
	n := 0
	for i := 0; i < len(s); i++ {
		switch r := s[i]; {
		case utf16surr1 <= r && r < utf16surr2 && i+1 < len(s) &&
			utf16surr2 <= s[i+1] && s[i+1] < utf16surr3:

			a[n] = utf16DecodeRune(rune(r), rune(s[i+1]))
			i++
			n++
		case utf16surr1 <= r && r < utf16surr3:

			a[n] = utf16replacementChar
			n++
		default:

			a[n] = rune(r)
			n++
		}
	}
	return a[0:n]
}
