// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// mksys.go generates assembler code per lines that prefixed with "//sys"

package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"unicode"
	"unicode/utf8"
)

var (
	output = flag.String("output", "", "output file name (standard output if omitted)")
	goos   = flag.String("goos", runtime.GOOS, "target OS")
	goarch = flag.String("goarch", runtime.GOARCH, "target architecture")
)

var (
	outFile     = os.Stdout
	zsysnumFile *os.File
	ptrSize     int
)

func init() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "usage: mksys.go [flags] [path ...]\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	if len(*output) != 0 {
		f, err := os.OpenFile(*output, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			log.Fatal(err)
		}
		outFile = f
	}

	f, err := os.Open(filepath.Join(runtime.GOROOT(), "src/syscall", fmt.Sprintf("zsysnum_%s_%s.go", *goos, *goarch)))
	if err != nil {
		log.Fatal(err)
	}
	zsysnumFile = f

	switch *goarch {
	case "386":
		ptrSize = 4
	case "amd64":
		ptrSize = 8
	case "arm":
		ptrSize = 4
	case "arm64":
		ptrSize = 8
	case "mips":
		ptrSize = 4
	case "mipsle":
		ptrSize = 4
	case "mips64":
		ptrSize = 8
	case "mips64le":
		ptrSize = 8
	case "ppc64":
		ptrSize = 8
	case "ppc64le":
		ptrSize = 8
	case "s390":
		ptrSize = 4
	case "s390x":
		ptrSize = 8
	default:
		log.Fatal("unsupported goarch")
	}
}

func main() {
	args := flag.Args()

	if len(args) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	printHeader()
	printBuidTag()
	printIncludes()
	printDefines()

	c, err := newCompiler()
	if err != nil {
		log.Fatal(err)
	}

	for _, a := range args {
		f, err := os.Open(a)
		if err != nil {
			log.Fatal(err)
		}
		err = printAsm(c, f)
		if err != nil {
			log.Fatal(err)
		}
	}
}

func printHeader() {
	fmt.Fprintln(outFile, "// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT")
	fmt.Fprintln(outFile)
}

func printBuidTag() {
	fmt.Fprintf(outFile, "// +build %s\n", *goos)
	fmt.Fprintf(outFile, "// +build %s\n", *goarch)
	fmt.Fprintln(outFile)
}

func printIncludes() {
	fmt.Fprintln(outFile, `#include "go_asm.h"`)
	fmt.Fprintln(outFile, `#include "go_tls.h"`)
	fmt.Fprintln(outFile, `#include "textflag.h"`)
	fmt.Fprintln(outFile)
}

func printDefines() error {
	s := bufio.NewScanner(zsysnumFile)
	for s.Scan() {
		line := strings.TrimSpace(s.Text())
		if strings.HasPrefix(line, "SYS_") {
			fs := strings.Fields(line)
			if len(fs) != 3 || fs[1] != "=" {
				return errors.New("unexpected format for zsysnum file")
			}

			fmt.Fprintf(outFile, "#define %s\t%s\n", "SYS_"+strings.ToLower(fs[0][4:]), fs[2])
		}
	}
	fmt.Fprintln(outFile)
	return nil
}

func printAsm(c *Compiler, f *os.File) error {
	s := bufio.NewScanner(f)
	for s.Scan() {
		line := strings.TrimSpace(s.Text())
		if strings.HasPrefix(line, "//sys") {
			var mode string

			switch {
			case strings.HasPrefix(line, "//sysnoret"):
				mode = line[5:10]
				line = strings.TrimSpace(line[10:])
			case strings.HasPrefix(line, "//sysfatal"):
				mode = line[5:10]
				line = strings.TrimSpace(line[10:])
			default:
				line = strings.TrimSpace(line[5:])
			}

			fn, err := parseSysLine(line, mode)
			if err != nil {
				return err
			}

			argSize, insts, err := c.Compile(fn)
			if err != nil {
				return err
			}

			fmt.Fprintf(outFile, "TEXT runtimeÂ·%s(SB),NOSPLIT,$0-%d\n", fn.Name, argSize)
			for _, inst := range insts {
				fmt.Fprintln(outFile, "\t"+inst.String())
			}

			fmt.Fprintln(outFile)
		}
	}
	return nil
}

type Func struct {
	Name    string
	Params  []*Param
	Results []*Param
	Sysname string
	Mode    string // "noret", "fatal" or blank
}

type Param struct {
	Name string
	Type string
}

func (p *Param) Size() int {
	switch p.Type {
	case "int32", "uint32":
		return 4
	case "int64", "uint64":
		return 8
	case "uintptr":
		return ptrSize
	case "unsafe.Pointer":
		return ptrSize
	}

	if strings.HasPrefix(p.Type, "*") {
		return ptrSize
	}

	panic(fmt.Sprintf("unsupported type %s", p.Type))
}

func parseSysLine(line string, mode string) (*Func, error) {
	orig := line

	i := strings.IndexByte(line, '(')
	if i == -1 {
		return nil, fmt.Errorf("failed to parse %q: missing '(' before params", orig)
	}
	fn := line[:i]

	line = line[i+1:]

	var params []*Param
	j := strings.IndexByte(line, ')')
	if j == -1 {
		return nil, fmt.Errorf("failed to parse %q: missing ')' after params", orig)
	}
	if toks := strings.TrimSpace(line[:j]); toks != "" {
		for _, p := range strings.Split(toks, ",") {
			fs := strings.Fields(strings.TrimSpace(p))
			switch len(fs) {
			case 2:
				params = append(params, &Param{
					Name: fs[0],
					Type: fs[1],
				})
			default:
				return nil, fmt.Errorf("failed to parse %q: can't parse param %q", orig, fs)
			}
		}
	}

	line = strings.TrimSpace(line[j+1:])

	var results []*Param
	switch {
	case strings.HasPrefix(line, "("):
		line = line[1:]
		k := strings.IndexByte(line, ')')
		if k == -1 {
			return nil, fmt.Errorf("failed to parse %q: missing ')' after return params", orig)
		}
		if toks := strings.TrimSpace(line[:k]); toks != "" {
			for _, p := range strings.Split(toks, ",") {
				fs := strings.Fields(strings.TrimSpace(p))
				switch len(fs) {
				case 2:
					results = append(results, &Param{
						Name: fs[0],
						Type: fs[1],
					})
				default:
					return nil, fmt.Errorf("failed to parse %q: can't parse return param %q", orig, fs)
				}
			}
		}

		line = strings.TrimSpace(line[k+1:])
	case len(line) != 0 && !strings.HasPrefix(line, "="):
		var typ string
		if k := strings.IndexAny(line, " \t="); k != -1 {
			typ = line[:k]

			line = strings.TrimSpace(line[k+1:])
		} else {
			typ = line
		}
		results = append(results, &Param{
			Name: "ret",
			Type: typ,
		})
	}

	if len(results) > 1 {
		return nil, fmt.Errorf("failed to parse %q: results must be single", orig)
	}

	var sysname string

	if strings.HasPrefix(line, "=") {
		sysname = strings.TrimSpace(line[1:])
	} else {
		sysname = fmt.Sprintf("SYS_%s", toUnderscore(fn))
	}

	return &Func{
		Name:    fn,
		Params:  params,
		Results: results,
		Sysname: sysname,
		Mode:    mode,
	}, nil
}

type Compiler struct {
	Reg        func(num int) string
	SysReg     string
	RetReg     string
	Mov        func(size int) string
	Syscall    Instruction
	CheckError []Instruction
	Crash      []Instruction
}

func newCompiler() (*Compiler, error) {
	var c *Compiler

	switch *goos {
	case "linux":
		// http://man7.org/linux/man-pages/man2/syscall.2.html

		switch *goarch {
		case "386":
			c = &Compiler{
				Reg: func(num int) string {
					switch num {
					case 0: // BX
						return "BX"
					case 1: // CX
						return "CX"
					case 2: // DX
						return "DX"
					case 3: // SI
						return "SI"
					case 4: // DI
						return "DI"
					case 5: // BP
						return "BP"
					default:
						panic("register number out of range")
					}
				},
				SysReg: "AX",
				RetReg: "AX",
				Mov: func(size int) string {
					switch size {
					case 4:
						return "MOVL"
					default:
						panic("unsupported argument size")
					}
				},
				Syscall: Instruction{
					Op: "INT",
					Args: []string{
						"$0x80",
					},
				},
				CheckError: []Instruction{
					{
						Op: "CMPL",
						Args: []string{
							"AX",
							"$0xfffff001",
						},
					},
					{
						Op: "JLS",
						Args: []string{
							"2(PC)",
						},
					},
				},
				Crash: []Instruction{
					{
						Op: "INT",
						Args: []string{
							"$3",
						},
					},
				},
			}
		case "amd64":
			c = &Compiler{
				Reg: func(num int) string {
					switch num {
					case 0: // DI
						return "DI"
					case 1: // SI
						return "SI"
					case 2: // DX
						return "DX"
					case 3: // R10
						return "R10"
					case 4: // R9
						return "R8"
					case 5: // R9
						return "R9"
					default:
						panic("register number out of range")
					}
				},
				SysReg: "AX",
				RetReg: "AX",
				Mov: func(size int) string {
					switch size {
					case 4:
						return "MOVL"
					case 8:
						return "MOVQ"
					default:
						panic("unsupported argument size")
					}
				},
				Syscall: Instruction{
					Op: "SYSCALL",
				},
				CheckError: []Instruction{
					{
						Op: "CMPQ",
						Args: []string{
							"AX",
							"$0xfffffffffffff001",
						},
					},
					{
						Op: "JLS",
						Args: []string{
							"2(PC)",
						},
					},
				},
				Crash: []Instruction{
					{
						Op: "MOVL",
						Args: []string{
							"$0xf1",
							"0xf1",
						},
					},
				},
			}
		case "arm":
			c = &Compiler{
				Reg: func(num int) string {
					switch num {
					case 0: // R0
						return "R0"
					case 1: // R1
						return "R1"
					case 2: // R2
						return "R2"
					case 3: // R3
						return "R3"
					case 4: // R4
						return "R4"
					case 5: // R5
						return "R5"
					default:
						panic("register number out of range")
					}
				},
				SysReg: "R7",
				RetReg: "R0",
				Mov: func(size int) string {
					switch size {
					case 4:
						return "MOVW"
					default:
						panic("unsupported argument size")
					}
				},
				Syscall: Instruction{
					Op: "SWI",
					Args: []string{
						"$0",
					},
				},
				CheckError: []Instruction{
					{
						Op: "MOVW",
						Args: []string{
							"$0xfffff001",
							"R6",
						},
					},
					{
						Op: "CMP",
						Args: []string{
							"R6",
							"R0",
						},
					},
				},
				Crash: []Instruction{
					{
						Op: "MOVW.HI",
						Args: []string{
							"$0",
							"R8",
						},
					},
					{
						Op: "MOVW.HI",
						Args: []string{
							"R8",
							"(R8)",
						},
					},
				},
			}
		}
	}

	if c != nil {
		return c, nil
	}

	return nil, fmt.Errorf("unsupported Platform %s/%s", *goos, *goarch)
}

func (c *Compiler) Compile(fn *Func) (argSize int, insts []Instruction, err error) {
	insts = append(insts, Instruction{
		Op: c.Mov(ptrSize),
		Args: []string{
			"$" + fn.Sysname,
			c.SysReg,
		},
	})

	var argPos int
	var argNum int

	for _, p := range fn.Params {
		pSize := p.Size()

		if argPos%ptrSize != 0 && pSize%ptrSize == 0 {
			argPos = (argPos + ptrSize - 1) &^ (ptrSize - 1)
		}

		insts = append(insts, Instruction{
			Op: c.Mov(pSize),
			Args: []string{
				fmt.Sprintf("%s+%d(FP)", p.Name, argPos),
				c.Reg(argNum),
			},
		})

		argPos += pSize
		argNum++
	}

	insts = append(insts, c.Syscall)

	switch fn.Mode {
	case "noret":
		if len(fn.Results) != 0 {
			return 0, nil, errors.New("can't return values in no return mode")
		}

		insts = append(insts, c.Crash...)

		return argPos, insts, nil
	case "fatal":
		insts = append(insts, c.CheckError...)
		insts = append(insts, c.Crash...)
	}

	if len(fn.Results) > 0 {
		argPos = (argPos + ptrSize - 1) &^ (ptrSize - 1)

		r := fn.Results[0]

		rSize := r.Size()

		insts = append(insts, Instruction{
			Op: c.Mov(rSize),
			Args: []string{
				c.RetReg,
				fmt.Sprintf("%s+%d(FP)", r.Name, argPos),
			},
		})

		argPos += rSize
	}

	insts = append(insts, Instruction{
		Op: "RET",
	})

	return argPos, insts, nil
}

type Instruction struct {
	Op   string
	Args []string
}

func (inst Instruction) String() string {
	if len(inst.Args) == 0 {
		return inst.Op
	}
	return inst.Op + "\t" + strings.Join(inst.Args, ", ")
}

// toUnderscore convert camelcase into lowercase with underscore (e.g. OpenClose =>
// open_close)
func toUnderscore(s string) string {
	rs := make([]rune, 0, utf8.RuneCountInString(s)+3)
	var p rune
	for _, r := range s {
		if unicode.IsLower(p) && unicode.IsUpper(r) {
			rs = append(rs, '_')
		}
		rs = append(rs, unicode.ToLower(r))
		p = r
	}
	return string(rs)
}
