// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Time-related runtime and pieces of package time.

package runtime

import (
	_channels "runtime/internal/channels"
	_core "runtime/internal/core"
	_lock "runtime/internal/lock"
	_sched "runtime/internal/sched"
	"unsafe"
)

// Package time APIs.
// Godoc uses the comments in package time, not these.

// time.now is implemented in assembly.

// timeSleep puts the current goroutine to sleep for at least ns nanoseconds.
//go:linkname timeSleep time.Sleep
func timeSleep(ns int64) {
	if ns <= 0 {
		return
	}

	t := new(_sched.Timer)
	t.When = _lock.Nanotime() + ns
	t.F = goroutineReady
	t.Arg = _core.Getg()
	_lock.Lock(&_sched.Timers.Lock)
	_sched.AddtimerLocked(t)
	_sched.Goparkunlock(&_sched.Timers.Lock, "sleep", _sched.TraceEvGoSleep)
}

// startTimer adds t to the timer heap.
//go:linkname startTimer time.startTimer
func startTimer(t *_sched.Timer) {
	if _sched.Raceenabled {
		_channels.Racerelease(unsafe.Pointer(t))
	}
	_sched.Addtimer(t)
}

// stopTimer removes t from the timer heap if it is there.
// It returns true if t was removed, false if t wasn't even there.
//go:linkname stopTimer time.stopTimer
func stopTimer(t *_sched.Timer) bool {
	return deltimer(t)
}

// Go runtime.

// Ready the goroutine arg.
func goroutineReady(arg interface{}, seq uintptr) {
	_sched.Goready(arg.(*_core.G))
}

// Delete timer t from the heap.
// Do not need to update the timerproc: if it wakes up early, no big deal.
func deltimer(t *_sched.Timer) bool {
	// Dereference t so that any panic happens before the lock is held.
	// Discard result, because t might be moving in the heap.
	_ = t.I

	_lock.Lock(&_sched.Timers.Lock)
	// t may not be registered anymore and may have
	// a bogus i (typically 0, if generated by Go).
	// Verify it before proceeding.
	i := t.I
	last := len(_sched.Timers.T) - 1
	if i < 0 || i > last || _sched.Timers.T[i] != t {
		_lock.Unlock(&_sched.Timers.Lock)
		return false
	}
	if i != last {
		_sched.Timers.T[i] = _sched.Timers.T[last]
		_sched.Timers.T[i].I = i
	}
	_sched.Timers.T[last] = nil
	_sched.Timers.T = _sched.Timers.T[:last]
	if i != last {
		_sched.SiftupTimer(i)
		_sched.SiftdownTimer(i)
	}
	_lock.Unlock(&_sched.Timers.Lock)
	return true
}

// Entry points for net, time to call nanotime.

//go:linkname net_runtimeNano net.runtimeNano
func net_runtimeNano() int64 {
	return _lock.Nanotime()
}

//go:linkname time_runtimeNano time.runtimeNano
func time_runtimeNano() int64 {
	return _lock.Nanotime()
}
