// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Time-related runtime and pieces of package time.

package runtime

import (
	_base "runtime/internal/base"
	_iface "runtime/internal/iface"
	_race "runtime/internal/race"
	"unsafe"
)

// startTimer adds t to the timer heap.
//go:linkname startTimer time.startTimer
func startTimer(t *_base.Timer) {
	if _base.Raceenabled {
		_race.Racerelease(unsafe.Pointer(t))
	}
	addtimer(t)
}

// stopTimer removes t from the timer heap if it is there.
// It returns true if t was removed, false if t wasn't even there.
//go:linkname stopTimer time.stopTimer
func stopTimer(t *_base.Timer) bool {
	return deltimer(t)
}

func addtimer(t *_base.Timer) {
	_base.Lock(&_base.Timers.Lock)
	_iface.AddtimerLocked(t)
	_base.Unlock(&_base.Timers.Lock)
}

// Delete timer t from the heap.
// Do not need to update the timerproc: if it wakes up early, no big deal.
func deltimer(t *_base.Timer) bool {
	// Dereference t so that any panic happens before the lock is held.
	// Discard result, because t might be moving in the heap.
	_ = t.I

	_base.Lock(&_base.Timers.Lock)
	// t may not be registered anymore and may have
	// a bogus i (typically 0, if generated by Go).
	// Verify it before proceeding.
	i := t.I
	last := len(_base.Timers.T) - 1
	if i < 0 || i > last || _base.Timers.T[i] != t {
		_base.Unlock(&_base.Timers.Lock)
		return false
	}
	if i != last {
		_base.Timers.T[i] = _base.Timers.T[last]
		_base.Timers.T[i].I = i
	}
	_base.Timers.T[last] = nil
	_base.Timers.T = _base.Timers.T[:last]
	if i != last {
		_iface.SiftupTimer(i)
		_iface.SiftdownTimer(i)
	}
	_base.Unlock(&_base.Timers.Lock)
	return true
}

// Entry points for net, time to call nanotime.

//go:linkname net_runtimeNano net.runtimeNano
func net_runtimeNano() int64 {
	return _base.Nanotime()
}

//go:linkname time_runtimeNano time.runtimeNano
func time_runtimeNano() int64 {
	return _base.Nanotime()
}
