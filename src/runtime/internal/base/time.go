// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Time-related runtime and pieces of package time.

package base

import (
	"unsafe"
)

// Package time knows the layout of this structure.
// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.
// For GOOS=nacl, package syscall knows the layout of this structure.
// If this struct changes, adjust ../syscall/net_nacl.go:/runtimeTimer.
type Timer struct {
	i int // heap index

	// Timer wakes up at when, and then at when+period, ... (period > 0 only)
	// each time calling f(now, arg) in the timer goroutine, so f must be
	// a well-behaved function and not block.
	When   int64
	period int64
	F      func(interface{}, uintptr)
	Arg    interface{}
	Seq    uintptr
}

var Timers struct {
	Lock         Mutex
	Gp           *G
	created      bool
	sleeping     bool
	rescheduling bool
	waitnote     Note
	t            []*Timer
}

// nacl fake time support - time in nanoseconds since 1970
var faketime int64

func Addtimer(t *Timer) {
	Lock(&Timers.Lock)
	AddtimerLocked(t)
	Unlock(&Timers.Lock)
}

// Add a timer to the heap and start or kick the timer proc.
// If the new timer is earlier than any of the others.
// Timers are locked.
func AddtimerLocked(t *Timer) {
	// when must never be negative; otherwise timerproc will overflow
	// during its delta calculation and never expire other runtimeÂ·timers.
	if t.When < 0 {
		t.When = 1<<63 - 1
	}
	t.i = len(Timers.t)
	Timers.t = append(Timers.t, t)
	siftupTimer(t.i)
	if t.i == 0 {
		// siftup moved to top: new earliest deadline.
		if Timers.sleeping {
			Timers.sleeping = false
			Notewakeup(&Timers.waitnote)
		}
		if Timers.rescheduling {
			Timers.rescheduling = false
			Goready(Timers.Gp, 0)
		}
	}
	if !Timers.created {
		Timers.created = true
		go Timerproc()
	}
}

// Delete timer t from the heap.
// Do not need to update the timerproc: if it wakes up early, no big deal.
func Deltimer(t *Timer) bool {
	// Dereference t so that any panic happens before the lock is held.
	// Discard result, because t might be moving in the heap.
	_ = t.i

	Lock(&Timers.Lock)
	// t may not be registered anymore and may have
	// a bogus i (typically 0, if generated by Go).
	// Verify it before proceeding.
	i := t.i
	last := len(Timers.t) - 1
	if i < 0 || i > last || Timers.t[i] != t {
		Unlock(&Timers.Lock)
		return false
	}
	if i != last {
		Timers.t[i] = Timers.t[last]
		Timers.t[i].i = i
	}
	Timers.t[last] = nil
	Timers.t = Timers.t[:last]
	if i != last {
		siftupTimer(i)
		siftdownTimer(i)
	}
	Unlock(&Timers.Lock)
	return true
}

// Timerproc runs the time-driven events.
// It sleeps until the next event in the timers heap.
// If addtimer inserts a new earlier event, addtimer1 wakes timerproc early.
func Timerproc() {
	Timers.Gp = Getg()
	for {
		Lock(&Timers.Lock)
		Timers.sleeping = false
		now := Nanotime()
		delta := int64(-1)
		for {
			if len(Timers.t) == 0 {
				delta = -1
				break
			}
			t := Timers.t[0]
			delta = t.When - now
			if delta > 0 {
				break
			}
			if t.period > 0 {
				// leave in heap but adjust next time to fire
				t.When += t.period * (1 + -delta/t.period)
				siftdownTimer(0)
			} else {
				// remove from heap
				last := len(Timers.t) - 1
				if last > 0 {
					Timers.t[0] = Timers.t[last]
					Timers.t[0].i = 0
				}
				Timers.t[last] = nil
				Timers.t = Timers.t[:last]
				if last > 0 {
					siftdownTimer(0)
				}
				t.i = -1 // mark as removed
			}
			f := t.F
			arg := t.Arg
			seq := t.Seq
			Unlock(&Timers.Lock)
			if Raceenabled {
				Raceacquire(unsafe.Pointer(t))
			}
			f(arg, seq)
			Lock(&Timers.Lock)
		}
		if delta < 0 || faketime > 0 {
			// No timers left - put goroutine to sleep.
			Timers.rescheduling = true
			Goparkunlock(&Timers.Lock, "timer goroutine (idle)", TraceEvGoBlock, 1)
			continue
		}
		// At least one timer pending.  Sleep until then.
		Timers.sleeping = true
		Noteclear(&Timers.waitnote)
		Unlock(&Timers.Lock)
		Notetsleepg(&Timers.waitnote, delta)
	}
}

func timejump() *G {
	if faketime == 0 {
		return nil
	}

	Lock(&Timers.Lock)
	if !Timers.created || len(Timers.t) == 0 {
		Unlock(&Timers.Lock)
		return nil
	}

	var gp *G
	if faketime < Timers.t[0].When {
		faketime = Timers.t[0].When
		if Timers.rescheduling {
			Timers.rescheduling = false
			gp = Timers.Gp
		}
	}
	Unlock(&Timers.Lock)
	return gp
}

// Heap maintenance algorithms.

func siftupTimer(i int) {
	t := Timers.t
	when := t[i].When
	tmp := t[i]
	for i > 0 {
		p := (i - 1) / 4 // parent
		if when >= t[p].When {
			break
		}
		t[i] = t[p]
		t[i].i = i
		t[p] = tmp
		t[p].i = p
		i = p
	}
}

func siftdownTimer(i int) {
	t := Timers.t
	n := len(t)
	when := t[i].When
	tmp := t[i]
	for {
		c := i*4 + 1 // left child
		c3 := c + 2  // mid child
		if c >= n {
			break
		}
		w := t[c].When
		if c+1 < n && t[c+1].When < w {
			w = t[c+1].When
			c++
		}
		if c3 < n {
			w3 := t[c3].When
			if c3+1 < n && t[c3+1].When < w3 {
				w3 = t[c3+1].When
				c3++
			}
			if w3 < w {
				w = w3
				c = c3
			}
		}
		if w >= when {
			break
		}
		t[i] = t[c]
		t[i].i = i
		t[c] = tmp
		t[c].i = c
		i = c
	}
}
