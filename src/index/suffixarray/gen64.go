// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// Gen generates sais64.go from sais.go by replacing 32s with 64s.
package main

import (
	"bytes"
	"io/ioutil"
	"log"
	"strings"
)

func main() {
	log.SetPrefix("gen: ")
	log.SetFlags(0)

	data, err := ioutil.ReadFile("sais.go")
	if err != nil {
		log.Fatal(err)
	}

	funcX := bytes.Index(data, []byte("\nfunc"))
	varX := bytes.Index(data, []byte("\nvar"))
	constX := bytes.Index(data, []byte("\nvar"))
	typeX := bytes.Index(data, []byte("\nvar"))

	x := funcX
	if x < 0 {
		log.Fatal("cannot find func declaration")
	}
	if varX >= 0 && x > varX {
		x = varX
	}
	if constX >= 0 && x > constX {
		x = constX
	}
	if typeX >= 0 && x > typeX {
		x = typeX
	}

	hdr, data := data[:x], data[x:]
	hdr = bytes.Replace(hdr, []byte("\n\n"), []byte("\n\n// Code generated by gen64.go; DO NOT EDIT.\n//go:generate go run gen64.go\n\n"), 1)

	var buf bytes.Buffer
	buf.Write(hdr)

	for {
		x := bytes.Index(data, []byte("\nfunc "))
		if x < 0 {
			break
		}
		data = data[x:]
		p := bytes.IndexByte(data, '(')
		if p < 0 {
			p = len(data)
		}
		name := string(data[len("\nfunc "):p])

		x = bytes.Index(data, []byte("\n}\n"))
		if x < 0 {
			log.Fatalf("cannot find end of func %s", name)
		}
		fn := string(data[:x+len("\n}\n")])
		data = data[x+len("\n}"):]

		if !strings.HasSuffix(name, "_32") {
			continue
		}

		if strings.HasSuffix(name, "_32") {
			buf.WriteString(fix32.Replace(fn))
		}
		if strings.HasSuffix(name, "_8_32") {
			// x_8_32 -> x_8_64 done above
			fn = fix8_32.Replace(stripByteOnly(fn))
			buf.WriteString(fn)
			buf.WriteString(fix32.Replace(fn))
			continue
		}
	}

	if err := ioutil.WriteFile("sais64.go", buf.Bytes(), 0666); err != nil {
		log.Fatal(err)
	}
}

var fix32 = strings.NewReplacer(
	"32", "64",
	"int32", "int64",
)

var fix8_32 = strings.NewReplacer(
	"_8_32", "_32",
	"byte", "int32",
)

func stripByteOnly(s string) string {
	lines := strings.SplitAfter(s, "\n")
	w := 0
	for _, line := range lines {
		if !strings.Contains(line, "256") && !strings.Contains(line, "byte-only") {
			lines[w] = line
			w++
		}
	}
	return strings.Join(lines[:w], "")
}
