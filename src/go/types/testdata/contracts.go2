// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package p

// empty contracts
contract _(){}
contract _(A){}
contract _(A, B, C){}
contract _(A, B, A /* ERROR A redeclared */ ){}

// For now we also allow this form of contract declaration.
// TODO(gri) probably not a good idea. Disallow at local level for sure.
type _ contract(){}
type _ contract(A, B, A /* ERROR A redeclared */ ){}

// method constraints
// Methods may be declaration multiple times as long as they have matching signatures.
// TODO(gri) The "correct" way of doing this is perhaps to allow multiple declarations
// only they appear though embedding (where they are harder to avoid), but not in general.
contract _(A) { A } /* ERROR expected type */
contract _(A) { A m(); A add(A) int }
//contract _(A) { B /* ERROR B not declared by contract */ m() }
contract _(A) { A m(); A m() } // double declaration with same signature is ok
contract _(A) {
        A m()
//        A m /* ERROR already declared */ () int
}
contract _(A, B) {
        A m(x int) B
        B m(x int) A
        A m(x int) B // double declaration with same signature is ok
//       B m /* ERROR already declared */ (x int) B // double declaration with different signature is not ok
}

// type constraints
// Types may be declared multiple times.
// TODO(gri) The "correct" way of doing this is perhaps to allow multiple declarations
// only when they appear though embedding (where they are harder to avoid), but not in general.
contract _(A) { A A }
//contract _(A) { A B /* ERROR undeclared name: B */ }
contract _(A) { A int }
contract _(A) { A []int }
//contract _(A) { A []B /* ERROR undeclared name: B */ }
//contract C(A) { A [ /* ERROR invalid type constraint */ ]C }
contract _(A) { A struct { f int } }
contract _(A, B) { A B }

// embedded contracts
contract E() {}
contract _() {
        //E /* ERROR embedding not yet implemented */ ()
}
