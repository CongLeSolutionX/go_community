// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package p

// empty contracts
contract _(){}
contract _(A){}
contract _(A, B, C){}
contract _(A, B, A /* ERROR A redeclared */ ){}

// For now we also allow this form of contract declaration.
// TODO(gri) probably not a good idea. Disallow at local level for sure.
type _ contract(){}
type _ contract(A, B, A /* ERROR A redeclared */ ){}

// method constraints
contract _(A) { A } /* ERROR expected type */
contract _(A) { A m(); A add(A) int }
contract _(A) { B /* ERROR B not declared by contract */ m() }
contract _(A) { A m(); A m /* ERROR already declared */ () }
contract _(A) {
        A m()
        A m /* ERROR already declared */ () int
}
contract _(A, B) {
        A m(x int) B
        B m(x int) A
        A m /* ERROR already declared */ (x int) B
        B m /* ERROR already declared */ (x int) B
}

contract _(A) {
        A m1(), m2 /* ERROR cannot have more than one method */ ()
        A m3(), int /* ERROR cannot mix types and methods */
        A int, float32, m4(), string /* ERROR cannot mix types and methods */
}

// type constraints
// Types may be declared multiple times.
// TODO(gri) The "correct" way of doing this is perhaps to allow multiple declarations
// only when they appear though embedding (where they are harder to avoid), but not in general.
contract _(A) { A A }
contract _(A) { A B /* ERROR undeclared name: B */ }
contract _(A) { A int }
contract _(A) { A []int }
contract _(A) { A []B /* ERROR undeclared name: B */ }
contract C(A) { A [ /* ERROR invalid type constraint */ ]C }
contract _(A) { A struct { f int } }
contract _(A, B) { A B }

// embedded contracts
contract E() {}
contract _() {
//        E /* ERROR embedding not yet implemented */
}

// --------------------------------------------------------------------------------------
// Contract implementation

// Type parameter type must be a contract.
type _(type T int /* ERROR not a contract */ ) struct{}

// The number of type parameters must match the number of contract parameters.
contract C0() {}

type _(type A C0 /* ERROR 1 type parameters */ ) struct{}

contract C2(A, B) {
        A a()
}

type _(type A C2 /* ERROR 1 type parameters */ ) struct{}
type _(type A, B C2) struct{}
type _(type A, B, C C2 /* ERROR 3 type parameters */ ) struct{}

// Type instantiation must satisfy the contract.

type T1(type _, _ C2) struct{}

type A struct{}

func (A) a() {}

var _ T1 /* ERROR not satisfied */ (int, int)
var _ T1(A, int)

contract Stringer(T) {
        T String() string
}

type List(type T Stringer) struct{
        data T
        link *List(T)
}

var _ List(MyData)
var _ List /* ERROR not satisfied */ (int)

type MyData string

func (s MyData) String() string { return string(s) }
