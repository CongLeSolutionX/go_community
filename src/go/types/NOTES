TODO
- if type parameters are repeated in recursive instantiation, they must be the same order (not yet checked)
- implement contract embedding
- interface embedding doesn't take care of literal type constraints yet
  (need an allTypes list, like we have an allMethods list?)
- type assertions on/against parameterized types
- consolidate Signature.tparams and Signature.mtparams?
- can we always set Named.targs?
- use []*TypeParam for tparams in subst

OPEN ISSUES
- using a contract and enumerating type arguments currently leads to an error (e.g. func f(type T C(T)) (x T) ... )
- contracts slip through in places where only types are permitted

DESIGN/IMPLEMENTATION
- 12/4/2019: do not allow parenthesized generic uninstantiated types (unless instantiated implicitly)
  In other words: generic types must always be instantiated before they can be used in any form
  More generally: Only permit type instantiation T(x) in type context, when the type is a named type.
  Do not permit it in general in type context: e.g., disallow []T(x) because we consider that a
  conversion, in general. Same for ([]T)(x).

- 12/12/2019: represent type bounds always as (possibly unnamed) interfaces
  (contracts are user syntactic sugar)

- 12/19/2019: Type parameters don't act like type aliases. For instance:

        func f(type T1, T2)(x T1) T2 { return x }

  is not valid, no matter how T1 and T2 are instantiated (but if T1 and T2 were type aliases with
  both of them having type int, the return x would be valid). In fact, the type parameters act more
  like named types. With their underlying type being the interface by which they are bound.
