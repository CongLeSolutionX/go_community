This file works as a sort of notebook/implementation log. It replaces my notebook based approach
so we have a better track record. I only switched to this file recently, hence it is incomplete.

TODO
- use Underlying() to return a type parameter's bound? investigate!
- better error message when declaring a contract local to a function (parser gets out of sync)
- if type parameters are repeated in recursive instantiation, they must be the same order (not yet checked)
- implement contract embedding
- interface embedding doesn't take care of literal type constraints yet
  (need an allTypes list, like we have an allMethods list?)
- type assertions on/against parameterized types
- move Func.tparams to Signature (as we have done for TypeName.tparams to Named)
- distinguish more clearly between Signature.tparams and mtparams (the latter are solely for recv type params)
- use []*TypeParam for tparams in subst? (unclear)

OPEN ISSUES
- instantiating a parameterized function type w/o value or result parameters may have unexpected side-effects
  (we don't make a copy of the signature in some cases) - investigate
- using a contract and enumerating type arguments currently leads to an error (e.g. func f(type T C(T)) (x T) ... )

DESIGN/IMPLEMENTATION
- 12/4/2019: do not allow parenthesized generic uninstantiated types (unless instantiated implicitly)
  In other words: generic types must always be instantiated before they can be used in any form
  More generally: Only permit type instantiation T(x) in type context, when the type is a named type.
  Do not permit it in general in type context: e.g., disallow []T(x) because we consider that a
  conversion, in general. Same for ([]T)(x).

- 12/12/2019: represent type bounds always as (possibly unnamed) interfaces
  (contracts are user syntactic sugar)

- 12/19/2019: Type parameters don't act like type aliases. For instance:

        func f(type T1, T2)(x T1) T2 { return x }

  is not valid, no matter how T1 and T2 are instantiated (but if T1 and T2 were type aliases with
  both of them having type int, the return x would be valid). In fact, the type parameters act more
  like named types with the methods described by their type bound. But type parameters are never
  interfaces. To determine: Given a type parameter P, is P == underlying(P) (like for basic types),
  or is the the underlying type of P something else (like for defined types). Is there an observable
  difference?

- 12/19/2019: Rewrote contract handling: they are now treated as Objects (rather than Types) throughout.

- 12/20/2019: Decided to start moving type parameters to types (from TypeName to Named), need to do the
  same for Func. This make more sense as in general any type (conceptually even literal types) could
  have type parameters. It's a property of the type, not the type name. It also simplified the code.

- 12/20/2019: Type parameters may be part of type lists in contracts/interfaces. It just falls out
  naturally. Added test cases.
