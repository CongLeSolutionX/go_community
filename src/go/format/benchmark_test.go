// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package format_test

import (
	"bytes"
	"fmt"
	"go/format"
	"testing"
)

const header = `
package format_test

import (
	"bytes"
	"compress/gzip"
	"crypto/sha256"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)
`

var sink []byte

func genBindata() *bytes.Buffer {
	buf := new(bytes.Buffer)
	buf.WriteString(header)
	buf.WriteByte('\n')
	for i := 0; i < 100; i++ {
		fmt.Fprintf(buf, "var _testdataBenchnrgbaGradientPng%d = ", i)
		buf.WriteString(`[]byte("`)
		buf.Write(bytes.Repeat([]byte(`\x00`), 233500))
		buf.WriteString(`")`)
		buf.WriteByte('\n')
	}
	buf.WriteString(fo)
	buf.WriteString(gradientFns)
	buf.WriteString("// _bindata is a table, holding each asset generator, mapped to its name.\n")
	buf.WriteString("var _bindata = map[string]func() (*asset, error) {\n")
	for i := 0; i < 100; i++ {
		buf.WriteString(`	"testdata/benchmark/%d.jpg": _testdataBenchnrgbaGradient%d,`)
		buf.WriteByte('\n')
	}
	buf.WriteString("}\n")
	return buf
}

func BenchmarkFormatSourceBindata(b *testing.B) {
	// Construct a file that resembles the asset file generated by
	// github.com/kevinburke/go-bindata, a file that stresses the formatter.
	// A string approximating the size of a PNG image is reproduced one hundred
	// times, to resemble a web server with many images compiled into the
	// binary.
	//
	// The generated file is about 20MB and some parts were omitted for brevity
	// so it does not compile. If that is a requirement, consider using
	// github.com/kevinburke/go-bindata/testdata/assets/bindata.go directly as
	// the benchmark.
	buf := genBindata()

	var err error
	b.SetBytes(int64(buf.Len()))
	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		sink, err = format.Source(buf.Bytes())
		if err != nil {
			b.Fatal(err)
		}
	}
}

const fo = `
type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}
`

const gradientFns = `
func testdataBenchnrgbaGradientPngBytes() ([]byte, error) {
	return bindataRead(
		_testdataBenchnrgbaGradientPng,
		"testdata/benchNRGBA-gradient.png",
	)
}

func testdataBenchnrgbaGradientPng() (*asset, error) {
	bytes, err := testdataBenchnrgbaGradientPngBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "testdata/benchNRGBA-gradient.png", size: 58831, mode: os.FileMode(420), modTime: time.Unix(1532313040, 0)}
	a := &asset{bytes: bytes, info: info, digest: [32]uint8{0xc, 0xd1, 0xdd, 0x8c, 0x81, 0xf1, 0x34, 0xea, 0xb1, 0xa5, 0x20, 0xe6, 0xf6, 0x38, 0x10, 0x18, 0x4e, 0x0, 0x73, 0x3c, 0x2f, 0xfa, 0xd0, 0x98, 0xbc, 0xb2, 0x31, 0xe3, 0xe7, 0xb6, 0x15, 0x13}}
	return a, nil
}
`
