// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// mkapi generates the zapi.go file, containing information about when various
// functions and types were introduced to Go. We bake this into the doc package
// to avoid scanning GOPATH in the common case.

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
)

func mustOpen(name string) io.Reader {
	f, err := os.Open(name)
	if err != nil {
		log.Fatal(err)
	}
	return f
}

func api(base string) string {
	if os.Getenv("GOROOT") == "" {
		return filepath.Join("..", "..", "..", "api", base)
	}

	return filepath.Join(os.Getenv("GOROOT"), "api", base)
}

type apiInfo struct {
	pkg      string
	kind     string
	name     string
	receiver string
	since    string
}

var (
	//TODO(dhobsd): Handle consts and vars
	baseRe   = regexp.MustCompile(`^pkg (\S+).*?, (func|type|method) `)
	tnameRe  = regexp.MustCompile(`([A-Z]\w*) struct$`)
	fnameRe  = regexp.MustCompile(`([A-Z]\w*)`)
	methodRe = regexp.MustCompile(`\((\*?[A-Z]\w*)\) ([A-Z]\w*)\(`)
)

func (ai *apiInfo) handleFunc(line string) {
	if m := fnameRe.FindStringSubmatch(line); m != nil {
		ai.name = m[1]
	}
}

func (ai *apiInfo) handleType(line string) {
	if m := tnameRe.FindStringSubmatch(line); m != nil {
		ai.name = m[1]
	}
}

func (ai *apiInfo) handleMethod(line string) {
	if m := methodRe.FindStringSubmatch(line); m != nil {
		ai.receiver = m[1]
		ai.name = m[2]
	}
}

func main() {
	var buf bytes.Buffer
	outf := func(format string, args ...interface{}) {
		fmt.Fprintf(&buf, format, args...)
	}
	outf("// Code generated by mkapi.go. DO NOT EDIT.\n\n")
	outf("package doc\n")
	sinceMap := map[string]string{
		"go1.txt":   "Go 1.0",
		"go1.1.txt": "Go 1.1",
		"go1.2.txt": "Go 1.2",
		"go1.3.txt": "Go 1.3",
		"go1.4.txt": "Go 1.4",
		"go1.5.txt": "Go 1.5",
		"go1.6.txt": "Go 1.6",
		"go1.7.txt": "Go 1.7",
		"go1.8.txt": "Go 1.8",
		"go1.9.txt": "Go 1.9",
	}

	// package name -> method/func/type -> name -> apiInfo
	pkgInfo := make(map[string]map[string]map[string]apiInfo)

	for f, v := range sinceMap {
		r := mustOpen(api(f))

		sc := bufio.NewScanner(r)
		for sc.Scan() {
			l := sc.Text()

			if len(l) < 11 {
				continue
			}

			if l[0] == '#' {
				continue
			}

			// Use of package syscall implies enough assumptions about where the code will
			// run that it's not worth documenting when things arrived there.
			if l[4:11] == "syscall" {
				continue
			}

			var ai apiInfo
			var m []int

			if m = baseRe.FindStringSubmatchIndex(l); m != nil {
				ai.pkg = l[m[2]:m[3]]
				ai.kind = l[m[4]:m[5]]

				if _, e := pkgInfo[ai.pkg]; !e {
					pkgInfo[ai.pkg] = map[string]map[string]apiInfo{
						"funcs":   map[string]apiInfo{},
						"types":   map[string]apiInfo{},
						"methods": map[string]apiInfo{},
					}
				}
			} else {
				continue
			}

			ai.since = v

			switch ai.kind {
			case "func":
				ai.handleFunc(l[m[1]:])
				pkgInfo[ai.pkg]["funcs"][ai.name] = ai
			case "type":
				ai.handleType(l[m[1]:])
				// TODO(dhobsd): Handle struct field members
				if ai.name != "" {
					pkgInfo[ai.pkg]["types"][ai.name] = ai
				}
			case "method":
				ai.handleMethod(l[m[1]:])
				pkgInfo[ai.pkg]["methods"][ai.receiver+"."+ai.name] = ai
			}
		}

		if err := sc.Err(); err != nil {
			log.Fatal(err)
		}
	}

	outf("var sinceInfo = map[string]map[string]map[string]string{\n")
	for p, m := range pkgInfo {
		outf("\t\"%s\": map[string]map[string]string{\n", p)
		for _, k := range []string{"types", "funcs", "methods"} {
			outf("\t\t\"%s\": map[string]string{\n", k)
			for n, ai := range m[k] {
				outf("\t\t\t\"%s\": \"%s\",\n", n, ai.since)
			}
			outf("\t\t},\n")
		}
		outf("\t},\n")
	}
	outf("}\n")

	fmtbuf, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile("zapi.go", fmtbuf, 0666)
	if err != nil {
		log.Fatal(err)
	}
}
