// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This test tests some internals of the flate package.
// The tests in package compress/gzip serve as the
// end-to-end test of the decompressor.

package flate

import (
	"bytes"
	"io/ioutil"
	"strings"
	"testing"
)

func TestUncompressedSource(t *testing.T) {
	decoder := NewReader(bytes.NewReader([]byte{0x01, 0x01, 0x00, 0xfe, 0xff, 0x11}))
	output := make([]byte, 1)
	n, error := decoder.Read(output)
	if n != 1 || error != nil {
		t.Fatalf("decoder.Read() = %d, %v, want 1, nil", n, error)
	}
	if output[0] != 0x11 {
		t.Errorf("output[0] = %x, want 0x11", output[0])
	}
}

// The following test should not panic.
func TestIssue5915(t *testing.T) {
	bits := []int{4, 0, 0, 6, 4, 3, 2, 3, 3, 4, 4, 5, 0, 0, 0, 0, 5, 5, 6,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 6, 0, 11, 0, 8, 0, 6, 6, 10, 8}
	h := new(huffmanDecoder)
	ok := h.init(bits)
	if ok == true {
		t.Fatalf("Given sequence of bits is bad, and should not succeed.")
	}
}

// The following test should not panic.
func TestIssue5962(t *testing.T) {
	bits := []int{4, 0, 0, 6, 4, 3, 2, 3, 3, 4, 4, 5, 0, 0, 0, 0,
		5, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11}
	h := new(huffmanDecoder)
	ok := h.init(bits)
	if ok == true {
		t.Fatalf("Given sequence of bits is bad, and should not succeed.")
	}
}

// The following test should not panic.
func TestIssue6255(t *testing.T) {
	bits1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11}
	bits2 := []int{11, 13}
	h := new(huffmanDecoder)
	if !h.init(bits1) {
		t.Fatalf("Given sequence of bits is good and should succeed.")
	}
	if h.init(bits2) {
		t.Fatalf("Given sequence of bits is bad and should not succeed.")
	}
}

func TestInvalidEncoding(t *testing.T) {
	// Initialize Huffman decoder to recognize "0".
	var h huffmanDecoder
	if !h.init([]int{1}) {
		t.Fatal("Failed to initialize Huffman decoder")
	}

	// Initialize decompressor with invalid Huffman coding.
	var f decompressor
	f.r = bytes.NewReader([]byte{0xff})

	_, err := f.huffSym(&h)
	if err == nil {
		t.Fatal("Should have rejected invalid bit sequence")
	}
}

func TestInvalidBits(t *testing.T) {
	oversubscribed := []int{1, 2, 3, 4, 4, 5}
	incomplete := []int{1, 2, 4, 4}
	var h huffmanDecoder
	if h.init(oversubscribed) {
		t.Fatal("Should reject oversubscribed bit-length set")
	}
	if h.init(incomplete) {
		t.Fatal("Should reject incomplete bit-length set")
	}
}

func TestDegenerateHuffmanCoding(t *testing.T) {
	// This test case is notable because:
	//   1. It's decompressable by zlib.
	//   2. It was generated by Go 1.4's compress/flate package.
	//   3. It uses a degenerate dynamic Huffman coding block.
	//
	// The input is somewhat contrived though.  It's a sequence of
	// 258 bytes with no 3+ byte sequence occuring more than once,
	// except that the whole sequence is repeated twice.  This
	// results in package flate emitting a single match token,
	// which consequently means a single symbol in the distance
	// coding table.
	//
	// Additionally, it uses very few unique byte values so that
	// the overhead from storing the dynamic Huffman coding still
	// results in a smaller encoding than using the fixed Huffman
	// coding.
	const (
		originalHalf = "\x00\x00\x00\x01\x03\x05\x03\x04\x02\x01\x05\x00\x00\x02\x04\x05\x02\x02\x04\x03\x05\x01\x02\x05\x00\x05\x00\x01\x00\x00\x03\x04\x01\x03\x03\x00\x04\x02\x04\x00\x01\x01\x01\x03\x04\x00\x00\x04\x01\x05\x01\x00\x01\x04\x05\x04\x00\x02\x02\x05\x03\x02\x04\x01\x00\x02\x05\x04\x05\x01\x03\x02\x05\x01\x01\x05\x05\x04\x01\x01\x00\x05\x05\x03\x03\x01\x01\x02\x04\x04\x05\x03\x05\x05\x05\x00\x02\x03\x01\x02\x00\x03\x02\x00\x02\x00\x01\x05\x02\x03\x03\x03\x04\x03\x00\x03\x05\x02\x04\x02\x05\x02\x05\x05\x01\x04\x01\x04\x00\x03\x03\x05\x00\x03\x00\x01\x02\x03\x04\x04\x02\x03\x00\x02\x01\x00\x03\x01\x00\x04\x03\x01\x03\x00\x05\x01\x05\x03\x00\x00\x05\x03\x01\x04\x03\x02\x01\x02\x02\x01\x03\x01\x05\x04\x04\x00\x04\x05\x05\x02\x00\x04\x00\x05\x02\x01\x04\x04\x03\x03\x02\x02\x00\x05\x04\x02\x02\x02\x03\x05\x04\x03\x04\x05\x00\x04\x04\x04\x01\x02\x01\x01\x04\x02\x00\x00\x06\x02\x06\x02\x02\x06\x04\x06\x06\x05\x06\x02\x03\x06\x04\x01\x06\x03\x02\x06\x00\x06\x05\x05\x06\x05\x02\x06\x01\x06\x02\x04\x06\x02\x05\x06\x01\x03\x06\x05\x04\x06"
		compressed   = "\xec\xd0\x01\x01\x00\x30\x10\x41\x51\x3e\xae\x7f\xe4\x15\x59\x85\x27\xc9\x59\x8a\x27\xd1\x41\x33\x33\x4d\x96\x52\x27\x2a\x95\xed\x54\xaa\x67\xb9\xab\x60\xa1\x16\xeb\x1c\x66\x6f\xb5\xb5\x25\x36\xed\xb2\x4d\xc4\x28\x08\x79\x24\x69\x94\x51\xc6\xe6\xba\x4a\xa6\xc8\xa4\x25\xc2\x8a\xd5\x38\x9a\x17\x69\x71\x83\xc1\xf1\x5a\x75\x43\xd5\x70\x9b\x80\x56\x20\x6b\x3a\xb5\x35\x76\x91\x8e\x83\xeb\xdd\x8e\x5c\x7d\xe1\x74\xdb\x8d\xf3\xd1\x63\xe7\xdc\x7a\x5f\xe0\x05\x00\x00\xff\xff"
	)

	data, err := ioutil.ReadAll(NewReader(strings.NewReader(compressed)))
	if err != nil {
		t.Fatal(err)
	}
	if string(data) != originalHalf+originalHalf {
		t.Fatal("Decompressed data does not match original")
	}
}
