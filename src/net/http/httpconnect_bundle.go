// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o httpconnect_bundle.go -dst http -prefix httpConnect -underscore golang.org/x/net/internal/httpconnect

package http

import (
	"bufio"
	"context"
	"crypto/tls"
	"errors"
	"net"
	"net/url"
	"strings"
	"time"
)

var (
	httpConnectnoDeadline   = time.Time{}
	httpConnectaLongTimeAgo = time.Unix(1, 0)
)

func (d *httpConnectDialer) connect(ctx context.Context, c net.Conn, address string) (ctxErr error) {
	if deadline, ok := ctx.Deadline(); ok && !deadline.IsZero() {
		c.SetDeadline(deadline)
		defer c.SetDeadline(httpConnectnoDeadline)
	}
	if ctx != context.Background() {
		errCh := make(chan error, 1)
		done := make(chan struct{})
		defer func() {
			close(done)
			if ctxErr == nil {
				ctxErr = <-errCh
			}
		}()
		go func() {
			select {
			case <-ctx.Done():
				c.SetDeadline(httpConnectaLongTimeAgo)
				errCh <- ctx.Err()
			case <-done:
				errCh <- nil
			}
		}()
	}

	// Send CONNECT request.
	hdr := d.Transport.ProxyConnectHeader
	if hdr == nil {
		hdr = make(Header)
	}
	connectReq := &Request{
		Method: "CONNECT",
		URL:    &url.URL{Opaque: address},
		Host:   address,
		Header: hdr,
	}
	connectReq.Write(c)

	// Read response.
	// Okay to use and discard buffered reader here, because
	// TLS server will not speak until spoken to.
	br := bufio.NewReader(c)
	resp, err := ReadResponse(br, connectReq)
	if err != nil {
		c.Close()
		return err
	}
	if resp.StatusCode != 200 {
		f := strings.SplitN(resp.Status, " ", 2)
		c.Close()
		if len(f) < 2 {
			return errors.New("unknown status code")
		}
		return errors.New(f[1])
	}
	return nil
}

// A Dialer holds HTTPCONNECT-specific options.
type httpConnectDialer struct {
	proxyNetwork string // network between a proxy server and a client
	proxyAddress string // proxy server address
	useTls       bool   // whether to use encryption between client and proxy

	// ProxyDial specifies the optional dial function for establishing the
	// client to proxy connection.
	ProxyDial func(context.Context, string, string) (net.Conn, error)

	// Transport to use for communication between the client and proxy if the
	// ProxyDial field is not specified.
	Transport *Transport
}

// DialContext connects to the provided address on the provided network.
//
// See func Dial of the net package of standard library for a
// description of the network and address parameters.
// For TCP and UDP networks, the address has the form "host:port"
func (d *httpConnectDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {
	switch network {
	case "tcp", "tcp6", "tcp4":
	default:
		return nil, errors.New("network not implemented")
	}
	if ctx == nil {
		ctx = context.Background()
	}
	var err error
	var c net.Conn
	// Set up connection to proxy
	// Copied from transport.dialConn
	if d.ProxyDial != nil {
		c, err = d.ProxyDial(ctx, d.proxyNetwork, d.proxyAddress)
	} else if d.useTls && d.Transport.DialTLS != nil {
		c, err = d.Transport.DialTLS(d.proxyNetwork, d.proxyAddress)
		if err != nil {
			return nil, err
		}
		if c == nil {
			return nil, errors.New("Transport.DialTLS returned (nil, nil)")
		}
		if tc, ok := c.(*tls.Conn); ok {
			// Handshake here, in case DialTLS didn't.
			if err := tc.Handshake(); err != nil {
				go c.Close()
				return nil, err
			}
		}
	} else {
		// Copied from transport.dial
		if d.Transport.DialContext != nil {
			if c, err = d.Transport.DialContext(ctx, d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		} else if d.Transport.Dial != nil {
			if c, err = d.Transport.Dial(d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		} else {
			if c, err = net.Dial(d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		}
		if d.useTls {
			// copied from persistConn.addTLS
			var proxyHost string
			if proxyHost, _, err = net.SplitHostPort(d.proxyAddress); err != nil {
				return nil, err
			}
			cfg := &tls.Config{}
			if d.Transport.TLSClientConfig != nil {
				cfg = d.Transport.TLSClientConfig.Clone()
			}
			if cfg.ServerName == "" {
				cfg.ServerName = proxyHost
			}
			tlsConn := tls.Client(c, cfg)
			errc := make(chan error, 2)
			var timer *time.Timer // for canceling TLS handshake
			if timeout := d.Transport.TLSHandshakeTimeout; timeout != 0 {
				timer = time.AfterFunc(timeout, func() {
					errc <- errors.New("TLS handshake timeout")
				})
			}
			go func() {
				err := tlsConn.Handshake()
				if timer != nil {
					timer.Stop()
				}
				errc <- err
			}()
			if err := <-errc; err != nil {
				c.Close()
				return nil, err
			}
			if !cfg.InsecureSkipVerify {
				if err := tlsConn.VerifyHostname(cfg.ServerName); err != nil {
					c.Close()
					return nil, err
				}
			}
			c = tlsConn
		}
	}
	// extend the connection to the destination address by sending the connect request
	err = d.connect(ctx, c, address)
	if err != nil {
		c.Close()
		return nil, err
	}
	return c, nil
}

// Dial connects to the provided address on the provided network.
//
// Deprecated: Use DialContext instead.
func (d *httpConnectDialer) Dial(network, address string) (net.Conn, error) {
	return d.DialContext(context.Background(), network, address)
}

// NewDialer returns a new Dialer that dials through the provided proxy server's
// network and address. Communication between the client and proxy server
// adheres to the provided useTls and transport fields.
func httpConnectNewDialer(network, address string, useTls bool, transport *Transport) *httpConnectDialer {
	return &httpConnectDialer{proxyNetwork: network, proxyAddress: address, useTls: useTls, Transport: transport}
}
