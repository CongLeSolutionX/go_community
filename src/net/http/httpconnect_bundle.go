// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o httpconnect_bundle.go -dst http -prefix httpConnect -underscore golang.org/x/net/internal/httpconnect

// Package httpconnect provides an implementation of a Dialer that connects
// to the destination address via a HTTP(S) proxy.
//

package http

import (
	"bufio"
	"context"
	"crypto/tls"
	"encoding/base64"
	"errors"
	"net"
	"net/url"
	"strings"
	"time"
)

var (
	httpConnectnoDeadline   = time.Time{}
	httpConnectaLongTimeAgo = time.Unix(1, 0)
)

func (d *httpConnectDialer) connect(ctx context.Context, c net.Conn, address string) (ctxErr error) {
	if deadline, ok := ctx.Deadline(); ok && !deadline.IsZero() {
		c.SetDeadline(deadline)
		defer c.SetDeadline(httpConnectnoDeadline)
	}
	if ctx != context.Background() {
		errCh := make(chan error, 1)
		done := make(chan struct{})
		defer func() {
			close(done)
			if ctxErr == nil {
				ctxErr = <-errCh
			}
		}()
		go func() {
			select {
			case <-ctx.Done():
				c.SetDeadline(httpConnectaLongTimeAgo)
				errCh <- ctx.Err()
			case <-done:
				errCh <- nil
			}
		}()
	}

	// Send CONNECT request.
	hdr := d.Transport.ProxyConnectHeader
	if hdr == nil {
		hdr = make(Header)
	}
	connectReq := &Request{
		Method: "CONNECT",
		URL:    &url.URL{Opaque: address},
		Host:   address,
		Header: hdr,
	}
	connectReq.Write(c)

	// Read response.
	// Okay to use and discard buffered reader here, because
	// TLS server will not speak until spoken to.
	br := bufio.NewReader(c)
	resp, err := ReadResponse(br, connectReq)
	if err != nil {
		c.Close()
		return err
	}
	if resp.StatusCode != 200 {
		f := strings.SplitN(resp.Status, " ", 2)
		c.Close()
		if len(f) < 2 {
			return errors.New("unknown status code")
		}
		return errors.New(f[1])
	}
	return nil
}

// A Dialer holds HTTP CONNECT-specific options.
type httpConnectDialer struct {
	proxyNetwork string // network between a proxy server and a client
	proxyAddress string // proxy server address
	useTLS       bool   // whether to use encryption between client and proxy

	// ProxyDial specifies the optional dial function for establishing the
	// client to proxy connection.
	ProxyDial func(ctx context.Context, network string, address string) (net.Conn, error)

	// Transport to use for communication between the client and proxy if the
	// ProxyDial field is not specified.
	Transport *Transport
}

// DialContext connects to the provided address on the provided network.
//
// See func Dial of the net package of standard library for a
// description of the network and address parameters.
// For TCP and UDP networks, the address has the form "host:port"
func (d *httpConnectDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {
	switch network {
	case "tcp", "tcp6", "tcp4":
	default:
		return nil, errors.New("network not implemented")
	}
	if ctx == nil {
		ctx = context.Background()
	}
	var err error
	var c net.Conn

	// Set up connection to proxy
	// Copied from transport.dialConn
	if d.ProxyDial != nil {
		c, err = d.ProxyDial(ctx, d.proxyNetwork, d.proxyAddress)
	} else if d.useTLS && d.Transport.DialTLS != nil {
		c, err = d.Transport.DialTLS(d.proxyNetwork, d.proxyAddress)
		if err != nil {
			return nil, err
		}
		if c == nil {
			return nil, errors.New("Transport.DialTLS returned (nil, nil)")
		}
		if tc, ok := c.(*tls.Conn); ok {
			// Handshake here, in case DialTLS didn't.
			if err := tc.Handshake(); err != nil {
				go c.Close()
				return nil, err
			}
		}
	} else {
		// Copied from transport.dial
		if d.Transport.DialContext != nil {
			if c, err = d.Transport.DialContext(ctx, d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		} else if d.Transport.Dial != nil {
			if c, err = d.Transport.Dial(d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		} else {
			if c, err = net.Dial(d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		}
		if d.useTLS {
			// copied from persistConn.addTLS
			var proxyHost string
			if proxyHost, _, err = net.SplitHostPort(d.proxyAddress); err != nil {
				return nil, err
			}
			cfg := &tls.Config{}
			if d.Transport.TLSClientConfig != nil {
				cfg = d.Transport.TLSClientConfig.Clone()
			}
			if cfg.ServerName == "" {
				cfg.ServerName = proxyHost
			}
			tlsConn := tls.Client(c, cfg)
			errc := make(chan error, 2)
			var timer *time.Timer // for canceling TLS handshake
			if timeout := d.Transport.TLSHandshakeTimeout; timeout != 0 {
				timer = time.AfterFunc(timeout, func() {
					errc <- errors.New("TLS handshake timeout")
				})
			}
			go func() {
				err := tlsConn.Handshake()
				if timer != nil {
					timer.Stop()
				}
				errc <- err
			}()
			if err := <-errc; err != nil {
				c.Close()
				return nil, err
			}
			if !cfg.InsecureSkipVerify {
				if err := tlsConn.VerifyHostname(cfg.ServerName); err != nil {
					c.Close()
					return nil, err
				}
			}
			c = tlsConn
		}
	}

	// use HTTP1.1 to send the connect request
	err = d.connect(ctx, c, address)
	if err != nil {
		c.Close()
		return nil, err
	}
	return c, nil
}

// Dial connects to the provided address on the provided network.
//
// Deprecated: Use DialContext instead.
func (d *httpConnectDialer) Dial(network, address string) (net.Conn, error) {
	return d.DialContext(context.Background(), network, address)
}

// NewDialer returns a new Dialer that dials through the proxy server's
// provided url. Communication between the client and proxy server adheres
// to the provided url and transport fields.
func httpConnectNewDialer(network string, url *url.URL, transport *Transport) *httpConnectDialer {
	if url.Scheme != "http" && url.Scheme != "https" {
		return nil
	}
	useTLS := url.Scheme == "https"
	port := url.Port()
	if port == "" {
		if url.Scheme == "http" {
			port = "80"
		} else {
			port = "443"
		}
	}

	// Make sure the proxy field in Transport will return the desired proxy url
	transport.Proxy = ProxyURL(url)

	// Copy the credentials for the proxy to the Transport
	if url.User != nil {
		if transport.ProxyConnectHeader == nil {
			transport.ProxyConnectHeader = make(Header)
		}
		password, _ := url.User.Password()
		encodedAuth := base64.StdEncoding.EncodeToString([]byte(url.User.Username() + ":" + password))
		transport.ProxyConnectHeader.Set("Proxy-Authorization", "Basic "+encodedAuth)
	}
	return &httpConnectDialer{proxyNetwork: network, proxyAddress: net.JoinHostPort(url.Hostname(), port),
		useTLS: useTLS, Transport: transport}
}
