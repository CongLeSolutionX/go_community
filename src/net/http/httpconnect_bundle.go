// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o httpconnect_bundle.go -dst http -prefix httpConnect -underscore golang.org/x/net/internal/httpconnect

// Package httpconnect provides an implementation of a Dialer that connects
// to the destination address via a HTTP(S) proxy.
//

package http

import (
	"bufio"
	"context"
	"crypto/tls"
	"encoding/base64"
	"errors"
	"io"
	"net"
	"net/http/httptrace"
	"net/url"
	"strings"
	"sync"
	"time"
)

var (
	httpConnectnoDeadline   = time.Time{}
	httpConnectaLongTimeAgo = time.Unix(1, 0)
)

func (d *httpConnectDialer) connectHttp2(ctx context.Context, rt RoundTripper, address string) (conn *httpConnecthttp2Conn, err error) {
	conn = httpConnectnewHttp2Conn()
	hdr := d.Transport.ProxyConnectHeader
	if hdr == nil {
		hdr = make(Header)
	}
	pr, pw := net.Pipe()
	connectReq := &Request{
		Method: "CONNECT",
		URL:    &url.URL{Scheme: "https", Host: address},
		Header: hdr,
		Body:   pr,
	}
	trace := &httptrace.ClientTrace{
		GotConn: conn.addrTrackingGotConn(),
	}
	connectReq = connectReq.WithContext(httptrace.WithClientTrace(ctx, trace))
	resp, err := rt.RoundTrip(connectReq)
	if err != nil {
		return
	}
	if resp.StatusCode != 200 {
		f := strings.SplitN(resp.Status, " ", 2)
		if len(f) < 2 {
			err = errors.New("unknown status code")
			return
		}
		err = errors.New(f[1])
		return
	}
	conn.w = pw
	conn.r = resp.Body
	return
}

func (d *httpConnectDialer) connect(ctx context.Context, c net.Conn, address string) (ctxErr error) {
	if deadline, ok := ctx.Deadline(); ok && !deadline.IsZero() {
		c.SetDeadline(deadline)
		defer c.SetDeadline(httpConnectnoDeadline)
	}
	if ctx != context.Background() {
		errCh := make(chan error, 1)
		done := make(chan struct{})
		defer func() {
			close(done)
			if ctxErr == nil {
				ctxErr = <-errCh
			}
		}()
		go func() {
			select {
			case <-ctx.Done():
				c.SetDeadline(httpConnectaLongTimeAgo)
				errCh <- ctx.Err()
			case <-done:
				errCh <- nil
			}
		}()
	}

	// Send CONNECT request.
	hdr := d.Transport.ProxyConnectHeader
	if hdr == nil {
		hdr = make(Header)
	}
	connectReq := &Request{
		Method: "CONNECT",
		URL:    &url.URL{Opaque: address},
		Host:   address,
		Header: hdr,
	}
	connectReq.Write(c)

	// Read response.
	// Okay to use and discard buffered reader here, because
	// TLS server will not speak until spoken to.
	br := bufio.NewReader(c)
	resp, err := ReadResponse(br, connectReq)
	if err != nil {
		c.Close()
		return err
	}
	if resp.StatusCode != 200 {
		f := strings.SplitN(resp.Status, " ", 2)
		c.Close()
		if len(f) < 2 {
			return errors.New("unknown status code")
		}
		return errors.New(f[1])
	}
	return nil
}

// deadline struct is copied from net/pipe.go
type httpConnectdeadline struct {
	mu     sync.Mutex // Guards timer and cancel
	timer  *time.Timer
	cancel chan struct{} // Must be non-nil
}

func (d *httpConnectdeadline) set(t time.Time) {
	d.mu.Lock()
	defer d.mu.Unlock()

	if d.timer != nil && !d.timer.Stop() {
		<-d.cancel // Wait for the timer callback to finish and close cancel
	}
	d.timer = nil

	// Time is zero, then there is no deadline.
	closed := httpConnectisClosedChan(d.cancel)
	if t.IsZero() {
		if closed {
			d.cancel = make(chan struct{})
		}
		return
	}

	// Time in the future, setup a timer to cancel in the future.
	if dur := time.Until(t); dur > 0 {
		if closed {
			d.cancel = make(chan struct{})
		}
		d.timer = time.AfterFunc(dur, func() {
			close(d.cancel)
		})
		return
	}

	// Time in the past, so close immediately.
	if !closed {
		close(d.cancel)
	}
}

func (d *httpConnectdeadline) wait() chan struct{} {
	d.mu.Lock()
	defer d.mu.Unlock()
	return d.cancel
}

func httpConnectisClosedChan(c <-chan struct{}) bool {
	select {
	case <-c:
		return true
	default:
		return false
	}
}

type httpConnectioResult struct {
	b   []byte
	n   int
	err error
}

type httpConnectconnError struct {
	errStr  string
	timeout bool
}

func (ce httpConnectconnError) Error() string { return ce.errStr }

func (ce httpConnectconnError) Timeout() bool { return ce.timeout }

func (ce httpConnectconnError) Temporary() bool { return ce.timeout }

var (
	httpConnecterrDeadline = httpConnectconnError{"deadline exceeded", true}
	httpConnecterrClosed   = httpConnectconnError{"closed connection", false}
)

func httpConnectnewHttp2Conn() *httpConnecthttp2Conn {
	return &httpConnecthttp2Conn{
		done:         make(chan struct{}),
		readDeadline: httpConnectdeadline{cancel: make(chan struct{})},
	}
}

type httpConnecthttp2Conn struct {
	w              net.Conn
	r              io.Reader
	localAddr      net.Addr
	remoteAddr     net.Addr
	readDeadline   httpConnectdeadline
	readMu         sync.Mutex
	once           sync.Once // protects closing done
	done           chan struct{}
	storedRead     *httpConnectioResult
	readInProgress bool
}

func (c *httpConnecthttp2Conn) Write(b []byte) (n int, err error) {
	n, err = c.w.Write(b)
	return
}

// This logic is adapted from net/pipe.go
func (c *httpConnecthttp2Conn) Read(b []byte) (n int, err error) {
	switch {
	case httpConnectisClosedChan(c.done):
		return 0, httpConnecterrClosed
	case httpConnectisClosedChan(c.readDeadline.wait()):
		return 0, httpConnecterrDeadline
	}

	// Ensure there aren't multiple reads depending on a previous read that
	// hasn't yet returned
	c.readMu.Lock()
	defer c.readMu.Unlock()
	ioCh := make(chan *httpConnectioResult)
	go func(ch chan *httpConnectioResult) {
		if c.readInProgress {
			for {
				if c.storedRead != nil {
					ch <- c.storedRead
					return
				}
			}
		} else {
			c.readInProgress = true
			n, err := c.r.Read(b)
			if n == 0 {
				err = io.EOF
			}
			c.storedRead = &httpConnectioResult{b[:n], n, err}
			ch <- c.storedRead
		}
	}(ioCh)

	select {
	case <-c.done:
		return 0, httpConnecterrClosed
	case <-c.readDeadline.wait():
		return 0, httpConnecterrDeadline
	case read := <-ioCh:
		// clear the stored read
		c.storedRead = nil
		c.readInProgress = false
		copy(b[:read.n], read.b[:read.n])
		return read.n, read.err
	}
}

func (c *httpConnecthttp2Conn) Close() error {
	c.w.Close()                         // close writer
	c.once.Do(func() { close(c.done) }) // close reader
	return nil
}

func (c *httpConnecthttp2Conn) LocalAddr() net.Addr {
	return c.localAddr
}

func (c *httpConnecthttp2Conn) RemoteAddr() net.Addr {
	return c.remoteAddr
}

func (c *httpConnecthttp2Conn) SetDeadline(t time.Time) error {
	c.readDeadline.set(t)   // set read deadline
	c.w.SetWriteDeadline(t) // set write deadline
	return nil
}

func (c *httpConnecthttp2Conn) SetReadDeadline(t time.Time) error {
	c.readDeadline.set(t)
	return nil
}

func (c *httpConnecthttp2Conn) SetWriteDeadline(t time.Time) error {
	c.w.SetWriteDeadline(t)
	return nil
}

func (c *httpConnecthttp2Conn) addrTrackingGotConn() func(connInfo httptrace.GotConnInfo) {
	return func(connInfo httptrace.GotConnInfo) {
		c.localAddr = connInfo.Conn.LocalAddr()
		c.remoteAddr = connInfo.Conn.RemoteAddr()
	}
}

// A Dialer holds HTTP CONNECT-specific options.
type httpConnectDialer struct {
	proxyNetwork string // network between a proxy server and a client
	proxyAddress string // proxy server address
	useTLS       bool   // whether to use encryption between client and proxy

	// ProxyDial specifies the optional dial function for establishing the
	// client to proxy connection.
	ProxyDial func(context.Context, string, string) (net.Conn, error)

	// Transport to use for communication between the client and proxy if the
	// ProxyDial field is not specified.
	Transport *Transport
}

// DialContext connects to the provided address on the provided network.
//
// See func Dial of the net package of standard library for a
// description of the network and address parameters.
// For TCP and UDP networks, the address has the form "host:port"
func (d *httpConnectDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {
	switch network {
	case "tcp", "tcp6", "tcp4":
	default:
		return nil, errors.New("network not implemented")
	}
	if ctx == nil {
		ctx = context.Background()
	}
	var err error
	var c net.Conn

	altProto, _ := d.Transport.AltProto.Load().(map[string]RoundTripper)
	if d.useTLS {
		if altRT := altProto["https"]; altRT != nil {
			// If a connection already exists, then the connect request should succeed over HTTP2
			if c, err = d.connectHttp2(ctx, altRT, address); err != ErrSkipAltProtocol {
				return c, err
			}
		}
	}

	// Set up connection to proxy
	// Copied from transport.dialConn
	if d.ProxyDial != nil {
		c, err = d.ProxyDial(ctx, d.proxyNetwork, d.proxyAddress)
	} else if d.useTLS && d.Transport.DialTLS != nil {
		c, err = d.Transport.DialTLS(d.proxyNetwork, d.proxyAddress)
		if err != nil {
			return nil, err
		}
		if c == nil {
			return nil, errors.New("Transport.DialTLS returned (nil, nil)")
		}
		if tc, ok := c.(*tls.Conn); ok {
			// Handshake here, in case DialTLS didn't.
			if err := tc.Handshake(); err != nil {
				go c.Close()
				return nil, err
			}
		}
	} else {
		// Copied from transport.dial
		if d.Transport.DialContext != nil {
			if c, err = d.Transport.DialContext(ctx, d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		} else if d.Transport.Dial != nil {
			if c, err = d.Transport.Dial(d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		} else {
			if c, err = net.Dial(d.proxyNetwork, d.proxyAddress); err != nil {
				return nil, err
			}
		}
		if d.useTLS {
			// copied from persistConn.addTLS
			var proxyHost string
			if proxyHost, _, err = net.SplitHostPort(d.proxyAddress); err != nil {
				return nil, err
			}
			cfg := &tls.Config{}
			if d.Transport.TLSClientConfig != nil {
				cfg = d.Transport.TLSClientConfig.Clone()
			}
			if cfg.ServerName == "" {
				cfg.ServerName = proxyHost
			}
			tlsConn := tls.Client(c, cfg)
			errc := make(chan error, 2)
			var timer *time.Timer // for canceling TLS handshake
			if timeout := d.Transport.TLSHandshakeTimeout; timeout != 0 {
				timer = time.AfterFunc(timeout, func() {
					errc <- errors.New("TLS handshake timeout")
				})
			}
			go func() {
				err := tlsConn.Handshake()
				if timer != nil {
					timer.Stop()
				}
				errc <- err
			}()
			if err := <-errc; err != nil {
				c.Close()
				return nil, err
			}
			if !cfg.InsecureSkipVerify {
				if err := tlsConn.VerifyHostname(cfg.ServerName); err != nil {
					c.Close()
					return nil, err
				}
			}
			c = tlsConn
			s := c.(*tls.Conn).ConnectionState()
			if s.NegotiatedProtocolIsMutual && s.NegotiatedProtocol != "" {
				if next, ok := d.Transport.TLSNextProto[s.NegotiatedProtocol]; ok {
					rt := next(d.proxyAddress, c.(*tls.Conn))
					// At this point the HTTP2 transport should have c as an available connection
					return d.connectHttp2(ctx, rt, address)
				}
			}
		}
	}

	// use HTTP1.1 to send the connect request
	err = d.connect(ctx, c, address)
	if err != nil {
		c.Close()
		return nil, err
	}
	return c, nil
}

// Dial connects to the provided address on the provided network.
//
// Deprecated: Use DialContext instead.
func (d *httpConnectDialer) Dial(network, address string) (net.Conn, error) {
	return d.DialContext(context.Background(), network, address)
}

// NewDialer returns a new Dialer that dials through the proxy server's
// provided url. Communication between the client and proxy server adheres
// to the provided url and transport fields.
func httpConnectNewDialer(network string, url *url.URL, transport *Transport) *httpConnectDialer {
	if url.Scheme != "http" && url.Scheme != "https" {
		return nil
	}
	useTLS := url.Scheme == "https"
	port := url.Port()
	if port == "" {
		if url.Scheme == "http" {
			port = "80"
		} else {
			port = "443"
		}
	}

	// Make sure the proxy field in Transport will return the desired proxy url
	transport.Proxy = ProxyURL(url)

	// Copy the credentials for the proxy to the Transport
	if url.User != nil {
		if transport.ProxyConnectHeader == nil {
			transport.ProxyConnectHeader = make(Header)
		}
		password, _ := url.User.Password()
		encodedAuth := base64.StdEncoding.EncodeToString([]byte(url.User.Username() + ":" + password))
		transport.ProxyConnectHeader.Set("Proxy-Authorization", "Basic "+encodedAuth)
	}
	return &httpConnectDialer{proxyNetwork: network, proxyAddress: net.JoinHostPort(url.Hostname(), port),
		useTLS: useTLS, Transport: transport}
}
