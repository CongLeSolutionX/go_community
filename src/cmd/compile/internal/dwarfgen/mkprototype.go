// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore
// +build ignore

// Generate prototype.go from runtime/runtime.go.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

var stdout = flag.Bool("stdout", false, "write to stdout instead of builtin.go")

func main() {
	flag.Parse()
	generate()
}

func generate() {
	var b bytes.Buffer
	fmt.Fprintln(&b, "// Code generated by mkprototype.go. DO NOT EDIT.")
	fmt.Fprintln(&b)
	fmt.Fprintln(&b, "package dwarfgen")
	fmt.Fprintln(&b)
	fmt.Fprintln(&b, `import (`)
	fmt.Fprintln(&b, `      "cmd/internal/dwarf"`)
	fmt.Fprintln(&b, `      "cmd/internal/objabi"`)

	fmt.Fprintln(&b, `)`)

	mkprototype(&b, "runtime")
	out, err := format.Source(b.Bytes())
	//out, err = b.Bytes(), nil
	if err != nil {
		log.Fatal(err)
	}
	if *stdout {
		_, err = os.Stdout.Write(out)
	} else {
		err = ioutil.WriteFile("prototype.go", out, 0666)
	}
	if err != nil {
		log.Fatal(err)
	}
}

func mkprototype(w io.Writer, name string) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filepath.Join("prototype", name+".go"), nil, 0)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Fprintln(w)
	conf := &types.Config{Importer: importer.Default()}
	info := &types.Info{Defs: map[*ast.Ident]types.Object{}}
	_, err = conf.Check(f.Name.Name, fset, []*ast.File{f}, info)
	if err != nil {
		log.Fatal(err)
		return
	}

	defs := []types.Object{}
	for _, v := range info.Defs {
		if v, ok := v.(*types.TypeName); ok {
			defs = append(defs, v)
		}
	}
	sort.Slice(defs, func(i, j int) bool {
		return defs[i].Name() < defs[j].Name()
	})

	var interner typeInterner
	for _, arch := range archs {
		interner.reset(types.SizesFor("gc", arch))

		for _, v := range defs {
			interner.intern(v.Type())
		}
		fmt.Fprintln(w)
		fmt.Fprintf(w, "func _%sPrototypes() []prototype {\n", arch)
		fmt.Fprintf(w, "var typs [%d]prototype\n", interner.index)
		interner.typs = interner.typs[0:interner.index]
		for i, typ := range interner.typs {
			fmt.Fprintf(w, "typs[%d] = %s\n", i, typ)
		}
		fmt.Fprintln(w, "return typs[:]")
		fmt.Fprintln(w, "}")
	}

	fmt.Fprintf(w, "var DwarfPrototypes = map[string]int{\n")
	for _, v := range defs {
		typ := interner.intern(v.Type())
		fmt.Fprintf(w, "%q: %d,\n", v.Pkg().Name()+"."+v.Name(), typ)
	}
	fmt.Fprintln(w, "}")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "var archPrototypeGen = map[string]func()[]prototype{\n")
	for _, arch := range archs {
		fmt.Fprintf(w, "%q: %s,\n", arch, "_"+arch+"Prototypes")
	}
	fmt.Fprintln(w, "}")
	fmt.Fprintln(w)
}

type typeInterner struct {
	index int
	typs  []string
	hash  map[string]int
	sizes types.Sizes
}

func (i *typeInterner) reset(sizes types.Sizes) {
	i.index = 0
	i.hash = nil
	i.typs = make([]string, 100)
	i.sizes = sizes
}

func (i *typeInterner) intern(t types.Type) int {
	v, ok := i.hash[t.String()]
	if ok {
		return v
	}

	v = i.index
	i.index++
	if i.hash == nil {
		i.hash = make(map[string]int)
	}
	i.hash[t.String()] = v
	x := i.mktype(t)
	if len(i.typs) > v {
		i.typs[v] = x
	}

	return v
}

func (i *typeInterner) subtype(t types.Type) string {
	return fmt.Sprintf("&typs[%d]", i.intern(t))
}

var archs = []string{
	"386",
	"arm",
	"arm64",
	"amd64",
	"amd64p32",
	"mips",
	"mipsle",
	"mips64",
	"mips64le",
	"ppc64",
	"ppc64le",
	"riscv64",
	"s390x",
	"sparc64",
	"wasm",
}

var kinds = map[string]string{
	"bool":           "objabi.KindBool",
	"int":            "objabi.KindInt",
	"int8":           "objabi.KindInt8",
	"int16":          "objabi.KindInt16",
	"int32":          "objabi.KindInt32",
	"int64":          "objabi.KindInt64",
	"uint":           "objabi.KindUint",
	"uint8":          "objabi.KindUint8",
	"byte":           "objabi.KindUint8",
	"uint16":         "objabi.KindUint16",
	"uint32":         "objabi.KindUint32",
	"uint64":         "objabi.KindUint64",
	"uintptr":        "objabi.KindUintptr",
	"float32":        "objabi.KindFloat32",
	"float64":        "objabi.KindFloat64",
	"complex64":      "objabi.KindComplex64",
	"complex128":     "objabi.KindComplex128",
	"unsafe.Pointer": "objabi.KindUnsafePointer",
}

func (i *typeInterner) mktype(t types.Type) string {
	var kind string
	name := t.String()
	typedef := fmt.Sprintf(`prototype{size: %d`, i.sizes.Sizeof(t))
	switch typ := t.Underlying().(type) {
	case *types.Basic:
		if _, ok := kinds[typ.String()]; !ok {
			log.Println(typ.String())
		}
		if typ.String() == "byte" {
			name = "uint8"
		}
		if typ.String() == "rune" {
			name = "int32"
		}
		kind = kinds[typ.String()]

	case *types.Struct:
		kind = "objabi.KindStruct"
		var flds []*types.Var
		for i := 0; i < typ.NumFields(); i++ {
			flds = append(flds, typ.Field(i))
		}

		off := `[]int64{`
		for _, o := range i.sizes.Offsetsof(flds) {
			off += strconv.Itoa(int(o)) + ","
		}
		off += "}"
		names, typs := i.fields(flds, true)
		typedef += fmt.Sprintf(`,numElem: %d,fieldName: %s,fieldType: %s,fieldOff: %s`, typ.NumFields(), names, typs, off)
	case *types.Array:
		kind = "objabi.KindArray"
		typedef += fmt.Sprintf(`,elem: %s,numElem: %d`, i.subtype(typ.Elem()), typ.Len())
	case *types.Slice:
		kind = "objabi.KindSlice"
		typedef += fmt.Sprintf(`,elem: %s`, i.subtype(typ.Elem()))
	case *types.Pointer:
		kind = "objabi.KindPtr"
		if typ.String() == "*byte" {
			name = "*uint8"
		}
		if typ.String() == "*rune" {
			name = "*int32"
		}
		typedef += fmt.Sprintf(`,elem: %s`, i.subtype(typ.Elem()))
	default:
		log.Fatalf("unhandled type: %#v", t)
		panic("unreachable")
	}
	typedef += fmt.Sprintf(`,name: %q,kind: %s}`, name, kind)
	return typedef
}

func (i *typeInterner) fields(fl []*types.Var, keepNames bool) (names string, types string) {
	if len(fl) == 0 {
		return "nil", "nil"
	}
	var name []string
	var typs []string
	for _, f := range fl {
		typ := i.subtype(f.Type())
		if keepNames {
			name = append(name, fmt.Sprintf("%q", f.Name()))
			typs = append(typs, typ)
		} else {
			typs = append(typs, typ)
		}
	}

	return fmt.Sprintf("[]string{%s}", strings.Join(name, ", ")), fmt.Sprintf("[]dwarf.Type{%s}", strings.Join(typs, ", "))
}
