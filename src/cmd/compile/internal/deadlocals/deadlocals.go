// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The deadlocals pass removes assignments to unused local variables.
package deadlocals

import (
	"cmd/compile/internal/base"
	"cmd/compile/internal/ir"
	"cmd/compile/internal/types"
	"cmd/internal/src"
	"fmt"
	"go/constant"
)

// Funcs applies the deadlocals pass to fns.
func Funcs(fns []*ir.Func) {
	if base.Flag.N != 0 || base.Debug.NoDeadLocals != 0 {
		return
	}

	zero := ir.NewBasicLit(base.AutogeneratedPos, types.Types[types.TINT], constant.MakeInt64(0))

	for _, fn := range fns {
		if fn.IsHiddenClosure() {
			continue
		}

		v := newVisitor(fn)
		v.nodes(fn.Body)

		for _, assigns := range v.defs {
			for _, as := range assigns {
				// Kludge for "missing func info" linker panic.
				// See also closureInitLSym in inline/inl.go.
				if clo, ok := (*as.rhs).(*ir.ClosureExpr); ok && clo.Op() == ir.OCLOSURE {
					if !ir.IsTrivialClosure(clo) {
						ir.InitLSym(clo.Func, true)
					}
				}

				*as.lhs = ir.BlankNode
				*as.rhs = zero
			}
		}
	}
}

type visitor struct {
	curfn *ir.Func
	defs  map[*ir.Name][]assign

	doNode func(ir.Node) bool
}

type assign struct {
	pos      src.XPos
	lhs, rhs *ir.Node
}

func newVisitor(fn *ir.Func) *visitor {
	v := &visitor{
		curfn: fn,
		defs:  make(map[*ir.Name][]assign),
	}
	v.doNode = func(n ir.Node) bool {
		v.node(n)
		return false
	}
	return v
}

func (v *visitor) node(n ir.Node) {
	if n == nil {
		return
	}

	switch n.Op() {
	default:
		ir.DoChildrenWithHidden(n, v.doNode)
	case ir.OCLOSURE:
		n := n.(*ir.ClosureExpr)
		v.nodes(n.Init())
		for _, cv := range n.Func.ClosureVars {
			v.node(cv)
		}
		v.nodes(n.Func.Body)

	case ir.ODCL:
		// ignore
	case ir.ONAME:
		n := n.(*ir.Name)
		n = n.Canonical()
		if isLocal(n) {
			// Force any lazy definitions.
			s := v.defs[n]
			v.defs[n] = nil

			for _, as := range s {
				v.node(*as.rhs)
			}
		}

	case ir.OAS:
		n := n.(*ir.AssignStmt)
		v.assign(n.Pos(), &n.X, &n.Y)
	case ir.OAS2:
		n := n.(*ir.AssignListStmt)
		for i := range n.Lhs {
			v.assign(n.Pos(), &n.Lhs[i], &n.Rhs[i])
		}
	}
}

func (v *visitor) nodes(list ir.Nodes) {
	for _, n := range list {
		v.node(n)
	}
}

func hasEffects(n ir.Node) bool {
	if n == nil {
		return false
	}
	if len(n.Init()) != 0 {
		return true
	}

	switch n.Op() {
	// TODO(mdempsky): More.
	case ir.ONAME, ir.OLITERAL, ir.ONIL, ir.OCLOSURE:
		return false
	}
	return true
}

func (v *visitor) assign(pos src.XPos, lhs, rhs *ir.Node) {
	name, ok := (*lhs).(*ir.Name)
	if !ok {
		v.node(*lhs) // XXX: Interpret as variable, not value.
		v.node(*rhs)
		return
	}
	name = name.Canonical()

	if isLocal(name) && !hasEffects(*rhs) {
		if s, ok := v.defs[name]; !ok || s != nil {
			v.defs[name] = append(s, assign{pos, lhs, rhs})
			return
		}
	}

	v.node(*rhs)
}

func isLocal(n *ir.Name) bool {
	if ir.IsBlank(n) {
		return true
	}

	switch n.Class {
	case ir.PAUTO, ir.PPARAM:
		return true
	case ir.PPARAMOUT:
		return false
	case ir.PEXTERN, ir.PFUNC:
		return false
	}
	panic(fmt.Sprintf("unexpected Class: %+v", n))
}
