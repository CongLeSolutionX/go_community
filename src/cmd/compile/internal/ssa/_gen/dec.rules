// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file contains rules to decompose builtin compound types
// (complex,string,slice,interface) into their constituent
// types.  These rules work together with the decomposeBuiltIn
// pass which handles phis of these types.

// complex ops
(ComplexReal (ComplexMake real _  )) => real
(ComplexImag (ComplexMake _ imag )) => imag

(Load <t> ptr mem) && t.IsComplex() && t.Size() == 8 =>
  (ComplexMake
    (Load <typ.Float32> ptr mem)
    (Load <typ.Float32>
      (OffPtr <typ.Float32Ptr> [4] ptr)
      mem)
    )
(Store {t} dst (ComplexMake real imag) mem) && t.Size() == 8 =>
  (Store {typ.Float32}
    (OffPtr <typ.Float32Ptr> [4] dst)
    imag
    (Store {typ.Float32} dst real mem))
(Load <t> ptr mem) && t.IsComplex() && t.Size() == 16 =>
  (ComplexMake
    (Load <typ.Float64> ptr mem)
    (Load <typ.Float64>
      (OffPtr <typ.Float64Ptr> [8] ptr)
      mem)
    )
(Store {t} dst (ComplexMake real imag) mem) && t.Size() == 16 =>
  (Store {typ.Float64}
    (OffPtr <typ.Float64Ptr> [8] dst)
    imag
    (Store {typ.Float64} dst real mem))

// string ops
(StringPtr (StringMake ptr _)) => ptr
(StringLen (StringMake _ len)) => len

// Note: we require that these loads be CSEd. So this isn't
// correct with optimizations off.
(Load <t> ptr mem) && t.IsString() =>
  (StringMake
    (ExpStringPtr <typ.BytePtr> (Load <types.TypeStr128> ptr mem))
    (ExpStringLen <typ.Int> (Load <types.TypeStr128> ptr mem)))
(Load <t> ptr mem) && t.IsInterface() =>
  (IMake
    (ExpInterType <typ.Uintptr> (Load <types.TypeInter128> ptr mem))
    (ExpInterData <typ.BytePtr> (Load <types.TypeInter128> ptr mem)))
(Load <t> ptr mem) && t.IsSlice() =>
  (SliceMake
    (ExpSlicePtr <t.Elem().PtrTo()> (Load <types.TypeSlice128> ptr mem))
    (ExpSliceLen <typ.Int> (Load <types.TypeSlice128> ptr mem))
    (Load <typ.Int> (OffPtr <typ.IntPtr> [2*config.PtrSize] ptr) mem))

(Store {t} dst str mem) && t.IsString() =>
  (Store {types.TypeStr128}
    dst
    (ExpStringMake <types.TypeStr128> (StringPtr str) (StringLen str))
    mem)
(Store {t} dst int mem) && t.IsInterface() =>
  (Store {types.TypeInter128}
    dst
    (ExpInterMake <types.TypeInter128> (ITab int) (IData int))
    mem)
(Store {t} dst s mem) && t.IsSlice() =>
  (Store {typ.Int}
    (OffPtr <typ.IntPtr> [2*config.PtrSize] dst)
    (SliceCap <typ.Int> s)
    (Store {types.TypeSlice128}
      dst
      (ExpSliceMake <types.TypeSlice128> (SlicePtr s) (SliceLen <typ.Int> s))
      mem))

// Avoid round-tripping through the integer registers. Useful when
// we're just doing a load+store of a string, interface, or slice.
(ExpStringMake (ExpStringPtr x) (ExpStringLen x)) => x
(ExpInterMake (ExpInterType x) (ExpInterData x)) => x
(ExpSliceMake (ExpSlicePtr x) (ExpSliceLen x)) => x

// slice ops
(SlicePtr (SliceMake ptr _ _ )) => ptr
(SliceLen (SliceMake _ len _)) => len
(SliceCap (SliceMake _ _ cap)) => cap
(SlicePtrUnchecked (SliceMake ptr _ _ )) => ptr

(Load <t> ptr mem) && t.IsSlice() =>
  (SliceMake
    (Load <t.Elem().PtrTo()> ptr mem)
    (Load <typ.Int>
      (OffPtr <typ.IntPtr> [config.PtrSize] ptr)
      mem)
    (Load <typ.Int>
      (OffPtr <typ.IntPtr> [2*config.PtrSize] ptr)
      mem))
(Store {t} dst (SliceMake ptr len cap) mem) =>
  (Store {typ.Int}
    (OffPtr <typ.IntPtr> [2*config.PtrSize] dst)
    cap
    (Store {typ.Int}
      (OffPtr <typ.IntPtr> [config.PtrSize] dst)
      len
      (Store {t.Elem().PtrTo()} dst ptr mem)))

// interface ops
(ITab (IMake itab _)) => itab
(IData (IMake _ data)) => data

(Load <t> ptr mem) && t.IsInterface() =>
  (IMake
    (Load <typ.Uintptr> ptr mem)
    (Load <typ.BytePtr>
      (OffPtr <typ.BytePtrPtr> [config.PtrSize] ptr)
      mem))
(Store dst (IMake itab data) mem) =>
  (Store {typ.BytePtr}
    (OffPtr <typ.BytePtrPtr> [config.PtrSize] dst)
    data
    (Store {typ.Uintptr} dst itab mem))
