This package contains the compiler's Static Single Assignment form
component. If you're not familiar with SSA, Wikipedia is a good starting
point:

	https://en.wikipedia.org/wiki/Static_single_assignment_form

SSA is useful to perform transformations and optimizations, which can be
found in this package in the form of compiler passes and rewrite rules.
The former can be found in the "passes" array in compile.go, while the
latter are generated from gen/*.rules.

Like most other SSA forms, funcs consist of blocks and values. Values
perform an operation, which is encoded in the form of an operator and a
number of arguments. The semantics of each Op can be found in
gen/*Ops.go.

Blocks can have multiple forms. For example, BlockPlain will always hand
the control flow to another block. And BlockIf will flow to one of two
blocks depending on a value.

Values also have types. For example, a constant boolean value will have
a Bool type, and a variable definition value will have a memory type.

The memory type is special - it tells us the memory state. For example,
an Op that takes a memory argument depends on that memory state. And an
Op which has the memory type impacts the state of memory. This is
important so that memory operations are kept in the right order.

A good way to see and get used to the compiler's SSA in action is via
GOSSAFUNC. For example, to see func Foo's initial SSA form and final
generated assembly, one can run:

	GOSSAFUNC=Foo go build
