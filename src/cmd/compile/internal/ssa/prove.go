// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ssa

// rangeMask represents the possible relations between a pair of variables.
type rangeMask uint

const (
	lt rangeMask = 1 << iota
	eq
	gt
)

// typeMask represents the universe of a variable pair in which
// a set of relations is known.
// For example, information learned for unsigned pairs cannot
// be transfered to signed pairs because the same bit representation
// can mean something else.
type typeMask uint

const (
	signed typeMask = 1 << iota
	unsigned
	pointer
	boolean
)

type typeRange struct {
	t typeMask
	r rangeMask
}

type control struct {
	tm     typeMask
	a0, a1 ID
}

// factsTable keeps track of restrictions for each pair of values in
// the dominators for the current node.
// Invariant: a0.ID <= a1.ID
// For example {unsigned, a0, a1} -> eq|gt means that from
// predecessors we know that a0 must be greater or equal to a1.
// Special case {boolean, -1, a0} means any boolean.
type factsTable map[control][]rangeMask

func (ft factsTable) get(i control) rangeMask {
	arr, ok := ft[i]
	if !ok {
		if i.a0 == i.a1 {
			return eq
		}
		return lt | eq | gt
	}
	return arr[len(arr)-1]
}

func (ft factsTable) push(i control, r rangeMask) {
	// ft[i] contains the possible relations between a0 and a1.
	// When we branched from parent we learned that the possible
	// relations cannot be more than tr.r. We compute the new set of
	// relations as the intersection between the old and the new set.
	ft[i] = append(ft[i], ft.get(i)&r)
}

func (ft factsTable) pop(i control) {
	arr := ft[i]
	arr = arr[:len(arr)-1]
	if len(arr) == 0 {
		delete(ft, i)
	} else {
		ft[i] = arr
	}
}

var (
	reverseBits = [...]rangeMask{0, 4, 2, 6, 1, 5, 3, 7}

	// maps what we learn when the positive branch is taken.
	// For example:
	//      OpLess8:   {signed, lt},
	//	v1 = (OpLess8 v2 v3).
	// If v1 branch is taken than we learn that the rangeMaks
	// can be at most lt.
	typeRangeTable = map[Op]typeRange{
		OpEq8:   {signed | unsigned, eq},
		OpEq16:  {signed | unsigned, eq},
		OpEq32:  {signed | unsigned, eq},
		OpEq64:  {signed | unsigned, eq},
		OpEqPtr: {pointer, eq},

		OpNeq8:   {signed | unsigned, lt | gt},
		OpNeq16:  {signed | unsigned, lt | gt},
		OpNeq32:  {signed | unsigned, lt | gt},
		OpNeq64:  {signed | unsigned, lt | gt},
		OpNeqPtr: {pointer, lt | gt},

		OpLess8:   {signed, lt},
		OpLess8U:  {unsigned, lt},
		OpLess16:  {signed, lt},
		OpLess16U: {unsigned, lt},
		OpLess32:  {signed, lt},
		OpLess32U: {unsigned, lt},
		OpLess64:  {signed, lt},
		OpLess64U: {unsigned, lt},

		OpLeq8:   {signed, lt | eq},
		OpLeq8U:  {unsigned, lt | eq},
		OpLeq16:  {signed, lt | eq},
		OpLeq16U: {unsigned, lt | eq},
		OpLeq32:  {signed, lt | eq},
		OpLeq32U: {unsigned, lt | eq},
		OpLeq64:  {signed, lt | eq},
		OpLeq64U: {unsigned, lt | eq},

		OpGeq8:   {signed, eq | gt},
		OpGeq8U:  {unsigned, eq | gt},
		OpGeq16:  {signed, eq | gt},
		OpGeq16U: {unsigned, eq | gt},
		OpGeq32:  {signed, eq | gt},
		OpGeq32U: {unsigned, eq | gt},
		OpGeq64:  {signed, eq | gt},
		OpGeq64U: {unsigned, eq | gt},

		OpGreater8:   {signed, gt},
		OpGreater8U:  {unsigned, gt},
		OpGreater16:  {signed, gt},
		OpGreater16U: {unsigned, gt},
		OpGreater32:  {signed, gt},
		OpGreater32U: {unsigned, gt},
		OpGreater64:  {signed, gt},
		OpGreater64U: {unsigned, gt},

		// TODO: OpIsInBounds actually test 0 <= a < b. This means
		// that the positive branch learns signed/LT and unsigned/LT
		// but the negative branch only learns unsigned/GE.
		OpIsInBounds:      {unsigned, lt},
		OpIsSliceInBounds: {unsigned, lt | eq},
	}
)

// prove removes redundant BlockIf controls that can be inferred in a straight line.
//
// By far, the most common redundant control are generated by bounds checking.
// For example for the code:
//
//    a[i] = 4
//    foo(a[i])
//
// The compiler will generate the following code:
//
//    if i >= len(a) {
//        panic("not in bounds")
//    }
//    a[i] = 4
//    if i >= len(a) {
//        panic("not in bounds")
//    }
//    foo(a[i])
//
// The second comparison i >= len(a) is clearly redundant because if the
// else branch of the first comparison is executed, we already know that i < len(a).
// The code for the second panic can be removed.
func prove(f *Func) {
	idom := dominators(f)
	sdom := newSparseTree(f, idom)

	// current node state
	type walkState int
	const (
		descend walkState = iota
		simplify
	)
	// work maintains the DFS stack.
	type bp struct {
		block *Block    // current handled block
		state walkState // what's to do
	}
	work := make([]bp, 0, 256)
	work = append(work, bp{
		block: f.Entry,
		state: descend,
	})

	ft := make(factsTable)

	// DFS on the dominator tree.
	for len(work) > 0 {
		node := work[len(work)-1]
		work = work[:len(work)-1]
		parent := idom[node.block.ID]
		branch := getBranch(sdom, parent, node.block)

		switch node.state {
		case descend:
			if branch != -1 {
				c := parent.Control
				updateRestrictions(ft, -1, c.ID, typeRange{boolean, eq}, branch)
				tr, has := typeRangeTable[parent.Control.Op]
				if has {
					updateRestrictions(ft, c.Args[0].ID, c.Args[1].ID, tr, branch)
				}
			}

			work = append(work, bp{
				block: node.block,
				state: simplify,
			})
			for s := sdom.Child(node.block); s != nil; s = sdom.Sibling(s) {
				work = append(work, bp{
					block: s,
					state: descend,
				})
			}

		case simplify:
			succ := simplifyBlock(ft, node.block)
			if succ != -1 {
				b := node.block
				b.Kind = BlockFirst
				b.Control = nil
				b.Succs[0], b.Succs[1] = b.Succs[succ], b.Succs[1-succ]
			}

			if branch != -1 {
				c := parent.Control
				restoreRestrictions(ft, -1, c.ID, typeRange{boolean, eq})
				tr, has := typeRangeTable[parent.Control.Op]
				if has {
					restoreRestrictions(ft, c.Args[0].ID, c.Args[1].ID, tr)
				}
			}
		}
	}
}

// getBranch returns the range restrictions added by p
// when reaching b. p is the immediate dominator or b.
func getBranch(sdom sparseTree, p *Block, b *Block) int {
	if p == nil || p.Kind != BlockIf {
		return -1
	}
	// If p and p.Succs[0] are dominators it means that every path
	// from entry to b passes through p and p.Succs[0]. We care that
	// no path from entry to b passes through p.Succs[1]. If p.Succs[0]
	// has one predecessor then (apart from the degenerate case),
	// there is no path from entry that can reach b through p.Succs[1].
	// TODO: how about p->yes->b->yes, i.e. a loop in yes.
	if sdom.isAncestorEq(p.Succs[0], b) && len(p.Succs[0].Preds) == 1 {
		return 0
	}
	if sdom.isAncestorEq(p.Succs[1], b) && len(p.Succs[1].Preds) == 1 {
		return 1
	}
	return -1
}

// updateRestrictions updates restrictions from the previous block (p) based on tr.
func updateRestrictions(ft factsTable, a0, a1 ID, tr typeRange, branch int) {
	if tr.t == 0 {
		return
	}
	if branch == -1 {
		return
	}
	if branch == 1 {
		tr.r = (lt | eq | gt) ^ tr.r
	}

	// p modifies the restrictions for (a0, a1).
	// save and return the previous state.
	if a0 > a1 {
		tr.r = reverseBits[tr.r]
		a0, a1 = a1, a0
	}
	for t := typeMask(1); t <= tr.t; t <<= 1 {
		if t&tr.t != 0 {
			ft.push(control{t, a0, a1}, tr.r)
		}
	}
	return
}

func restoreRestrictions(ft factsTable, a0, a1 ID, tr typeRange) {
	if tr.r == 0 {
		return
	}
	if a0 > a1 {
		a0, a1 = a1, a0
	}
	for t := typeMask(1); t <= tr.t; t <<= 1 {
		if t&tr.t != 0 {
			ft.pop(control{t, a0, a1})
		}
	}
}

// simplifyBlock simplifies block known the restrictions in ft.
// Returns which branch is always taken, or -1 if both braches are possible.
func simplifyBlock(ft factsTable, b *Block) int {
	if b.Kind != BlockIf {
		return -1
	}

	// First, checks if the condition itself is redundant.
	i := control{boolean, -1, b.Control.ID}
	m := ft.get(i)
	if m == eq {
		if b.Func.pass.debug > 0 {
			b.Func.Config.Warnl(int(b.Line), "Proved boolean %s", b.Control.Op)
		}
		return 0
	}
	if m == lt|gt {
		if b.Func.pass.debug > 0 {
			b.Func.Config.Warnl(int(b.Line), "Disproved boolean %s", b.Control.Op)
		}
		return 1
	}

	// Next look check equalities.
	tr, has := typeRangeTable[b.Control.Op]
	if !has {
		return -1
	}

	a0 := b.Control.Args[0].ID
	a1 := b.Control.Args[1].ID
	if a0 > a1 {
		tr.r = reverseBits[tr.r]
		a0, a1 = a1, a0
	}

	for t := typeMask(1); t <= tr.t; t <<= 1 {
		if t&tr.t == 0 {
			continue
		}

		// tr.r represents in which case the positive branch is taken.
		// m.r represents which cases are possible because of previous relations.
		// If the set of possible relations m.r is included in the set of relations
		// need to take the positive branch (or negative) then that branch will
		// always be taken.
		// For shortcut, if m.r == 0 then this block is dead code.
		m := ft.get(control{t, a0, a1})
		if m != 0 && tr.r&m == m {
			if b.Func.pass.debug > 0 {
				b.Func.Config.Warnl(int(b.Line), "Proved %s", b.Control.Op)
			}
			b.Logf("proved positive branch of %s, block %s in %s\n", b.Control, b, b.Func.Name)
			return 0
		}
		if m != 0 && ((lt|eq|gt)^tr.r)&m == m {
			if b.Func.pass.debug > 0 {
				b.Func.Config.Warnl(int(b.Line), "Disproved %s", b.Control.Op)
			}
			b.Logf("proved negative branch of %s, block %s in %s\n", b.Control, b, b.Func.Name)
			return -1
		}
	}

	// HACK: If the first argument of IsInBounds or IsSliceInBounds
	// is a constant and we already know that constant is smaller (or equal)
	// to the upper bound than this is proven. Most useful in cases such as:
	// if len(a) <= 1 { return }
	// do something with a[1]
	c := b.Control
	if (c.Op == OpIsInBounds || c.Op == OpIsSliceInBounds) && isNonNegative(c.Args[0]) {
		m := ft.get(control{signed, a0, a1})
		if m != 0 && tr.r&m == m {
			if b.Func.pass.debug > 0 {
				b.Func.Config.Warnl(int(b.Line), "Proved constant %s", c.Op)
			}
			return 0
		}
	}

	// HACK: If the first argument of IsSliceInBounds is 0 and the limit
	// is non-negative then the condition is always true.
	if c.Op == OpIsSliceInBounds && c.Args[0].Op == OpConst64 && c.Args[0].AuxInt == 0 && isNonNegative(c.Args[1]) {
		if b.Func.pass.debug > 0 {
			b.Func.Config.Warnl(int(b.Line), "Proved 0 <= non-negative %s", c.Op)
		}
		return 0
	}

	return -1
}

// isNonNegative returns true is v is known to be greater or equal to zero.
func isNonNegative(v *Value) bool {
	if v.Op == OpConst64 && v.AuxInt >= 0 {
		return true
	}
	if v.Op == OpStringLen || v.Op == OpSliceLen || v.Op == OpSliceCap {
		return true
	}
	if v.Op == OpRsh64x64 {
		return isNonNegative(v.Args[0])
	}
	return false
}
