// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This program generates Go code that creates rules for constant
// shift rewriting prior to code generation from the rules.
// In all cases of LSH/RSH X,Y where Y is a constant, the bitwidth of Y
// and the constant will be the same reducing the number of rules to
// generate.

package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
)

// pieceGen is the type of function that writes out a portion of the
// generated shift rules. w1, and w2 are bit widths, while hdr indicates
// if the function should write out a header only
type pieceGen func(w io.Writer, w1, w2 int, hdr bool)

func isGeneric(arch arch) bool {
	return arch.name == "generic"
}

func genGenericShift(arch arch) {
	w := new(bytes.Buffer)
	fmt.Fprintf(w, "// autogenerated from genShiftRules.go do not edit!\n")
	fmt.Fprintln(w, "// generated with: go run *.go")

	widths := []int{64, 32, 16, 8}
	pieces := []pieceGen{largeShift, zeroShift, constShift}
	for _, pg := range pieces {
		fmt.Fprintln(w, "")
		// print the header
		pg(w, 0, 0, true)
		for _, w1 := range widths {
			for _, w2 := range widths {
				// print the generated code
				pg(w, w1, w2, false)
			}
		}
	}

	// Write to file
	err := ioutil.WriteFile("generic_genShift.rules", w.Bytes(), 0666)
	if err != nil {
		log.Fatalf("can't write output: %v\n", err)
	}
}

func largeShift(w io.Writer, w1, w2 int, hdr bool) {
	if hdr {
		fmt.Fprintln(w, "// shifts by more bits than the destination")
		return
	}
	if w2 >= w1 {
		fmt.Fprintf(w, "(Lsh%dx%d _ (Const%d [c])) && c >= %d -> (Const64 [0])\n", w1, w2, w2, w1)
		fmt.Fprintf(w, "(Rsh%dx%d _ (Const%d [c])) && c >= %d -> (Const64 [0])\n", w1, w2, w2, w1)
		fmt.Fprintf(w, "(Rsh%dUx%d _ (Const%d [c])) && c >= %d -> (Const64 [0])\n", w1, w2, w2, w1)
	}
}

func zeroShift(w io.Writer, w1, w2 int, hdr bool) {
	if hdr {
		fmt.Fprintln(w, "// shifts by zero are a no-op")
		return
	}
	if w2 == 64 {
		fmt.Fprintf(w, "(Lsh%dx%d x (Const%d [0])) -> x\n", w1, w2, w2)
		fmt.Fprintf(w, "(Rsh%dx%d x (Const%d [0])) -> x\n", w1, w2, w2)
		fmt.Fprintf(w, "(Rsh%dUx%d x (Const%d [0])) -> x\n", w1, w2, w2)
	} else {
		fmt.Fprintf(w, "(Lsh%dx%d x (Const%d [c])) && c == 0 -> x\n", w1, w2, w2)
		fmt.Fprintf(w, "(Rsh%dx%d x (Const%d [c])) && c == 0 -> x\n", w1, w2, w2)
		fmt.Fprintf(w, "(Rsh%dUx%d x (Const%d [c])) && c == 0 -> x\n", w1, w2, w2)
	}
}

func constShift(w io.Writer, w1, w2 int, hdr bool) {
	if hdr {
		fmt.Fprintln(w, "// shifts by constants can be merged")
		return
	}
	widths := []int{64, 32, 16, 8}
	for _, w3 := range widths {
		// we need an additional width to generate all possible combinations
		// of (LshW1xW2 (LshW1xW3...
		fmt.Fprintf(w, "(Lsh%dx%d <t> (Lsh%dx%d x (Const%d [c])) (Const%d [d])) -> (Lsh%dx%d x  (Const%d <t> [c+d]))\n", w1, w2, w1, w3, w3, w2, w1, w2, w2)
		fmt.Fprintf(w, "(Rsh%dx%d <t> (Rsh%dx%d x (Const%d [c])) (Const%d [d])) -> (Rsh%dx%d x  (Const%d <t> [c+d]))\n", w1, w2, w1, w3, w3, w2, w1, w2, w2)
		fmt.Fprintf(w, "(Rsh%dUx%d <t> (Rsh%dUx%d x (Const%d [c])) (Const%d [d])) -> (Rsh%dUx%d x  (Const%d <t> [c+d]))\n", w1, w2, w1, w3, w3, w2, w1, w2, w2)
	}
}

func init() {
	genInputRules = append(genInputRules, genInputRule{isGeneric, genGenericShift})
}
