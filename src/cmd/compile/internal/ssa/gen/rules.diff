diff --git a/src/cmd/compile/internal/ssa/gen/386.rules b/src/cmd/compile/internal/ssa/gen/386.rules
index df03cb71a6..77169c1e67 100644
--- a/src/cmd/compile/internal/ssa/gen/386.rules
+++ b/src/cmd/compile/internal/ssa/gen/386.rules
@@ -313,7 +313,14 @@
 (ConstBool [c]) => (MOVLconst [b2i32(c)])
 
 // Lowering calls
-(StaticCall ...) => (CALLstatic ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall ...) => (CALLinter ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/ARM.rules b/src/cmd/compile/internal/ssa/gen/ARM.rules
index de0df363e4..663c5f7b44 100644
--- a/src/cmd/compile/internal/ssa/gen/ARM.rules
+++ b/src/cmd/compile/internal/ssa/gen/ARM.rules
@@ -347,7 +347,14 @@
 		mem)
 
 // calls
-(StaticCall ...) => (CALLstatic ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall ...) => (CALLinter ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/ARM64.rules b/src/cmd/compile/internal/ssa/gen/ARM64.rules
index a0e2a0d5e2..c583a1a3f2 100644
--- a/src/cmd/compile/internal/ssa/gen/ARM64.rules
+++ b/src/cmd/compile/internal/ssa/gen/ARM64.rules
@@ -498,7 +498,14 @@
 		mem)
 
 // calls
-(StaticCall ...) => (CALLstatic ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall ...) => (CALLinter ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/MIPS.rules b/src/cmd/compile/internal/ssa/gen/MIPS.rules
index 8ad2c90ac3..c8a2e386a2 100644
--- a/src/cmd/compile/internal/ssa/gen/MIPS.rules
+++ b/src/cmd/compile/internal/ssa/gen/MIPS.rules
@@ -330,7 +330,14 @@
 		mem)
 
 // calls
-(StaticCall ...)  => (CALLstatic ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall ...)   => (CALLinter ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/MIPS64.rules b/src/cmd/compile/internal/ssa/gen/MIPS64.rules
index 088c9b1ac4..b747483279 100644
--- a/src/cmd/compile/internal/ssa/gen/MIPS64.rules
+++ b/src/cmd/compile/internal/ssa/gen/MIPS64.rules
@@ -375,7 +375,14 @@
 		mem)
 
 // calls
-(StaticCall ...) => (CALLstatic ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall ...) => (CALLinter ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/PPC64.rules b/src/cmd/compile/internal/ssa/gen/PPC64.rules
index a762be65d4..b5dd3a8453 100644
--- a/src/cmd/compile/internal/ssa/gen/PPC64.rules
+++ b/src/cmd/compile/internal/ssa/gen/PPC64.rules
@@ -677,8 +677,14 @@
         (LoweredQuadMove [s] dst src mem)
 
 // Calls
-// Lowering calls
-(StaticCall ...) => (CALLstatic ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall ...) => (CALLinter ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/RISCV64.rules b/src/cmd/compile/internal/ssa/gen/RISCV64.rules
index 4380a5efef..fd51fc39e7 100644
--- a/src/cmd/compile/internal/ssa/gen/RISCV64.rules
+++ b/src/cmd/compile/internal/ssa/gen/RISCV64.rules
@@ -545,7 +545,14 @@
 (LocalAddr {sym} base _) => (MOVaddr {sym} base)
 
 // Calls
-(StaticCall  ...) => (CALLstatic  ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall   ...) => (CALLinter   ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/S390X.rules b/src/cmd/compile/internal/ssa/gen/S390X.rules
index c3421da0a2..e6dbd1e9d4 100644
--- a/src/cmd/compile/internal/ssa/gen/S390X.rules
+++ b/src/cmd/compile/internal/ssa/gen/S390X.rules
@@ -429,7 +429,14 @@
 (ConstBool [b]) => (MOVDconst [b2i(b)])
 
 // Lowering calls
-(StaticCall ...) => (CALLstatic ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (CALLstatic <t.FieldType(t.NumFields()-1)> [i] {a} x)
+(SelectN <types.TypeMem> [0] x:(CALLstatic _)) => x
+
 (ClosureCall ...) => (CALLclosure ...)
 (InterCall ...) => (CALLinter ...)
 
diff --git a/src/cmd/compile/internal/ssa/gen/Wasm.rules b/src/cmd/compile/internal/ssa/gen/Wasm.rules
index fc45cd3ed5..f976c7f2dd 100644
--- a/src/cmd/compile/internal/ssa/gen/Wasm.rules
+++ b/src/cmd/compile/internal/ssa/gen/Wasm.rules
@@ -304,7 +304,16 @@
 (ConstBool [c]) => (I64Const [b2i(c)])
 
 // Lowering calls
-(StaticCall ...) => (LoweredStaticCall ...)
+
+// StaticCall is manyIn->manyOut, but for ABI0 architectures "many == (mem)", arch CALLstatic is mem->mem
+// Requiring SelectN accessor and type match will kick out any missed StaticCall as failure to lower.
+// To convert to register ABI, the rewrite is (StaticCall ...) -> (CALLstatic ...), and the architecture-
+// specific code generator needs to process OpSelectN.
+(StaticCall <t> [i] {a} x) && t.IsResults() => (LoweredStaticCall <t.FieldType(t.NumFields()-1)> [i] {a} x)
+
+// For for not-yet-new-ABI architectures, fix the glitch
+(SelectN <types.TypeMem> [0] x:(LoweredStaticCall _)) => x
+
 (ClosureCall ...) => (LoweredClosureCall ...)
 (InterCall ...) => (LoweredInterCall ...)
 