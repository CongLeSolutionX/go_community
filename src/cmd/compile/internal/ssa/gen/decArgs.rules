// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Decompose compound argument values
// Do this early to simplify tracking names for debugging.

(Arg {n} [off]) && v.Type.IsString() ->
  (StringMake
    (Arg <typ.BytePtr> {n} [off])
    (Arg <typ.Int> {n} [off+config.PtrSize]))

(Arg {n} [off]) && v.Type.IsSlice() ->
  (SliceMake
    (Arg <v.Type.Elem().PtrTo()> {n} [off])
    (Arg <typ.Int> {n} [off+config.PtrSize])
    (Arg <typ.Int> {n} [off+2*config.PtrSize]))

(Arg {n} [off]) && v.Type.IsInterface() ->
  (IMake
    (Arg <typ.Uintptr> {n} [off])
    (Arg <typ.BytePtr> {n} [off+config.PtrSize]))

(Arg {n} [off]) && v.Type.IsComplex() && v.Type.Size() == 16 ->
  (ComplexMake
    (Arg <typ.Float64> {n} [off])
    (Arg <typ.Float64> {n} [off+8]))

(Arg {n} [off]) && v.Type.IsComplex() && v.Type.Size() == 8 ->
  (ComplexMake
    (Arg <typ.Float32> {n} [off])
    (Arg <typ.Float32> {n} [off+4]))

(Arg <t>) && t.IsStruct() -> { argStruct(v) }

(Arg <t>) && t.IsArray() && t.NumElem() == 0 ->
  (ArrayMake)
(Arg <t> {n} [off]) && t.IsArray() && t.NumElem() == 1 ->
  (ArrayUpdate (ArrayMake <t>) (Const64 <types.Types[types.TINT]> [0]) (Arg <t.Elem()> {n} [off]))
// TODO: Const64->?
  
