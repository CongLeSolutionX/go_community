// autogenerated from gen/386.rules: do not edit!
// generated with: cd gen; go run *.go

package ssa

import "math"

var _ = math.MinInt8 // in case not otherwise used
func rewriteValue386(v *Value, config *Config) bool {
	switch v.Op {
	case OpAdd32:
		return rewriteValue386_OpAdd32(v, config)
	case OpAddr:
		return rewriteValue386_OpAddr(v, config)
	case OpStore:
		return rewriteValue386_OpStore(v, config)
	}
	return false
}
func rewriteValue386_OpAdd32(v *Value, config *Config) bool {
	b := v.Block
	_ = b
	// match: (Add32 x y)
	// cond:
	// result: (ADDL x y)
	for {
		x := v.Args[0]
		y := v.Args[1]
		v.reset(Op386ADDL)
		v.AddArg(x)
		v.AddArg(y)
		return true
	}
}
func rewriteValue386_OpAddr(v *Value, config *Config) bool {
	b := v.Block
	_ = b
	// match: (Addr {sym} base)
	// cond:
	// result: (LEAL {sym} base)
	for {
		sym := v.Aux
		base := v.Args[0]
		v.reset(Op386LEAL)
		v.Aux = sym
		v.AddArg(base)
		return true
	}
}
func rewriteValue386_OpStore(v *Value, config *Config) bool {
	b := v.Block
	_ = b
	// match: (Store [4] ptr val mem)
	// cond:
	// result: (MOVLstore ptr val mem)
	for {
		if v.AuxInt != 4 {
			break
		}
		ptr := v.Args[0]
		val := v.Args[1]
		mem := v.Args[2]
		v.reset(Op386MOVLstore)
		v.AddArg(ptr)
		v.AddArg(val)
		v.AddArg(mem)
		return true
	}
	return false
}
func rewriteBlock386(b *Block) bool {
	switch b.Kind {
	}
	return false
}
