// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package conversions

import (
        "constraints"
        "unsafe"
)

// "x is assignable to T"
// - tested via assignability tests

// "x's type and T have identical underlying types if tags are ignored"

func _[X ~int, T ~int](x X) T { return T(x) }
func _[X struct{f int "foo"}, T struct{f int "bar"}](x X) T { return T(x) }

type Foo struct{f int "foo"}
type Bar struct{f int "bar"}
type Far struct{f float64 }

func _[X Foo, T Bar](x X) T { return T(x) }
func _[X Foo|Bar, T Bar](x X) T { return T(x) }
func _[X Foo, T Foo|Bar](x X) T { return T(x) }
func _[X Foo, T Far](x X) T { return T(x /* ERROR cannot convert */ ) }

// "x's type and T are unnamed pointer types and their pointer base types
// have identical underlying types if tags are ignored"

func _[X ~*Foo, T ~*Bar](x X) T { return T(x) }
func _[X ~*Foo|~*Bar, T ~*Bar](x X) T { return T(x) }
func _[X ~*Foo, T ~*Foo|~*Bar](x X) T { return T(x) }
func _[X ~*Foo, T ~*Far](x X) T { return T(x /* ERROR cannot convert */ ) }

// "x's type and T are both integer or floating point types"

func _[X constraints.Integer, T constraints.Integer](x X) T { return T(x) }
func _[X constraints.Unsigned, T constraints.Integer](x X) T { return T(x) }
func _[X constraints.Float, T constraints.Integer](x X) T { return T(x) }

func _[X constraints.Integer, T constraints.Unsigned](x X) T { return T(x) }
func _[X constraints.Unsigned, T constraints.Unsigned](x X) T { return T(x) }
func _[X constraints.Float, T constraints.Unsigned](x X) T { return T(x) }

func _[X constraints.Integer, T constraints.Float](x X) T { return T(x) }
func _[X constraints.Unsigned, T constraints.Float](x X) T { return T(x) }
func _[X constraints.Float, T constraints.Float](x X) T { return T(x) }

func _[X, T constraints.Integer|constraints.Unsigned|constraints.Float](x X) T { return T(x) }
func _[X, T constraints.Integer|~string](x X) T { return T(x /* ERROR cannot convert */ ) }

// "x's type and T are both complex types"

func _[X, T constraints.Complex](x X) T { return T(x) }
func _[X, T constraints.Float|constraints.Complex](x X) T { return T(x /* ERROR cannot convert */ ) }

// "x is an integer or a slice of bytes or runes and T is a string type"

type myInt int
type myString string

func _[T ~string](x int) T { return T(x) }
func _[T ~string](x myInt) T { return T(x) }
func _[X constraints.Integer](x X) string { return string(x) }
func _[X constraints.Integer](x X) myString { return myString(x) }
func _[X constraints.Integer](x X) *string { return (*string)(x /* ERROR cannot convert */ ) }

func _[T ~string](x []byte) T { return T(x) }
func _[T ~string](x []rune) T { return T(x) }
func _[X ~[]byte, T ~string](x X) T { return T(x) }
func _[X ~[]rune, T ~string](x X) T { return T(x) }
func _[X constraints.Integer|~[]byte|~[]rune, T ~string](x X) T { return T(x) }
func _[X constraints.Integer|~[]byte|~[]rune, T ~*string](x X) T { return T(x /* ERROR cannot convert */ ) }

// "x is a string and T is a slice of bytes or runes"

func _[T ~[]byte](x string) T { return T(x) }
func _[T ~[]rune](x string) T { return T(x) }
func _[T ~[]rune](x *string) T { return T(x /* ERROR cannot convert */ ) }

func _[X ~string, T ~[]byte](x X) T { return T(x) }
func _[X ~string, T ~[]rune](x X) T { return T(x) }
func _[X ~string, T ~[]byte|~[]rune](x X) T { return T(x) }
func _[X ~*string, T ~[]byte|~[]rune](x X) T { return T(x /* ERROR cannot convert */ ) }

// package unsafe:
// "any pointer or value of underlying type uintptr can be converted into a unsafe.Pointer"

type myUintptr uintptr

func _[X ~uintptr](x X) unsafe.Pointer { return unsafe.Pointer(x) }
func _[T unsafe.Pointer](x myUintptr) T { return T(x) }
func _[T unsafe.Pointer](x int64) T { return T(x /* ERROR cannot convert */ ) }

// "and vice versa"

func _[T ~uintptr](x unsafe.Pointer) T { return T(x) }
func _[X unsafe.Pointer](x X) uintptr { return uintptr(x) }
func _[X unsafe.Pointer](x X) myUintptr { return myUintptr(x) }
func _[X unsafe.Pointer](x X) int64 { return int64(x /* ERROR cannot convert */ ) }

// "x is a slice, T is a pointer-to-array type,
// and the slice and array types have identical element types."

func _[X ~[]E, T ~*[10]E, E any](x X) T { return T(x) }
func _[X ~[]E, T ~[10]E, E any](x X) T { return T(x /* ERROR cannot convert */ ) }
