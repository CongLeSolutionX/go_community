// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// A note on line numbers: when working with line numbers, we always use the
// binary-visible relative line number. i.e., the line number as adjusted by
// //line directives (ctxt.InnermostPos(ir.Node.Pos()).RelLine()). Use
// NodeLineOffset to compute line offsets.
//
// If you are thinking, "wait, doesn't that just make things more complex than
// using the real line number?", then you are 100% correct. Unfortunately,
// pprof profiles generated by the runtime always contain line numbers as
// adjusted by //line directives (because that is what we put in pclntab). Thus
// for the best behavior when attempting to match the source with the profile
// it makes sense to use the same line number space.
//
// Some of the effects of this to keep in mind:
//
//  - For files without //line directives there is no impact, as RelLine() ==
//    Line().
//  - For functions entirely covered by the same //line directive (i.e., a
//    directive before the function definition and no directives within the
//    function), there should also be no impact, as line offsets within the
//    function should be the same as the real line offsets.
//  - Functions containing //line directives may be impacted. As fake line
//    numbers need not be monotonic, we may compute negative line offsets. We
//    should accept these and attempt to use them for best-effort matching, as
//    these offsets should still match if the source is unchanged, and may
//    continue to match with changed source depending on the impact of the
//    changes on fake line numbers.
//  - Functions containing //line directives may also contain duplicate lines,
//    making it ambiguous which call the profile is referencing. This is a
//    similar problem to multiple calls on a single real line, as we don't
//    currently track column numbers.
//
// Long term it would be best to extend pprof profiles to include real line
// numbers. Until then, we have to live with these complexities. Luckily,
// //line directives that change line numbers in strange ways should be rare,
// and failing PGO matching on these files is not too big of a loss.

package pgo

import (
	"cmd/compile/internal/base"
	"cmd/compile/internal/ir"
	"cmd/compile/internal/pgo/internal/graph"
	"cmd/compile/internal/typecheck"
	"cmd/compile/internal/types"
	"fmt"
	"internal/profile"
	"os"
)

// IRGraph is a call graph with nodes pointing to IRs of functions and edges
// carrying weights and callsite information.
//
// The graph is bidirectional which helps in adding and removing nodes
// efficiently.
//
// Nodes for indirect calls may have missing IR (IRNode.AST == nil) if the node
// is not visible from this package (e.g., not in the transitive deps). Keeping
// these nodes allows determining the hottest edge from a call even if that
// callee is not available.
//
// TODO(prattmic): Consider merging this data structure with Graph. This is
// effectively a copy of Graph aggregated to line number and pointing to IR.
type IRGraph struct {
	// Nodes of the graph
	IRNodes  map[string]*IRNode
	OutEdges IREdgeMap
	InEdges  IREdgeMap
}

// IRNode represents a node (function) in the IRGraph.
type IRNode struct {
	// Pointer to the IR of the Function represented by this node.
	AST *ir.Func
	// Symbol name of the Function represented by this node. Populated only
	// if AST == nil.
	SymbolName string
	// Flat weight of the IRNode, obtained from profile.
	Flat int64
	// Cumulative weight of the IRNode.
	Cum int64
}

// Name returns the symbol name of this function.
func (i *IRNode) Name() string {
	if i.AST != nil {
		return ir.LinkFuncName(i.AST)
	}
	return i.SymbolName
}

// IREdgeMap maps an IRNode to its successors.
type IREdgeMap map[*IRNode][]*IREdge

// IREdge represents a call edge in the IRGraph with source, destination,
// weight, callsite, and line number information.
type IREdge struct {
	// Source and destination of the edge in IRNode.
	Src, Dst       *IRNode
	Weight         int64
	CallSiteOffset int // Line offset from function start line.
}

// NodeMapKey represents a hash key to identify unique call-edges in profile
// and in IR. Used for deduplication of call edges found in profile.
type NodeMapKey struct {
	CallerName     string
	CalleeName     string
	CallSiteOffset int // Line offset from function start line.
}

// Weights capture both node weight and edge weight.
type Weights struct {
	NFlat   int64
	NCum    int64
	EWeight int64
}

// CallSiteInfo captures call-site information and its caller/callee.
type CallSiteInfo struct {
	LineOffset int // Line offset from function start line.
	Caller     *ir.Func
	Callee     *ir.Func
}

// IfaceInfo captures interface method call-site information.
type IfaceInfo struct {
	CallerName     string
	CallSiteOffset int // Line offset from function start line.
}

// CalleeInfo stores the sole hot-callee and its frequency. It also contains additional callee targets in CalleeMap.
type CalleeInfo struct {
	HotCallee     string
	HotCalleeFreq int64
	// CalleeMap stores all callees recorded in profile, for a given interface method call.
	CalleeMap map[string]int64
}

// Profile contains the processed PGO profile and weighted call graph used for
// PGO optimizations.
type Profile struct {
	// Aggregated NodeWeights and EdgeWeights across the profile. This
	// helps us determine the percentage threshold for hot/cold
	// partitioning.
	TotalNodeWeight int64
	TotalEdgeWeight int64

	// NodeMap contains all unique call-edges in the profile and their
	// aggregated weight.
	NodeMap map[NodeMapKey]*Weights

	// WeightedCG represents the IRGraph built from profile, which we will
	// update as part of inlining.
	WeightedCG *IRGraph
}

type CallStat struct {
	Pkg string
	Pos string

	Caller string

	// Call type. Interface must not be Direct.
	Direct    bool
	Interface bool

	Weight int64

	Hottest       string
	HottestWeight int64

	// Specialized callee if != "".
	//
	// Note that this may be different than Hottest because we apply
	// type-check restrictions, which helps distinguish multiple calls on
	// the same line. Hottest doesn't do that.
	Specialized       string
	SpecializedWeight int64
}

// New generates a profile-graph from the profile.
func New(profileFile string) (*Profile, error) {
	f, err := os.Open(profileFile)
	if err != nil {
		return nil, fmt.Errorf("error opening profile: %w", err)
	}
	defer f.Close()
	profile, err := profile.Parse(f)
	if err != nil {
		return nil, fmt.Errorf("error parsing profile: %w", err)
	}

	if len(profile.Sample) == 0 {
		// We accept empty profiles, but there is nothing to do.
		return nil, nil
	}

	valueIndex := -1
	for i, s := range profile.SampleType {
		// Samples count is the raw data collected, and CPU nanoseconds is just
		// a scaled version of it, so either one we can find is fine.
		if (s.Type == "samples" && s.Unit == "count") ||
		(s.Type == "cpu" && s.Unit == "nanoseconds") {
			valueIndex = i
			break
		}
	}

	if valueIndex == -1 {
		return nil, fmt.Errorf(`profile does not contain a sample index with value/type "samples/count" or cpu/nanoseconds"`)
	}

	g := graph.NewGraph(profile, &graph.Options{
		SampleValue: func(v []int64) int64 { return v[valueIndex] },
	})

	p := &Profile{
		NodeMap:         make(map[NodeMapKey]*Weights),
		WeightedCG: &IRGraph{
			IRNodes: make(map[string]*IRNode),
		},
	}

	// Build the node map and totals from the profile graph.
	if err := p.processprofileGraph(g); err != nil {
		return nil, err
	}

	if p.TotalNodeWeight == 0 || p.TotalEdgeWeight == 0 {
		return nil, nil // accept but ignore profile with no samples.
	}

	// Create package-level call graph with weights from profile and IR.
	p.initializeIRGraph()

	return p, nil
}

// processprofileGraph builds various maps from the profile-graph.
//
// It initializes NodeMap and Total{Node,Edge}Weight based on the name and
// callsite to compute node and edge weights which will be used later on to
// create edges for WeightedCG.
//
// Caller should ignore the profile if p.TotalNodeWeight == 0 || p.TotalEdgeWeight == 0.
func (p *Profile) processprofileGraph(g *graph.Graph) error {
	nFlat := make(map[string]int64)
	nCum := make(map[string]int64)
	seenStartLine := false

	// Accummulate weights for the same node.
	for _, n := range g.Nodes {
		canonicalName := n.Info.Name
		nFlat[canonicalName] += n.FlatValue()
		nCum[canonicalName] += n.CumValue()
	}

	// Process graph and build various node and edge maps which will
	// be consumed by AST walk.
	for _, n := range g.Nodes {
		seenStartLine = seenStartLine || n.Info.StartLine != 0

		p.TotalNodeWeight += n.FlatValue()
		canonicalName := n.Info.Name
		// Create the key to the nodeMapKey.
		nodeinfo := NodeMapKey{
			CallerName:     canonicalName,
			CallSiteOffset: n.Info.Lineno - n.Info.StartLine,
		}

		for _, e := range n.Out {
			p.TotalEdgeWeight += e.WeightValue()
			nodeinfo.CalleeName = e.Dest.Info.Name
			if w, ok := p.NodeMap[nodeinfo]; ok {
				w.EWeight += e.WeightValue()
			} else {
				weights := new(Weights)
				weights.NFlat = nFlat[canonicalName]
				weights.NCum = nCum[canonicalName]
				weights.EWeight = e.WeightValue()
				p.NodeMap[nodeinfo] = weights
			}
		}
	}

	if p.TotalNodeWeight == 0 || p.TotalEdgeWeight == 0 {
		return nil // accept but ignore profile with no samples.
	}

	if !seenStartLine {
		// TODO(prattmic): If Function.start_line is missing we could
		// fall back to using absolute line numbers, which is better
		// than nothing.
		return fmt.Errorf("profile missing Function.start_line data (Go version of profiled application too old? Go 1.20+ automatically adds this to profiles)")
	}

	return nil
}

// initializeIRGraph builds the IRGraph by visiting all the ir.Func in decl list
// of a package.
func (p *Profile) initializeIRGraph() {
	// Bottomup walk over the function to create IRGraph.
	ir.VisitFuncsBottomUp(typecheck.Target.Decls, func(list []*ir.Func, recursive bool) {
		for _, n := range list {
			p.VisitIR(n)
		}
	})

	// Done second so that IRNodes is fully populated.
	ir.VisitFuncsBottomUp(typecheck.Target.Decls, func(list []*ir.Func, recursive bool) {
		for _, n := range list {
			p.VisitIndirect(n)
		}
	})
}

// VisitIR traverses the body of each ir.Func and use NodeMap to determine if
// we need to add an edge from ir.Func and any node in the ir.Func body.
func (p *Profile) VisitIR(fn *ir.Func) {
	g := p.WeightedCG

	if g.IRNodes == nil {
		g.IRNodes = make(map[string]*IRNode)
	}
	if g.OutEdges == nil {
		g.OutEdges = make(map[*IRNode][]*IREdge)
	}
	if g.InEdges == nil {
		g.InEdges = make(map[*IRNode][]*IREdge)
	}
	name := ir.LinkFuncName(fn)
	node := new(IRNode)
	node.AST = fn
	if g.IRNodes[name] == nil {
		g.IRNodes[name] = node
	}
	// Create the key for the NodeMapKey.
	nodeinfo := NodeMapKey{
		CallerName:     name,
		CalleeName:     "",
		CallSiteOffset: 0,
	}
	// If the node exists, then update its node weight.
	if weights, ok := p.NodeMap[nodeinfo]; ok {
		g.IRNodes[name].Flat = weights.NFlat
		g.IRNodes[name].Cum = weights.NCum
	}

	// Recursively walk over the body of the function to create IRGraph edges.
	p.createIRGraphEdge(fn, g.IRNodes[name], name)
}

// TODO: In Visit we use the direct calls discovered in the IR to build the
// WeightedCG. That is, we discover call edges from the IR and then add weights
// on the side via lookup from the profile.
//
// In VisitIndirect, we now extend the WeightedCG by adding additional edges
// visible in the profile that we did not discover from the IR. These should
// primarily be the indirect calls.
//
// This split approach is uneccesarily complicated. We could use the profile as
// the source of all edges. Any edges in the IR but not the profile are defined
// to have weight 0 anyway.
func (p *Profile) VisitIndirect(fn *ir.Func) {
	g := p.WeightedCG

	name := ir.LinkFuncName(fn)
	node := g.IRNodes[name]

	// Add partial in-edges, needed for indirect calls.
	// TODO: iterating the entire NodeMap for every function is extremely inefficient.
inedge:
	for key, weights := range p.NodeMap {
		if key.CalleeName != name {
			//fmt.Printf("%s != %s\n", key.CalleeName, name)
			continue
		}
		for _, e := range g.InEdges[node] {
			if e.Src == nil {
				panic("impossible for in-edge to be added to this function without a src ir.Func")
			}
			if e.Src.Name() != key.CallerName {
				continue
			}
			if e.CallSiteOffset != key.CallSiteOffset {
				continue
			}
			// Already handled this key.
			continue inedge
		}

		var callerNode *IRNode
		var ok bool
		callerNode, ok = g.IRNodes[key.CallerName]
		if !ok {
			// TODO: The IR might be there, but we've missing it in
			// VisitIR because it was never referenced directly.
			// Try to do a lookup.



			// TODO: record this call anyway. If this is the
			// hottest, then we want to skip specialization rather
			// than specializing to the second most common callee.
			//fmt.Printf("No node for %s in %s -> %s\n", key.CallerName, key.CallerName, name)
			callerNode = &IRNode{
				SymbolName: key.CallerName,
				// TODO: weights? We don't need them.
			}
			// N.B. used only for PrintWeightedCallGraphDOT.
			g.IRNodes[key.CallerName] = callerNode
		}
		edge := &IREdge{
			Src:            callerNode,
			Dst:            node,
			Weight:         weights.EWeight,
			CallSiteOffset: key.CallSiteOffset,
		}
		g.InEdges[node] = append(g.InEdges[node], edge)
		g.OutEdges[callerNode] = append(g.OutEdges[callerNode], edge)
	}

	// Add partial out-edges, needed for indirect calls.
outedge:
	for key, weights := range p.NodeMap {
		if key.CallerName != name {
			continue
		}

		if base.Debug.PGOInline >= 1 {
			fmt.Printf("NodeMap: %s (off %d) -> %s: weight %d\n", key.CallerName, key.CallSiteOffset, key.CalleeName, weights.EWeight)
		}

		for _, e := range g.OutEdges[node] {
			if e.Dst == nil {
				panic("impossible for out-edge to be added to this function without a dst ir.Func")
			}
			if e.Dst.Name() != key.CalleeName {
				continue
			}
			if e.CallSiteOffset != key.CallSiteOffset {
				continue
			}
			// Already handled this key.
			continue outedge
		}

		var calleeNode *IRNode
		var ok bool
		calleeNode, ok = g.IRNodes[key.CalleeName]
		if !ok {
			// TODO: The IR might be there, but we've missing it in
			// VisitIR because it was never referenced directly.
			// Try to do a lookup.

			// Record this call anyway. If this is the hottest,
			// then we want to skip specialization rather than
			// specializing to the second most common callee.
			calleeNode = &IRNode{
				SymbolName: key.CalleeName,
				// TODO: weights? We don't need them.
			}
			// N.B. used only for PrintWeightedCallGraphDOT.
			g.IRNodes[key.CalleeName] = calleeNode
		}
		edge := &IREdge{
			Src:            node,
			Dst:            calleeNode,
			Weight:         weights.EWeight,
			CallSiteOffset: key.CallSiteOffset,
		}
		g.OutEdges[node] = append(g.OutEdges[node], edge)
		g.InEdges[calleeNode] = append(g.InEdges[calleeNode], edge)
	}
}

// NodeLineOffset returns the line offset of n in fn.
func NodeLineOffset(n ir.Node, fn *ir.Func) int {
	// See "A note on line numbers" at the top of the file.
	line := int(base.Ctxt.InnermostPos(n.Pos()).RelLine())
	startLine := int(base.Ctxt.InnermostPos(fn.Pos()).RelLine())
	return line - startLine
}

// addIREdge adds an edge between caller and new node that points to `callee`
// based on the profile-graph and NodeMap.
func (p *Profile) addIREdge(caller *IRNode, callername string, call ir.Node, callee *ir.Func) {
	g := p.WeightedCG

	// Create an IRNode for the callee.
	calleenode := new(IRNode)
	calleenode.AST = callee
	calleename := ir.LinkFuncName(callee)

	// Create key for NodeMapKey.
	nodeinfo := NodeMapKey{
		CallerName:     callername,
		CalleeName:     calleename,
		CallSiteOffset: NodeLineOffset(call, caller.AST),
	}

	// Create the callee node with node weight.
	if g.IRNodes[calleename] == nil {
		g.IRNodes[calleename] = calleenode
		nodeinfo2 := NodeMapKey{
			CallerName:     calleename,
			CalleeName:     "",
			CallSiteOffset: 0,
		}
		if weights, ok := p.NodeMap[nodeinfo2]; ok {
			g.IRNodes[calleename].Flat = weights.NFlat
			g.IRNodes[calleename].Cum = weights.NCum
		}
	}

	if weights, ok := p.NodeMap[nodeinfo]; ok {
		caller.Flat = weights.NFlat
		caller.Cum = weights.NCum

		// Add edge in the IRGraph from caller to callee.
		info := &IREdge{Src: caller, Dst: g.IRNodes[calleename], Weight: weights.EWeight, CallSiteOffset: nodeinfo.CallSiteOffset}
		g.OutEdges[caller] = append(g.OutEdges[caller], info)
		g.InEdges[g.IRNodes[calleename]] = append(g.InEdges[g.IRNodes[calleename]], info)
	} else {
		nodeinfo.CalleeName = ""
		nodeinfo.CallSiteOffset = 0
		if weights, ok := p.NodeMap[nodeinfo]; ok {
			caller.Flat = weights.NFlat
			caller.Cum = weights.NCum
			info := &IREdge{Src: caller, Dst: g.IRNodes[calleename], Weight: 0, CallSiteOffset: nodeinfo.CallSiteOffset}
			g.OutEdges[caller] = append(g.OutEdges[caller], info)
			g.InEdges[g.IRNodes[calleename]] = append(g.InEdges[g.IRNodes[calleename]], info)
		} else {
			info := &IREdge{Src: caller, Dst: g.IRNodes[calleename], Weight: 0, CallSiteOffset: nodeinfo.CallSiteOffset}
			g.OutEdges[caller] = append(g.OutEdges[caller], info)
			g.InEdges[g.IRNodes[calleename]] = append(g.InEdges[g.IRNodes[calleename]], info)
		}
	}
}

// typeOfMethodParent returns the type containing method fn. Returns nil if fn
// is not a method.
func typeOfMethodParent(fn *ir.Func) *types.Type {
	recv := fn.Nname.Type().Recv()
	if recv == nil {
		return nil
	}
	return recv.Type
}

// interfaceCallType returns the type of the interface used in an interface
// call. Returns nil if call is not an interface call.
func interfaceCallType(n ir.Node) *types.Type {
	if n.Op() != ir.OCALLINTER {
		// TODO: return nil. For now, catch bugs.
		panic(fmt.Sprintf("unexpected call type: %+v", n))
	}

	call, ok := n.(*ir.CallExpr)
	if !ok {
		panic(fmt.Sprintf("OCALLINTER isn't CallExpr? %+v", n))
	}

	sel, ok := call.X.(*ir.SelectorExpr)
	if !ok {
		panic(fmt.Sprintf("OCALLINTER doesn't contain SelectorExpr? %+v", n))
	}

	return sel.X.Type()
}

// findHotConcreteCallee finds the concrete Func node for a callsite node in `call`.
func (p *Profile) findHotConcreteCallee(caller *ir.Func, call ir.Node) (*ir.Func, int64) {
	if _, ok := call.(*ir.CallExpr); !ok {
		panic(fmt.Sprintf("call isn't a call: %+v", call))
		return nil, 0
	}

	callerName := ir.LinkFuncName(caller)
	callerNode := p.WeightedCG.IRNodes[callerName]
	callOffset := NodeLineOffset(call, caller)

	inter := interfaceCallType(call)

	logf := func(s string, v ...interface{}) {
		if base.Debug.PGOInline >= 2 {
			fmt.Printf(s, v...)
		}
	}

	var hottest *ir.Func
	var hottestWeight int64

	for _, e := range p.WeightedCG.OutEdges[callerNode] {
		logf("%s: Consider %s\n", base.FmtPos(call.Pos()), e.Dst.Name())

		if e.CallSiteOffset != callOffset {
			logf("wrong offset\n")
			continue
		}

		if e.Weight <= hottestWeight {
			// TODO: make sure sort order if fully deterministic so
			// we always pick the same callee if there are equal
			// weights.
			// TODO: consider total caller weight? i.e., if the
			// hottest callee is only 10% of the weight, maybe
			// don't specialize?
			logf("\ttoo cold\n")
			continue
		}

		if e.Dst.AST == nil {
			// Destination isn't visible from this package
			// compilation.
			//
			// We must assume it implements the interface.
			logf("\tmissing IR\n")
			continue
		}

		ctyp := typeOfMethodParent(e.Dst.AST)
		if ctyp == nil {
			// Not a method.
			// TODO: Support non-interface indirect calls.
			logf("dst not a method\n")
			continue
		}

		// If ctyp doesn't implement inter it is most likely from a
		// different call on the same line
		op, _ := typecheck.Assignop(ctyp, inter)
		if op == ir.OXXX {
			// TODO: this is overly strict. Consider if ctyp is a
			// partial implementation of an interface that gets
			// embedded in types that complete the interface. It
			// would still be OK to specialize a call to this
			// method.
			//
			// What we'd need to do is check that the function
			// pointer in the itab matches the method we want,
			// rather than doing a full type assertion.
			logf("\tdoesn't implement interface\n")
			continue
		}

		logf("\taccept as hottest\n")
		hottest = e.Dst.AST
		hottestWeight = e.Weight
	}

	return hottest, hottestWeight
}

// createIRGraphEdge traverses the nodes in the body of ir.Func and adds edges between the callernode which points to the ir.Func and the nodes in the body.
func (p *Profile) createIRGraphEdge(fn *ir.Func, callernode *IRNode, name string) {
	ir.VisitList(fn.Body, func(n ir.Node) {
		switch n.Op() {
		case ir.OCALLFUNC:
			call := n.(*ir.CallExpr)
			// Find the callee function from the call site and add the edge.
			callee := inlCallee(call.X)
			if callee != nil {
				p.addIREdge(callernode, name, n, callee)
			}
		case ir.OCALLMETH:
			call := n.(*ir.CallExpr)
			// Find the callee method from the call site and add the edge.
			callee := ir.MethodExprName(call.X).Func
			p.addIREdge(callernode, name, n, callee)
		}
	})
}

// WeightInPercentage converts profile weights to a percentage.
func WeightInPercentage(value int64, total int64) float64 {
	return (float64(value) / float64(total)) * 100
}

// PrintWeightedCallGraphDOT prints IRGraph in DOT format.
func (p *Profile) PrintWeightedCallGraphDOT(edgeThreshold float64) {
	fmt.Printf("\ndigraph G {\n")
	fmt.Printf("forcelabels=true;\n")

	// List of functions in this package.
	funcs := make(map[string]struct{})
	ir.VisitFuncsBottomUp(typecheck.Target.Decls, func(list []*ir.Func, recursive bool) {
		for _, f := range list {
			name := ir.LinkFuncName(f)
			funcs[name] = struct{}{}
		}
	})

	// Determine nodes of DOT.
	//
	// Note that ir.Func may be nil for functions not visible from this
	// package.
	nodes := make(map[string]*ir.Func)
	for name := range funcs {
		if n, ok := p.WeightedCG.IRNodes[name]; ok {
			for _, e := range p.WeightedCG.OutEdges[n] {
				if _, ok := nodes[e.Src.Name()]; !ok {
					nodes[e.Src.Name()] = e.Src.AST
				}
				if _, ok := nodes[e.Dst.Name()]; !ok {
					nodes[e.Dst.Name()] = e.Dst.AST
				}
			}
			if _, ok := nodes[n.Name()]; !ok {
				nodes[n.Name()] = n.AST
			}
		}
	}

	// Print nodes.
	for name, ast := range nodes {
		if n, ok := p.WeightedCG.IRNodes[name]; ok {
			nodeweight := WeightInPercentage(n.Flat, p.TotalNodeWeight)
			style := "solid"
			if ast == nil {
				// TODO: nodeweight will be zero due to TODO in VisitIndirect.
				style = "dashed"
			}

			if ast != nil && ast.Inl != nil {
				fmt.Printf("\"%v\" [color=black, style=%s, label=\"%v,freq=%.2f,inl_cost=%d\"];\n", name, style, name, nodeweight, ast.Inl.Cost)
			} else {
				fmt.Printf("\"%v\" [color=black, style=%s, label=\"%v,freq=%.2f\"];\n", name, style, name, nodeweight)
			}
		}
	}
	// Print edges.
	ir.VisitFuncsBottomUp(typecheck.Target.Decls, func(list []*ir.Func, recursive bool) {
		for _, f := range list {
			name := ir.LinkFuncName(f)
			if n, ok := p.WeightedCG.IRNodes[name]; ok {
				for _, e := range p.WeightedCG.OutEdges[n] {
					style := "solid"
					if e.Dst.AST == nil {
						style = "dashed"
					}
					color := "black"
					edgepercent := WeightInPercentage(e.Weight, p.TotalEdgeWeight)
					if edgepercent > edgeThreshold {
						color = "red"
					}

					fmt.Printf("edge [color=%s, style=%s];\n", color, style)
					fmt.Printf("\"%v\" -> \"%v\" [label=\"%.2f\"];\n", n.Name(), e.Dst.Name(), edgepercent)
				}
			}
		}
	})
	fmt.Printf("}\n")
}

// RedirectEdges deletes and redirects out-edges from node cur based on
// inlining information via inlinedCallSites.
//
// CallSiteInfo.Callee must be nil.
func (p *Profile) RedirectEdges(cur *IRNode, inlinedCallSites map[CallSiteInfo]struct{}) {
	g := p.WeightedCG

	i := 0
	outs := g.OutEdges[cur]
	for i < len(outs) {
		outEdge := outs[i]
		redirected := false
		_, found := inlinedCallSites[CallSiteInfo{LineOffset: outEdge.CallSiteOffset, Caller: cur.AST}]
		if !found {
			for _, InEdge := range g.InEdges[cur] {
				if _, ok := inlinedCallSites[CallSiteInfo{LineOffset: InEdge.CallSiteOffset, Caller: InEdge.Src.AST}]; ok {
					weight := g.calculateWeight(InEdge.Src, cur)
					g.redirectEdge(InEdge.Src, outEdge, weight)
					redirected = true
				}
			}
		}
		if found || redirected {
			g.remove(cur, i)
			outs = g.OutEdges[cur]
			continue
		}
		i++
	}
}

// redirectEdge redirects a node's out-edge to one of its parent nodes, cloning is
// required as the node might be inlined in multiple call-sites.
// TODO: adjust the in-edges of outEdge.Dst if necessary
func (g *IRGraph) redirectEdge(parent *IRNode, outEdge *IREdge, weight int64) {
	edge := &IREdge{Src: parent, Dst: outEdge.Dst, Weight: weight * outEdge.Weight, CallSiteOffset: outEdge.CallSiteOffset}
	g.OutEdges[parent] = append(g.OutEdges[parent], edge)
}

// remove deletes the cur-node's out-edges at index idx.
func (g *IRGraph) remove(cur *IRNode, i int) {
	if len(g.OutEdges[cur]) >= 2 {
		g.OutEdges[cur][i] = g.OutEdges[cur][len(g.OutEdges[cur])-1]
		g.OutEdges[cur] = g.OutEdges[cur][:len(g.OutEdges[cur])-1]
	} else {
		delete(g.OutEdges, cur)
	}
}

// calculateWeight calculates the weight of the new redirected edge.
func (g *IRGraph) calculateWeight(parent *IRNode, cur *IRNode) int64 {
	sum := int64(0)
	pw := int64(0)
	for _, InEdge := range g.InEdges[cur] {
		sum += InEdge.Weight
		if InEdge.Src.Name() == parent.Name() {
			pw = InEdge.Weight
		}
	}
	weight := int64(0)
	if sum != 0 {
		weight = pw / sum
	} else {
		weight = pw
	}
	return weight
}

// inlCallee is same as the implementation for inl.go with one change. The change is that we do not invoke CanInline on a closure.
func inlCallee(fn ir.Node) *ir.Func {
	fn = ir.StaticValue(fn)
	switch fn.Op() {
	case ir.OMETHEXPR:
		fn := fn.(*ir.SelectorExpr)
		n := ir.MethodExprName(fn)
		// Check that receiver type matches fn.X.
		// TODO(mdempsky): Handle implicit dereference
		// of pointer receiver argument?
		if n == nil || !types.Identical(n.Type().Recv().Type, fn.X.Type()) {
			return nil
		}
		return n.Func
	case ir.ONAME:
		fn := fn.(*ir.Name)
		if fn.Class == ir.PFUNC {
			return fn.Func
		}
	case ir.OCLOSURE:
		fn := fn.(*ir.ClosureExpr)
		c := fn.Func
		return c
	}
	return nil
}
