// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	exec "internal/execabs"
	"log"
	"os"
	"regexp"
	"strings"
	"testing"
	"text/template"

	"cmd/go/internal/base"
)

func main() {
	if err := regenerate(); err != nil {
		log.Fatal(err)
	}
}

func regenerate() error {
	vetAnalyzers, err := testVetAnalyzers()
	if err != nil {
		return err
	}

	t := template.Must(template.New("fileTemplate").Parse(fileTemplate))
	tData := map[string][]string{
		"testFlags":    testFlags(),
		"vetAnalyzers": vetAnalyzers,
	}
	buf := bytes.NewBuffer(nil)
	if err := t.Execute(buf, tData); err != nil {
		return err
	}

	f, err := os.Create("flagdefs.go")
	if err != nil {
		return err
	}

	cmd := exec.Command("gofmt")
	cmd.Stdin = buf
	cmd.Stdout = f
	cmd.Stderr = os.Stderr
	cmdErr := cmd.Run()

	if err := f.Close(); err != nil {
		return err
	}
	if cmdErr != nil {
		os.Remove(f.Name())
		return cmdErr
	}

	return nil
}

func testFlags() []string {
	testing.Init()

	var names []string
	flag.VisitAll(func(f *flag.Flag) {
		if !strings.HasPrefix(f.Name, "test.") {
			return
		}
		name := strings.TrimPrefix(f.Name, "test.")

		switch name {
		case "testlogfile", "paniconexit0":
			// These flags are only for use by cmd/go.
		default:
			names = append(names, name)
		}
	})

	return names
}

// testVetAnalyzers computes vet-supported analyzers for go test vet=...
func testVetAnalyzers() ([]string, error) {
	// get supported vet flag information
	tool := base.Tool("vet")
	vetcmd := exec.Command(tool, "-flags")
	out := new(bytes.Buffer)
	vetcmd.Stdout = out
	if err := vetcmd.Run(); err != nil {
		return nil, fmt.Errorf("go vet: can't execute %s -flags: %v\n", tool, err)
	}
	var analysisFlags []struct {
		Name  string
		Bool  bool
		Usage string
	}
	if err := json.Unmarshal(out.Bytes(), &analysisFlags); err != nil {
		return nil, fmt.Errorf("go vet: can't unmarshal JSON from %s -flags: %v", tool, err)
	}

	// parse the flags to figure out which ones stand for analyses
	rEnable := regexp.MustCompile("^enable (?P<analyzer>(.+)) analysis$")
	rDeprecated := regexp.MustCompile("^deprecated alias for -(?P<analyzer>(.+))$")

	// Returns the <analyzer> match of rEnable and rDeprecated on input value.
	// If there is no match, "" is returned.
	analyzerMatch := func(value string) string {
		match := rEnable.FindStringSubmatch(value)
		for i, name := range rEnable.SubexpNames() {
			if name == "analyzer" && i < len(match) {
				return match[i]
			}
		}

		match = rDeprecated.FindStringSubmatch(value)
		for i, name := range rDeprecated.SubexpNames() {
			if name == "analyzer" && i < len(match) {
				return match[i]
			}
		}

		return ""
	}

	// set is used to collect analyzer names as parsing of "deprecated ..."
	// usage can yield an analyzer already appearing in "enable ..." usage.
	analyzerSet := make(map[string]bool)
	for _, flag := range analysisFlags {
		if a := analyzerMatch(flag.Usage); a != "" {
			analyzerSet[a] = true
		}
	}

	var analyzers []string
	for a := range analyzerSet {
		analyzers = append(analyzers, a)
	}
	return analyzers, nil
}

const fileTemplate = `// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by genflags.go â€” DO NOT EDIT.

package test

// passFlagToTest contains the flags that should be forwarded to
// the test binary with the prefix "test.".
var passFlagToTest = map[string]bool {
{{- range .testFlags}}
	"{{.}}": true,
{{- end }}
}

var passAnalyzersToVet = map[string]bool {
{{- range .vetAnalyzers}}
	"{{.}}": true,
{{- end }}
}
`
