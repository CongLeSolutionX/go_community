# Test that when the coordinator experiences an I/O error communicating
# with a worker, the coordinator stops the worker and reports the error.
# The coordinator should not record a crasher.
#
# We simulate an I/O error by closing the fuzz_in / fuzz_out pipe that
# the coordinator and worker use for RPCs.
# TODO(jayconrod): test on Windows, too.
[short] skip
[!darwin] [!linux] skip

# If the I/O error occurs before F.Fuzz is called, the coordinator should
# stop the worker and say that.
! go test -fuzz=FuzzClosePipeBefore
stdout '^\s*worker terminated without fuzzing$'
! stdout 'communicating with worker: EOF'
! exists testdata

# If the I/O error occurs after F.Fuzz is called (unlikely), just exit.
# It's hard to distinguish this case from the worker being interrupted by ^C
# or exiting with status 0 (which it should do when interrupted by ^C).
go test -fuzz=FuzzClosePipeAfter

-- go.mod --
module test

go 1.17
-- close_pipe_test.go --
package close_pipe

import (
	"flag"
	"syscall"
	"testing"
	"time"
)

func isWorker() bool {
	f := flag.Lookup("test.fuzzworker")
	if f == nil {
		return false
	}
	get, ok := f.Value.(flag.Getter)
	if !ok {
		return false
	}
	return get.Get() == interface{}(true)
}

func closePipeAndWait() {
	syscall.Close(3)
	syscall.Close(4)
	time.Sleep(3600 * time.Second) // pause until coordinator terminates the process
}

func FuzzClosePipeBefore(f *testing.F) {
	if isWorker() {
		closePipeAndWait()
	}
	f.Fuzz(func(*testing.T, []byte) {})
}

func FuzzClosePipeAfter(f *testing.F) {
	f.Fuzz(func(*testing.T, []byte) {
		if isWorker() {
			closePipeAndWait()
		}
	})
}
