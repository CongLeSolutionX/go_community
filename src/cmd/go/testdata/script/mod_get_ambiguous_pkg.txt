# Both example.net/ambiguous v0.1.0 and example.net/ambiguous/pkg v0.1.0 exist.
# 'go mod tidy' would arbitrarily choose the one with the longer path,
# but 'go mod tidy' also arbitrarily chooses the latest version.

cp go.mod go.mod.orig


# From a clean slate, 'go get' currently does the same thing as 'go mod tidy':
# it resolves the package from the module with the longest matching prefix.

go get -d example.net/ambiguous/nested/pkg@v0.1.0
go list -m all

stdout '^example.net/ambiguous/nested v0.1.0$'
! stdout '^example.net/ambiguous '


# From an initial state that already depends on the shorter path,
# the same 'go get' command attempts to add the longer path and fails.
#
# TODO(bcmills): What should really happen here?
# Should we match the versioned package path against the existing package
# (reducing unexpected errors), or give it the same meaning regardless of the
# initial state?

cp go.mod.orig go.mod
go mod edit -require=example.net/ambiguous@v0.1.0

! go get -d example.net/ambiguous/nested/pkg@v0.1.0
stderr '^go get example.net/ambiguous/nested/pkg@v0.1.0: ambiguous import: found package example.net/ambiguous/nested/pkg in multiple modules:\n\texample.net/ambiguous v0.1.0 \(.*\)\n\texample.net/ambiguous/nested v0.1.0 \(.*\)\n\z'


# In contrast, if we do the same thing tacking a wildcard pattern ('/...') on
# the end of the package path, we get different behaviors depending on the
# initial state, and no error. (This seems to contradict the “same meaning
# regardless of the initial state” point above.)

cp go.mod.orig go.mod

go get -d example.net/ambiguous/nested/pkg/...@v0.1.0
go list -m all

stdout '^example.net/ambiguous/nested v0.1.0$'
! stdout '^example.net/ambiguous '


cp go.mod.orig go.mod
go mod edit -require=example.net/ambiguous@v0.1.0

go get -d example.net/ambiguous/nested/pkg/...@v0.1.0
go list -m all

! stdout '^example.net/ambiguous/nested '
stdout '^example.net/ambiguous v0.1.0$'


-- go.mod --
module test

go 1.16
