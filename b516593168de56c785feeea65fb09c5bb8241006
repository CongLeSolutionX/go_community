{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f5e5f073_38ba0df9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-03-10T01:23:52Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003db5165931",
      "tag": "autogenerated:trybots~beginning",
      "revId": "b516593168de56c785feeea65fb09c5bb8241006",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2fad4498_6325584b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-03-10T01:36:09Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "f5e5f073_38ba0df9",
      "tag": "autogenerated:trybots~happy",
      "revId": "b516593168de56c785feeea65fb09c5bb8241006",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c07bbd01_82f2657c",
        "filename": "src/reflect/value.go",
        "patchSetId": 5
      },
      "lineNbr": 2659,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-04-01T00:43:07Z",
      "side": 1,
      "message": "I think using growslice directly here has a subtle problem. In growslice, we do:\n\n\tif et.ptrdata \u003d\u003d 0 {\n\t\tp \u003d mallocgc(capmem, nil, false)\n\t\t// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).\n\t\t// Only clear the part that will not be overwritten.\n\t\tmemclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\n\nSo, growslice doesn\u0027t actually erase between oldlen and newlen (for allocations of pointerless data). That\u0027s ok for when the compiler calls it, because it can guarantee that it will initialize that data. But here we expect the user to do the initialization. But a sneaky user can observe uninitialized data there if they try, I think.\n\nI think we need a safer wrapper in the runtime for reflect to use.\n\n(Note that this isn\u0027t a problem with the calls from Append/AppendSlice via extendSlice. Only from Grow. Maybe Grow can do the zeroing after calling grow? It is subtle, though, and I\u0027d like to avoid subtlety like this.)",
      "revId": "b516593168de56c785feeea65fb09c5bb8241006",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "139a2f1c_d1f4f3f4",
        "filename": "src/reflect/value.go",
        "patchSetId": 5
      },
      "lineNbr": 2678,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-04-01T00:43:07Z",
      "side": 1,
      "message": "Just s.Len +\u003d n?",
      "range": {
        "startLine": 2678,
        "startChar": 1,
        "endLine": 2678,
        "endChar": 34
      },
      "revId": "b516593168de56c785feeea65fb09c5bb8241006",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}