{
  "comments": [
    {
      "key": {
        "uuid": "7c365bfb_107f96b3",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 8470
      },
      "writtenOn": "2017-05-17T09:09:26Z",
      "side": 1,
      "message": "I added these here because on my Goobuntu workstation, linux-libc-dev is too old to contain them, hence mkerrors.sh doesn’t pick them up. Will mkerrors eventually use the same Docker-based technique that x/sys uses now?",
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93d54d26_43369d56",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 5206
      },
      "writtenOn": "2017-05-17T14:02:47Z",
      "side": 1,
      "message": "I would support that, but it seems low priority since the syscall package is frozen for most purposes (https://docs.google.com/document/d/1QXzI9I1pOfZPujQzxhyRy6EeHYTQitKKjHfpq0zpxZs/view).",
      "parentUuid": "7c365bfb_107f96b3",
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b81f0622_b02af694",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 8470
      },
      "writtenOn": "2017-05-17T14:17:56Z",
      "side": 1,
      "message": "That’s fair. I take it you’re okay with adding these constants here for now, then.",
      "parentUuid": "93d54d26_43369d56",
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4de2ccf4_d9155be7",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 108,
      "author": {
        "id": 8675
      },
      "writtenOn": "2017-05-31T22:33:00Z",
      "side": 1,
      "message": "It seems like this should at least be in the child so that we don\u0027t affect the calling thread\u0027s KEEPCAPS value. Should this be split out into another option (or be based on calling setuid)?",
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4a418f2_5c283a8e",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 108,
      "author": {
        "id": 8470
      },
      "writtenOn": "2017-06-02T08:50:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4de2ccf4_d9155be7",
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "52f6a8f0_143f7881",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 263,
      "author": {
        "id": 8675
      },
      "writtenOn": "2017-05-31T22:33:00Z",
      "side": 1,
      "message": "Why put this in the Credential check? For my use case (keeping capabilities in non-root-mapped user namespaces), I need to manipulate the ambient capability set even without calling setuid. (Though I also need to manipulate the inheritable capability set first, so if I continue down this path I\u0027ll send a separate CL)",
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8cad9f6_59c9d59d",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 263,
      "author": {
        "id": 8470
      },
      "writtenOn": "2017-06-02T08:50:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "52f6a8f0_143f7881",
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "557b3a05_f549acee",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 8675
      },
      "writtenOn": "2017-05-31T22:33:00Z",
      "side": 1,
      "message": "PR_CAP_AMBIENT_RAISE takes a single capability number, not a multiple capabilities. Can we make this a loop so that more than one capability can be set? The current capget/capset implementations use 64-bit (2x32-bit) masks, so it would be feasible to take uint64 and walk the set bits, but iterating over a slice matches this interface better.",
      "range": {
        "startLine": 264,
        "startChar": 3,
        "endLine": 264,
        "endChar": 110
      },
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2fe6ffa_5b4c45b9",
        "filename": "src/syscall/exec_linux.go",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 8470
      },
      "writtenOn": "2017-06-02T08:50:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "557b3a05_f549acee",
      "range": {
        "startLine": 264,
        "startChar": 3,
        "endLine": 264,
        "endChar": 110
      },
      "revId": "5289d3e4954f19d1404796499d264613afc73385",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}