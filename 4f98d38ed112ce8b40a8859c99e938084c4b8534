{
  "comments": [
    {
      "key": {
        "uuid": "4877ec0e_460452b3",
        "filename": "src/runtime/append_test.go",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 5846
      },
      "writtenOn": "2016-04-19T17:27:41Z",
      "side": 1,
      "message": "This tests the same elem size in a loop. I think a better benchmark would test a mix of cases that cant be predicted in a window of 16 values to test a possible worst case for branch missprediction.",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08b6d404_e28a420f",
        "filename": "src/runtime/append_test.go",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 5143
      },
      "writtenOn": "2016-04-19T19:55:34Z",
      "side": 1,
      "message": "My experience is that in benchmarks like this, random number generation ends up costing more than everything else. :) I added an unpredictable case that cycles through, though, which should make the sole remaining branch (with the lookup table) hard to predict. I also reduced the number of cases.",
      "parentUuid": "4877ec0e_460452b3",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4877ec0e_86ed6a1a",
        "filename": "src/runtime/malloc.go",
        "patchSetId": 1
      },
      "lineNbr": 795,
      "author": {
        "id": 5846
      },
      "writtenOn": "2016-04-19T17:27:41Z",
      "side": 1,
      "message": "is typ.size needed here? if typ.size \u003d\u003d 0 then maxSliceElem returns maximum uintptr which fails n \u003e maxuintptr automatically. This could save a compare and branch for some common cases.",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4877ec0e_66222e3c",
        "filename": "src/runtime/malloc.go",
        "patchSetId": 1
      },
      "lineNbr": 795,
      "author": {
        "id": 5846
      },
      "writtenOn": "2016-04-19T17:30:12Z",
      "side": 1,
      "message": "i meant typ.size \u003e 0",
      "parentUuid": "4877ec0e_86ed6a1a",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08b6d404_4252165b",
        "filename": "src/runtime/malloc.go",
        "patchSetId": 1
      },
      "lineNbr": 795,
      "author": {
        "id": 5143
      },
      "writtenOn": "2016-04-19T19:55:34Z",
      "side": 1,
      "message": "Removed!",
      "parentUuid": "4877ec0e_66222e3c",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08b6d404_1cbeb57f",
        "filename": "src/runtime/slice.go",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 5200
      },
      "writtenOn": "2016-04-19T17:43:17Z",
      "side": 1,
      "message": "Would a table lookup be faster?  You could do all sizes \u003c 32 with a 256-byte table.",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4877ec0e_26d1164a",
        "filename": "src/runtime/slice.go",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 5846
      },
      "writtenOn": "2016-04-19T18:05:57Z",
      "side": 1,
      "message": "good point. The instruction code size of the switch is also not tiny. In this view the lookup table seems an ok tradeoff cache wise too.",
      "parentUuid": "08b6d404_1cbeb57f",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08b6d404_22f6eaa0",
        "filename": "src/runtime/slice.go",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 5143
      },
      "writtenOn": "2016-04-19T19:55:34Z",
      "side": 1,
      "message": "Lovely. Thanks. Done.",
      "parentUuid": "4877ec0e_26d1164a",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08989484_6c5a1bfd",
        "filename": "src/runtime/slice.go",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 5846
      },
      "writtenOn": "2016-04-19T17:27:41Z",
      "side": 1,
      "message": "since _MaxMem is const maybe do a / for consistency and let the compiler do its \"magic\"? (it should result in the same binary)",
      "revId": "4f98d38ed112ce8b40a8859c99e938084c4b8534",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}