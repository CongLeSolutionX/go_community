{
  "comments": [
    {
      "key": {
        "uuid": "0efc1c7c_cf1fa150",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 5167
      },
      "writtenOn": "2016-04-05T14:39:05Z",
      "side": 1,
      "message": "I\u0027m a little surprised that casgstatus waits for a long time. Do you happen to know what it\u0027s waiting on? We may be able to make algorithmic improvements here.",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8e3accf4_a38c0466",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 5400
      },
      "writtenOn": "2016-04-05T18:55:56Z",
      "side": 1,
      "message": "No, I did not look. Probably it\u0027s growing/scanning stack.",
      "parentUuid": "0efc1c7c_cf1fa150",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0efc1c7c_aff5f532",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 130,
      "author": {
        "id": 5167
      },
      "writtenOn": "2016-04-05T14:39:05Z",
      "side": 1,
      "message": "The spin wait in scang has worried me for a while. It\u0027s interesting to see that its effect can be elucidated by the http benchmark.\n\nThere\u0027s actually a TODO in markroot suggesting fixing this with two passes where the first is non-blocking and the second is blocking, though obviously this could still spin. That may be an easy first step, though.\n\nI think the tricky bit is dealing the _Grunning/preempt race. A while ago I prototyped something that, rather than signaling individual goroutines to scan their stacks, would increment a single, global generation counter while the world was stopped at the beginning of GC. Then, if a goroutine saw its own scan generation was behind the global generation, it was responsible for fixing that. If we do this right, we could set it up so that no goroutine can enter _Grunning without first scanning its stack to catch up to the global generation. If we count these as \"mark jobs\", then concurrent mark simply won\u0027t end until all of the stacks have been scanned.",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ec48060_fb2967c7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 130,
      "author": {
        "id": 5400
      },
      "writtenOn": "2016-04-05T18:55:56Z",
      "side": 1,
      "message": "What you describe sounds much better than tuning unproductive waits.\n\nMy original idea was to synchronize via g.status. Namely, if we need to scan a stack but the goroutine is running, we merely note this fact in status as Grunning|Gneedscan, issue preemption request and return. When the goroutine calls into scheduler, it will notice the flag and scan own stack.\nIf we are scanning a stack of a blocked goroutine, but another goroutine want to make it runnable, it notices the conflict and CASes g.status from Gblocked|Gscanning to Gunblocked|Gscanning. When the scan finishes, we notice the flag and queue the goroutine for execution.\nThis entirely eliminates both scang and casgstatus waits. Instead we pass the responsibility to do the required action to the other thread.",
      "parentUuid": "0efc1c7c_aff5f532",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0efc1c7c_6f02eda6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 130,
      "author": {
        "id": 5167
      },
      "writtenOn": "2016-04-05T19:09:38Z",
      "side": 1,
      "message": "Interesting. I think I like my approach to scang better than further complicating the G state machine, but I like your idea of fixing the casgstatus spin by making it encode the desired transition in the status and return immediately, letting the scan complete the transition when it finishes. I don\u0027t think this is feasible for all transitions; for example if a G in _Grunnable|_Gscan reaches the head of a run queue, I don\u0027t know what it would mean for the scan to complete the _Grunnable-\u003e_Grunning transition later. But in that case the scheduler could just kick the goroutine to the end of the run queue or something.",
      "parentUuid": "2ec48060_fb2967c7",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0efc1c7c_4f6611f6",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 811,
      "author": {
        "id": 5186
      },
      "writtenOn": "2016-04-05T12:13:53Z",
      "side": 1,
      "message": "Why the break loop here instead of a simple break?",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ec48060_18bd492c",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 811,
      "author": {
        "id": 5400
      },
      "writtenOn": "2016-04-05T12:51:18Z",
      "side": 1,
      "message": "Simple break would cause an additional, unnecessary yield after the switch (break would break from the switch, not from the for).",
      "parentUuid": "0efc1c7c_4f6611f6",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0efc1c7c_6f566d05",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 811,
      "author": {
        "id": 5186
      },
      "writtenOn": "2016-04-05T13:37:27Z",
      "side": 1,
      "message": "You\u0027re right. \nDone",
      "parentUuid": "2ec48060_18bd492c",
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0efc1c7c_af7a1586",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 858,
      "author": {
        "id": 5186
      },
      "writtenOn": "2016-04-05T12:13:53Z",
      "side": 1,
      "message": "Again why not \nfor x :\u003d 0; x \u003c 10 \u0026\u0026 !gp.gcscandone; x++ {\n    procyield(1)\n}\n\nIf we agree on this as the idiom for using PAUSE I\u0027ll put in a CL changing the other places in the code that pass procyield something besides 1.",
      "range": {
        "startLine": 858,
        "startChar": 3,
        "endLine": 858,
        "endChar": 16
      },
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6eb2f8f7_1a929979",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 858,
      "author": {
        "id": 5400
      },
      "writtenOn": "2016-04-05T12:58:33Z",
      "side": 1,
      "message": "Because we may need to make some actions depending on the status: scan stack or preempt. We could also check that status does not change, but then I am not sure whether it is correct for _Grunning (e.g. maybe we need to re-preempt again). It is subtle, and exact value of procyield does not matter here.\n\nAnd, no, don\u0027t change all other places. The most important one is mutex, and there we actually need to back off from the shared state for longer. Even loading the mutex state will cause cache coherence traffic.",
      "parentUuid": "0efc1c7c_af7a1586",
      "range": {
        "startLine": 858,
        "startChar": 3,
        "endLine": 858,
        "endChar": 16
      },
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0efc1c7c_cf46814c",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 858,
      "author": {
        "id": 5186
      },
      "writtenOn": "2016-04-05T13:37:27Z",
      "side": 1,
      "message": "OK, we can take up this discussion later. I have no numbers.",
      "parentUuid": "6eb2f8f7_1a929979",
      "range": {
        "startLine": 858,
        "startChar": 3,
        "endLine": 858,
        "endChar": 16
      },
      "revId": "32cc9d11ad710c503de4d19cdc4880c640c300a1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}