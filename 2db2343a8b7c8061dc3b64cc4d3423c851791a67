{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "48b98b85_f27d914b",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1098,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-03-21T00:33:52Z",
      "side": 1,
      "message": "If we\u0027re strictly following RFC 3986 Section 5.2.2, should this be merging `u.Path`/`u.Opaque` with `ref.Opaque`?\n\n(I\u0027m not sure, the relationship between Opaque and Path is confusing me.)",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79c76e19_10260631",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1098,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-03-21T22:55:04Z",
      "side": 1,
      "message": "So I thought that the reason behind having that check for the `ref.Opaque !\u003d \"\"` was that merging a `base.path` with `ref.Opaque` would always result in just the `ref.Opaque` and thus just reset the authority section and return, but that\u0027s not the case. If the base URL has an opaque value, that conclusion is correct, but if it has a path, then applying `resolvePath(base.path, ref.Opaque)`  results in the merge of the URL\u0027s (which seems to be according to spec).\nThat got me thinking that there\u0027s an issue with the `ref.Opaque !\u003d \"\"` condition, but then as I investigated/tested further I figured that for a URL to be parsed and store an opaque value, it needs to follow the template: `scheme:text` (where `text` will be parsed as opaque and can not include a \u0027/\u0027 at the beginning) as stated in the documentation for the URL class: https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#349\n\nSo, if the URL needs to have a scheme to have an opaque value, how wouldn\u0027t it enter the first condition ( `if ref.Scheme !\u003d \"\" || ref.Host !\u003d \"\" || ref.User !\u003d nil`)? If it enters that first condition, the behavior is according to spec, no problem, but if it doesn\u0027t then it won\u0027t have an opaque value, turning the `ref.Opaque !\u003d \"\"` condition obsolete.\nIf we parse something like \"`text`\", it will be treated as a path (inserting a \u0027/\u0027 before the text) and will fall back to the \"abs_path\" or \"rel_path\" cases, where the path will be handled correctly, merging `base.path/opaque` with `ref.Opaque` in `resolvePath(base, ref)`, [which will ignore the given base as the ref has a \u0027/\u0027 prefix](https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#1007), turning completely irrelevant what is passed for `base` (whether a path or opaque).\nI tried removing the `ref.Opaque !\u003d \"\"` condition and all the tests passed, so right now I\u0027m not sure if the condition just won\u0027t ever evaluate to true and so is irrelevant or if there exists another issue here.",
      "parentUuid": "48b98b85_f27d914b",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55252b1b_96b1e17d",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1111,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-03-21T00:33:52Z",
      "side": 1,
      "message": "What about the case where `ref.Path !\u003d \"\" \u0026\u0026 u.Opaque !\u003d \"\"`?",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d334067c_83fceb72",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1111,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-03-21T22:55:04Z",
      "side": 1,
      "message": "Since the opaque is stored separately, if we reach the end of the funcion (the \"abs_path\" or \"rel_path\" cases), we know that the ref doesn\u0027t have an opaque value (either because we entered the `ref.Opaque !\u003d \"\"` condition or because for it to have an opaque value it needs a scheme and so entered that first condition mentioned previously: `if ref.Scheme !\u003d \"\" || ref.Host !\u003d \"\" || ref.User !\u003d nil` ), so if its path is `!\u003d \"\"` (and a path in the URI class starts with a \u0027/\u0027) the corresponding pseudocode that would be executed is: \n```\nif (R.path starts-with \"/\") then\n  T.path \u003d remove_dot_segments(R.path);\n``` \nIn the current implementation, the final path will be `resolvePath(u.EscapedPath(), ref.EscapedPath())`, which should return what would be expected from the `remove_dot_segments(R.path)` call in the pseudocode (and from my understanding of the function and testing, it does), independently if the base URL has an opaque or not (since only the `R.path` should be taken into account here), because otherwise this general case (when `R.scheme \u003d\u003d \"\" \u0026\u0026 R.Authority \u003d\u003d \"\" \u0026\u0026 R.path !\u003d \"\"`) is not according to the spec and there\u0027s another issue here (not related with the opaque issue).",
      "parentUuid": "55252b1b_96b1e17d",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "876a6fae_48c130fa",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-03-22T17:50:00Z",
      "side": 1,
      "message": "Some additional cases:\n\n```\n        {\"http:opaque\", \"g\", \"http:opaque/g\"},\n        {\"http:opaque\", \".\", \"http:opaque\"},\n        {\"http:opaque\", \"..\", \"http:\"},\n        {\"http:opaque?p\", \"g?q\", \"http:opaque/g?q\"},\n        {\"http:a/./b\", \"c\", \"http:a/b/c\"},\n        {\"http:a/./b\", \"?q\", \"http:a/b?q\"},\n```\n\nI think those expectations are correct; if so, the current code is mishandling these cases. But I might be wrong about the correct expected output.",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e136aab_d319c1e4",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-03-23T16:42:34Z",
      "side": 1,
      "message": "The first four cases all fall into the following pseudo algorithm case:\n```\nif (R.path starts-with \"/\") then\n  [...]\nelse  \u003c-- this case\n  T.path \u003d merge(Base.path, R.path);\n  T.path \u003d remove_dot_segments(T.path);\n```\nso the test cases should be as follows (current implementation results in side comment):\n```\n{\"http:opaque\", \"g\", \"http:g\"}, // \"http:///g\"\n{\"http:opaque\", \".\", \"http:\"}, // \"http:///\"\n{\"http:opaque\", \"..\", \"http:\"}, // \"http:///\"\n{\"http:opaque?p\", \"g?q\", \"http:g?q\"}, // \"http:///g?q\"\n```\nwhich are correctly being handled using `resolvePath(u.EscapedPath(), ref.EscapedPath())`, but all of them print an empty authority section \"//\", which seems related to [this issue](https://github.com/golang/go/issues/46059)\n\nFrom my interpretation of what an opaque value represents (which would be something that does not describe a path to a resource, not hierarchical, just a random sequence of characters), I don\u0027t think that the opaque value should be parsed (or merged with another path) in any way like a path is (for example removing dot segments as in the 5th and 6th provided test cases), especially given that we\u0027re storing the opaque separately from the path and [treating an opaque URL in a completely different way from an URL with a path](https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#349). With this in mind, I would suggest that the above four cases should just ignore the base opaque value (by setting the final path to `resolvePath(u.EscapedPath(), ref.EscapedPath())`, which is the current behavior), since that if the base opaque has a \u0027/\u0027 character and the `ref.path` doesn\u0027t start with one, then applying `resolvePath` to the base opaque and the ref path [would be merging part of the opaque with the ref path](https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#1005), and that\u0027s probably undesired given the way an opaque URL is treated here.\n\nThe fix I proposed is for the case where the reference doesn\u0027t have a scheme, an authority section, or a path and the base url is opaque. The result should be the base opaque proceeded by the reference fragment and/or query (if they exist) since that\u0027s the way an opaque URL is interpreted in this class, as I mentioned previously. The current implementation doesn\u0027t support this case as the opaque is stored separately and the \"abs_path\" or \"rel_path\" case will only take into account paths, thus the need for checking this specific case.",
      "parentUuid": "876a6fae_48c130fa",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}