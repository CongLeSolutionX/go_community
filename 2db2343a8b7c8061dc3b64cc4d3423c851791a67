{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3c1dd181_745826f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2024-05-21T22:46:39Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d2db2343a\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29c423cf_49459a71",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2024-05-21T22:52:27Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003d2db2343a\nFailed on (x/tools) linux-amd64: https://storage.googleapis.com/go-build-log/2db2343a/linux-amd64_1780a703.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "3c1dd181_745826f1",
      "tag": "autogenerated:trybots~progress",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48b98b85_f27d914b",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1098,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-03-21T00:33:52Z",
      "side": 1,
      "message": "If we\u0027re strictly following RFC 3986 Section 5.2.2, should this be merging `u.Path`/`u.Opaque` with `ref.Opaque`?\n\n(I\u0027m not sure, the relationship between Opaque and Path is confusing me.)",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79c76e19_10260631",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1098,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-03-21T22:55:04Z",
      "side": 1,
      "message": "So I thought that the reason behind having that check for the `ref.Opaque !\u003d \"\"` was that merging a `base.path` with `ref.Opaque` would always result in just the `ref.Opaque` and thus just reset the authority section and return, but that\u0027s not the case. If the base URL has an opaque value, that conclusion is correct, but if it has a path, then applying `resolvePath(base.path, ref.Opaque)`  results in the merge of the URL\u0027s (which seems to be according to spec).\nThat got me thinking that there\u0027s an issue with the `ref.Opaque !\u003d \"\"` condition, but then as I investigated/tested further I figured that for a URL to be parsed and store an opaque value, it needs to follow the template: `scheme:text` (where `text` will be parsed as opaque and can not include a \u0027/\u0027 at the beginning) as stated in the documentation for the URL class: https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#349\n\nSo, if the URL needs to have a scheme to have an opaque value, how wouldn\u0027t it enter the first condition ( `if ref.Scheme !\u003d \"\" || ref.Host !\u003d \"\" || ref.User !\u003d nil`)? If it enters that first condition, the behavior is according to spec, no problem, but if it doesn\u0027t then it won\u0027t have an opaque value, turning the `ref.Opaque !\u003d \"\"` condition obsolete.\nIf we parse something like \"`text`\", it will be treated as a path (inserting a \u0027/\u0027 before the text) and will fall back to the \"abs_path\" or \"rel_path\" cases, where the path will be handled correctly, merging `base.path/opaque` with `ref.Opaque` in `resolvePath(base, ref)`, [which will ignore the given base as the ref has a \u0027/\u0027 prefix](https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#1007), turning completely irrelevant what is passed for `base` (whether a path or opaque).\nI tried removing the `ref.Opaque !\u003d \"\"` condition and all the tests passed, so right now I\u0027m not sure if the condition just won\u0027t ever evaluate to true and so is irrelevant or if there exists another issue here.",
      "parentUuid": "48b98b85_f27d914b",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b05b4e0c_c7526fc0",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1098,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-05-21T22:47:16Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "79c76e19_10260631",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55252b1b_96b1e17d",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1111,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-03-21T00:33:52Z",
      "side": 1,
      "message": "What about the case where `ref.Path !\u003d \"\" \u0026\u0026 u.Opaque !\u003d \"\"`?",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d334067c_83fceb72",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1111,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-03-21T22:55:04Z",
      "side": 1,
      "message": "Since the opaque is stored separately, if we reach the end of the funcion (the \"abs_path\" or \"rel_path\" cases), we know that the ref doesn\u0027t have an opaque value (either because we entered the `ref.Opaque !\u003d \"\"` condition or because for it to have an opaque value it needs a scheme and so entered that first condition mentioned previously: `if ref.Scheme !\u003d \"\" || ref.Host !\u003d \"\" || ref.User !\u003d nil` ), so if its path is `!\u003d \"\"` (and a path in the URI class starts with a \u0027/\u0027) the corresponding pseudocode that would be executed is: \n```\nif (R.path starts-with \"/\") then\n  T.path \u003d remove_dot_segments(R.path);\n``` \nIn the current implementation, the final path will be `resolvePath(u.EscapedPath(), ref.EscapedPath())`, which should return what would be expected from the `remove_dot_segments(R.path)` call in the pseudocode (and from my understanding of the function and testing, it does), independently if the base URL has an opaque or not (since only the `R.path` should be taken into account here), because otherwise this general case (when `R.scheme \u003d\u003d \"\" \u0026\u0026 R.Authority \u003d\u003d \"\" \u0026\u0026 R.path !\u003d \"\"`) is not according to the spec and there\u0027s another issue here (not related with the opaque issue).",
      "parentUuid": "55252b1b_96b1e17d",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5fd32565_67b9ebae",
        "filename": "src/net/url/url.go",
        "patchSetId": 1
      },
      "lineNbr": 1111,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-05-21T22:47:16Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "d334067c_83fceb72",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "876a6fae_48c130fa",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-03-22T17:50:00Z",
      "side": 1,
      "message": "Some additional cases:\n\n```\n        {\"http:opaque\", \"g\", \"http:opaque/g\"},\n        {\"http:opaque\", \".\", \"http:opaque\"},\n        {\"http:opaque\", \"..\", \"http:\"},\n        {\"http:opaque?p\", \"g?q\", \"http:opaque/g?q\"},\n        {\"http:a/./b\", \"c\", \"http:a/b/c\"},\n        {\"http:a/./b\", \"?q\", \"http:a/b?q\"},\n```\n\nI think those expectations are correct; if so, the current code is mishandling these cases. But I might be wrong about the correct expected output.",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e136aab_d319c1e4",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-03-23T16:42:34Z",
      "side": 1,
      "message": "The first four cases all fall into the following pseudo algorithm case:\n```\nif (R.path starts-with \"/\") then\n  [...]\nelse  \u003c-- this case\n  T.path \u003d merge(Base.path, R.path);\n  T.path \u003d remove_dot_segments(T.path);\n```\nso the test cases should be as follows (current implementation results in side comment):\n```\n{\"http:opaque\", \"g\", \"http:g\"}, // \"http:///g\"\n{\"http:opaque\", \".\", \"http:\"}, // \"http:///\"\n{\"http:opaque\", \"..\", \"http:\"}, // \"http:///\"\n{\"http:opaque?p\", \"g?q\", \"http:g?q\"}, // \"http:///g?q\"\n```\nwhich are correctly being handled using `resolvePath(u.EscapedPath(), ref.EscapedPath())`, but all of them print an empty authority section \"//\", which seems related to [this issue](https://github.com/golang/go/issues/46059)\n\nFrom my interpretation of what an opaque value represents (which would be something that does not describe a path to a resource, not hierarchical, just a random sequence of characters), I don\u0027t think that the opaque value should be parsed (or merged with another path) in any way like a path is (for example removing dot segments as in the 5th and 6th provided test cases), especially given that we\u0027re storing the opaque separately from the path and [treating an opaque URL in a completely different way from an URL with a path](https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#349). With this in mind, I would suggest that the above four cases should just ignore the base opaque value (by setting the final path to `resolvePath(u.EscapedPath(), ref.EscapedPath())`, which is the current behavior), since that if the base opaque has a \u0027/\u0027 character and the `ref.path` doesn\u0027t start with one, then applying `resolvePath` to the base opaque and the ref path [would be merging part of the opaque with the ref path](https://go-review.googlesource.com/c/go/+/572915/1/src/net/url/url.go#1005), and that\u0027s probably undesired given the way an opaque URL is treated here.\n\nThe fix I proposed is for the case where the reference doesn\u0027t have a scheme, an authority section, or a path and the base url is opaque. The result should be the base opaque proceeded by the reference fragment and/or query (if they exist) since that\u0027s the way an opaque URL is interpreted in this class, as I mentioned previously. The current implementation doesn\u0027t support this case as the opaque is stored separately and the \"abs_path\" or \"rel_path\" case will only take into account paths, thus the need for checking this specific case.",
      "parentUuid": "876a6fae_48c130fa",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad77b872_3642d0f3",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-03-25T17:51:27Z",
      "side": 1,
      "message": "Ah, I was misunderstanding `merge`; it replaces the last path segment.\n\nRFC 3986 Section 1.2.3 (https://www.rfc-editor.org/rfc/rfc3986.html#section-1.2.3) says:\n\n\u003e URI scheme specifications can define opaque identifiers by disallowing use of slash characters, question mark characters, and the URIs \"scheme:.\" and \"scheme:..\".\n\nThat is, if an identifier is supposed to be opaque, it shouldn\u0027t contain characters that get special processing by `merge` and `remove_dot_segments` (`/`, `?`, or the bare path `.` or `..`).\n\nThis is distinct from `URL.Opaque`, which is an identifier that doesn\u0027t start with a `/` and has a scheme. A URL of `http:a/./b/../c` is not \"opaque\" as described in Section 1.2.3, even though `net/url` would put the path in the `Opaque` field.\n\nI think if we\u0027re strictly following RFC 3986, my examples above should be:\n\n```\n        {\"http:opaque\", \"g\", \"http:g\"},\n        {\"http:opaque\", \".\", \"http:\"},\n        {\"http:opaque\", \"..\", \"http:\"},\n        {\"http:opaque?p\", \"g?q\", \"http:g?q\"},\n        {\"http:a/./b\", \"c\", \"http:a/c\"},\n        {\"http:a/./b\", \"?q\", \"http:a/b?q\"},\n```",
      "parentUuid": "6e136aab_d319c1e4",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc809718_d50e09e7",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-03-26T11:13:28Z",
      "side": 1,
      "message": "I agree with the given expected outputs for the tests.\n\nBut if the `URL.opaque` isn\u0027t necessarily an opaque as described in the spec, but it is intended to be treated as a path is in the spec, isn\u0027t the whole opaque separation pointless? Just storing the path always as a path would probably be better, since with the current implementation of `URL` it will be needed to check for both `base.opaque` and `base.path` and treat them differently to get the output according to spec when the merging behavior should be universal (in my opinion), which would be achieved by not storing opaque separately.\n\nThe `resolvePath` function is just meant to handle paths (either starting with \u0027/\u0027 or not), not opaques, since one of its core behaviors is always printing a \u0027/\u0027 at the beginning, which is not desired when handling an opaque, as described in the 5th and 6th given test cases, but is intended for paths as tests are expecting it.\n\nThe refactoring of the whole opaque handling to make it completely according to spec should be opened as another issue since it will be much deeper than what this issue is about. There\u0027s also the previously mentioned problem, where there\u0027s being printed an empty authority section, which would make writing tests for the opaque merging behavior difficult (since the tests would have to expect the empty authority, even though that wouldn\u0027t be desired).\n\nThis issue is just about the specific case where the reference doesn\u0027t have a scheme, an authority section, or a path and the base url is opaque, which doesn\u0027t require any path merging as the `ref.Path` is empty.",
      "parentUuid": "ad77b872_3642d0f3",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ecf1ada5_542a1e89",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-04-08T20:15:50Z",
      "side": 1,
      "message": "I don\u0027t know what the history behind the `Opaque` field is. It does seem to me like it would be simpler to just have `Path` contain the path, including the `/` prefix when present. But we can\u0027t change that now.\n\nI don\u0027t have a strong opinion about whether we need to handle resolving paths with no `/` prefix exactly according to the spec or not. I do think that `\"http:opaque\".ResolveReference(\"g\")` should be `http:g`, not `http:///g`.\n\nWould you mind adding this set of test cases? They seem like cases where our choice of behavior should be deliberate and exercised by tests. If there are ones where you think it\u0027s okay for us to diverge from the letter of the specification, or where we\u0027re currently doing the wrong thing and this CL doesn\u0027t make the situation worse, then include an explanatory comment.\n\nThanks.",
      "parentUuid": "fc809718_d50e09e7",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3dbe1e1_ebd46f99",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 3340440
      },
      "writtenOn": "2024-04-10T22:14:06Z",
      "side": 1,
      "message": "Sorry, but I\u0027m not sure I understood your request.\nDo you want the given test cases to be added, and thus all the functionality for merging Opaques according to spec? That is, fixing the overall missing behavior for handling Opaques instead of just the reported case.",
      "parentUuid": "ecf1ada5_542a1e89",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2db95980_c4ecaa87",
        "filename": "src/net/url/url_test.go",
        "patchSetId": 1
      },
      "lineNbr": 1258,
      "author": {
        "id": 5305
      },
      "writtenOn": "2024-05-21T22:46:21Z",
      "side": 1,
      "message": "Sorry for losing track of this, many distractions.\n\nWhat I\u0027d like is for us to have tests that cover these cases, so we document our current behavior and can identify in the future if it changes either intentionally or unintentionally.\n\nI\u0027m okay if the tests verify that we produce incorrect/spec-noncompliant output, so long as the test includes a comment explaining that we\u0027re doing the wrong thing and identifying what we think the right thing would be.\n\nDon\u0027t worry about it, though, I can add them myself in a followup CL. I\u0027ve been convinced that this one is a strict improvement as-is.  Thanks.",
      "parentUuid": "c3dbe1e1_ebd46f99",
      "revId": "2db2343a8b7c8061dc3b64cc4d3423c851791a67",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}