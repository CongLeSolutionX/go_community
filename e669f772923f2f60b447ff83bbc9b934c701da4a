{
  "comments": [
    {
      "key": {
        "uuid": "7a9af431_7aeb8252",
        "filename": "src/cmd/compile/internal/gc/walk.go",
        "patchSetId": 9
      },
      "lineNbr": 1430,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-05-05T20:48:28Z",
      "side": 1,
      "message": "I think we might need a race/msan detector call here also.",
      "revId": "e669f772923f2f60b447ff83bbc9b934c701da4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "876e216c_6397438d",
        "filename": "src/cmd/compile/internal/gc/walk.go",
        "patchSetId": 9
      },
      "lineNbr": 1430,
      "author": {
        "id": 5846
      },
      "writtenOn": "2020-05-05T21:24:19Z",
      "side": 1,
      "message": "I tried to find a case where we do that in walk.go and could not find one. e.g. the memmove in append is not instrumented either. That may be an existing problem. For now I added an instrumenting check in orderMakeSliceCopy that disables the optimization in the order pass.\n\nGenerally it looks like we should (if we can) instrument memmove in ssa.go so we do not miss any cases from order/walk. We also have the func references and do other instrumenting in that pass.",
      "parentUuid": "7a9af431_7aeb8252",
      "revId": "e669f772923f2f60b447ff83bbc9b934c701da4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85a037b5_aa5bfe63",
        "filename": "src/runtime/slice.go",
        "patchSetId": 9
      },
      "lineNbr": 34,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-05-05T20:48:28Z",
      "side": 1,
      "message": "Needs a comment about what it does.\n\n// makeslicecopy allocates a slice of \"tolen\" elements of type \"et\", then copies \"fromlen\" elements of type \"et\" into that new allocation from \"from\".",
      "revId": "e669f772923f2f60b447ff83bbc9b934c701da4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7419495_9bceca25",
        "filename": "src/runtime/slice.go",
        "patchSetId": 9
      },
      "lineNbr": 34,
      "author": {
        "id": 5846
      },
      "writtenOn": "2020-05-05T21:24:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "85a037b5_aa5bfe63",
      "revId": "e669f772923f2f60b447ff83bbc9b934c701da4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2e6a122b_7f11cb17",
        "filename": "src/runtime/slice.go",
        "patchSetId": 9
      },
      "lineNbr": 35,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-05-05T20:48:28Z",
      "side": 1,
      "message": "I think this function needs a raceenabled and msanenabled block somewhere (analagous to slicecopy).",
      "revId": "e669f772923f2f60b447ff83bbc9b934c701da4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2bbfd93_47bd06f6",
        "filename": "src/runtime/slice.go",
        "patchSetId": 9
      },
      "lineNbr": 35,
      "author": {
        "id": 5846
      },
      "writtenOn": "2020-05-05T21:24:19Z",
      "side": 1,
      "message": "Done. Added the read. As the slice is new the copy to should not be able to race.",
      "parentUuid": "2e6a122b_7f11cb17",
      "revId": "e669f772923f2f60b447ff83bbc9b934c701da4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}