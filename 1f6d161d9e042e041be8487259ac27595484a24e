{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bef48bff_a22a8e53",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-01-15T23:19:39Z",
      "side": 1,
      "message": "I don\u0027t think this entirely prevents the problem. If the shared memory is unmapped in Close by the worker goroutine, the client goroutine (workerClient.fuzz) could still call setValue or valueCopy. So the mutex needs to exist outside sharedMem, and the caller needs to know whether sharedMem has been Closed.\n\nI\u0027m not quite sure where the mutex should go: worker and workerClient both need access to it. It would be awkward to have a pointer to a mutex. Maybe sharedMem itself should expose it as a field.\n\nTotally optional, but this seems like a good use case for Bryan\u0027s chan-as-mutex pattern. worker could have a field of type chan *sharedMem instead of *sharedMem.\n\nThat\u0027s created with:\n\n  memC :\u003d make(chan *sharedMem, 1)\n  mem, err :\u003d ...\n  memC \u003c- mem\n\nClosed with:\n\n  mem :\u003d \u003c-memC\n  mem.Close()\n  close(memC)\n\nAccessed with:\n\n  mem :\u003d \u003c-memC // lock\n  if mem \u003d\u003d nil {\n    // closed earlier\n  }\n  ...\n  memC \u003c- mem // unlock\n",
      "revId": "1f6d161d9e042e041be8487259ac27595484a24e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64725af9_0a36bfdf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-01-19T23:02:57Z",
      "side": 1,
      "message": "I like the chan-as-mutex pattern (I hadn\u0027t seen this before actually! Very cool), and I think it could work. When I was playing around with it, the refactor ended up being a huge pain because we shared the workerComm{} between both workerServer and workerClient, so having one be a `chan *sharedMem` and the other a `*sharedMem` posed some issues. It also made the code a bit more difficult to follow. We can discuss it tomorrow and see if there\u0027s another way.\n\nI\u0027m also wondering how we avoid this happening in the workerServer. If the client deletes the shared memory file, do we have to worry about there being a seg fault in the workerServer? I\u0027m not sure.\n\nI just sent an update that I *think* should solve this, but I don\u0027t love it.",
      "parentUuid": "bef48bff_a22a8e53",
      "revId": "1f6d161d9e042e041be8487259ac27595484a24e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}