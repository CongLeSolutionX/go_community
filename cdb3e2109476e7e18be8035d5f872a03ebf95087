{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f9221176_8c5f67f3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-07-11T00:51:21Z",
      "side": 1,
      "message": "This seems like a lot of code to handle what sounds like an extremely rare case.  Does this ever happen except for people writing an init process?  Can people writing an init process simply avoid the os and os/exec packages and just call syscall directly?",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bfcdb56a_d7a7bcb8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 35211
      },
      "writtenOn": "2023-07-11T06:02:58Z",
      "side": 1,
      "message": "Any Go binary that is the entry point of a Docker container is running as PID 1, so I wouldn\u0027t say it\u0027s rare in particular.\n\nPeople could in theory avoid the os and os/exec packages, but that isn\u0027t very appealing. There\u0027s quite a lot of useful stuff in those packages that you\u0027d have to replicate. For example, os/exec allows terminating a process based on context expiration. This is something that you\u0027d have to hand-roll then.",
      "parentUuid": "f9221176_8c5f67f3",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b0cfb04_1d9ac71d",
        "filename": "src/syscall/exec_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 496,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-07-11T00:51:21Z",
      "side": 1,
      "message": "This is new user-visible API, which requires a proposal.  See https://go.dev/s/proposal.",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2a10cf5_05c42405",
        "filename": "src/syscall/exec_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 496,
      "author": {
        "id": 35211
      },
      "writtenOn": "2023-07-11T06:02:58Z",
      "side": 1,
      "message": "Gotcha! I can write a proposal. Just let me know what your preference is on the name for the StartProcess() replacement and I\u0027ll make sure to incorporate that.",
      "parentUuid": "1b0cfb04_1d9ac71d",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e36ce2d0_133d59c8",
        "filename": "src/syscall/exec_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 496,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-07-11T13:57:01Z",
      "side": 1,
      "message": "I haven\u0027t fully read read the CL, but the description suggests that it does more than is required to run as PID 1.  It seems to me that in general a PID 1 Go program shouldn\u0027t need to care about child processes that are reparented.  The os/exec code should always wait for a known process, not for an arbitrary process.  It\u0027s not clear to me that we need to make every Go program support reaping zombies just because it is PID 1.  For example, I assume that C programs do not routinely do that.",
      "parentUuid": "b2a10cf5_05c42405",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4911369f_eb6e9871",
        "filename": "src/syscall/exec_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 496,
      "author": {
        "id": 35211
      },
      "writtenOn": "2023-07-11T17:01:24Z",
      "side": 1,
      "message": "\u003e It seems to me that in general a PID 1 Go program shouldn\u0027t need to care about child processes that are reparented.\n\nApart from contrived use cases where processes create new sessions, daemonize, etc., reparenting may already happen if any direct child of PID 1 terminates (e.g., crashes) before grandchildren do. This is not an uncommon use case if you ask me.\n\nI didn\u0027t write this patch just for the sake of it. This issue is a real problem for me for Buildbarn, a distributed build cluster for Bazel (https://github.com/buildbarn). There I see that if I need to kill build actions due to them exceeding their timeout, we often leave processes behind.\n\nI have strongly considered completely banning the use of os/exec in the codebase, but it simply leads to too much code duplication. If there was a way to use os/exec, but swap out the bottom half that does the waiting, I would have already done so.\n\n\u003e It\u0027s not clear to me that we need to make every Go program support reaping zombies just because it is PID 1. For example, I assume that C programs do not routinely do that.\n\nThat\u0027s correct. Most C programs also don\u0027t do it properly. But a lot of things have changed since the bulk of software built in C was written. For example, Docker became a thing and Google released a tool named Kubernetes that allows you to run Docker containers at scale.\n\nComing back to the topic of how common it is to run Go binaries as PID 1, I just noticed that if I literally follow the instructions on https://hub.docker.com/_/golang, I end up with exactly that:\n\n    $ cat Dockerfile       \n    FROM golang:1.20\n    WORKDIR /usr/src/app\n    COPY go.mod ./\n    RUN go mod download \u0026\u0026 go mod verify\n    COPY . .\n    RUN go build -v -o /usr/local/bin/app ./...\n    CMD [\"app\"]\n    $ cat main.go   \n    package main\n    import (\n    \t\"fmt\"\n    \t\"os\"\n    )\n    func main() {\n    \tfmt.Println(os.Getpid())\n    }\n    $ docker build -t my-golang-app .                        \n    $ docker run -it --rm --name my-running-app my-golang-app\n    1",
      "parentUuid": "e36ce2d0_133d59c8",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fd2c83b_6dd271bf",
        "filename": "src/syscall/exec_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 536,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-07-11T00:51:21Z",
      "side": 1,
      "message": "This changes the second result from uintptr to ProcessHandle.  We can\u0027t do that, as it breaks the Go 1 compatibility guarantee (https://go.dev/doc/go1compat).",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c160c8a9_bf6acd8d",
        "filename": "src/syscall/exec_unix.go",
        "patchSetId": 1
      },
      "lineNbr": 536,
      "author": {
        "id": 35211
      },
      "writtenOn": "2023-07-11T06:02:58Z",
      "side": 1,
      "message": "What would your thoughts on adding a new function named StartProcessWithHandle()?",
      "parentUuid": "9fd2c83b_6dd271bf",
      "revId": "cdb3e2109476e7e18be8035d5f872a03ebf95087",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}