{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d675bc6f_d69e3fae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-07-26T08:49:21Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dcd94b291\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17c4794f_c5252172",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-07-26T09:02:20Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "d675bc6f_d69e3fae",
      "tag": "autogenerated:trybots~happy",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bdb55681_288c3e8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-07-27T17:38:06Z",
      "side": 1,
      "message": "After a few rounds of reviews I still have a hard time to see this is more maintainable. This CL adds a lot complexity, and a mix of (semi-)generated code and hand-written code. I\u0027m not sure this is the right direction. If the goal is to add  SVE support, I think we should discuss that instead. I think it is probably possible to add SVE support without the rewrite. Thanks.",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "34ecc13b_31c79ca3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-07-28T08:57:53Z",
      "side": 1,
      "message": "\u003e complexity\nI admit that this CL increases the code size, but I think this CL just puts the previous Prog matching work and part of the encoding work into unfolding, and this is for better modularity. The previous implementation mixed the conversion of Prog to machine IR with encoding, now we separated the two. So in fact, the encoding of machine IR is simplified. The overall framework is more modular, so I think it is simpler. Of course this is subjective.\n\n\u003e mix of (semi-)generated code and hand-written code\nI guess you are referring to the instruction table and the parameter table, and the encoding of the parameters. To be honest I would also like these to be automatically generated. Suppose there is such an automated program, what are its inputs? What can be seen outside the Arm are some PDF documents, so we can only parse this pdf document, which has no fixed format and changes with the development of ISA. To be honest, we don\u0027t have a good automation program in-house either, so I think this form of semi-automation is the most practical. We can update these two tables for a large version of the ISA, such as arm v8 to arm v9, SVE, etc. And small version updates, such as v8 to v8.1, will not have too many instructions, we can manually add some instructions. In most cases I would assume that there will be no changes to the two tables.\n\n\u003e If the goal is to add SVE support\nIn addition to SVE, there are many unsupported NEON instructions, and new instructions in the future. I can\u0027t imagine the effort of adding hundreds or thousands of SVE and NEON instructions to the existing framework. Our main goal is to reduce the effort of adding new instructions, this CL can reuse a lot of the encoding and unfolding work, which can reduce a lot of effort.\n\nThanks for your feedback, I think our goal is the same, improve the arm64 backend. The current design may not be the best, but it\u0027s the result of our internal discussions. If you have other better designs, I\u0027d be happy to make changes for it. Thanks.",
      "parentUuid": "bdb55681_288c3e8e",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00c683a2_52e1acec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-08-01T23:16:54Z",
      "side": 1,
      "message": "I think the unfolding pass actually adds more complexity. Now every instruction has two representations, and there are several tables. I don\u0027t think this is really necessary. The machine instruction encoding is really not needed until the very end. So let\u0027s keep it that way. Also, while there exist a number of Progs that expand to multiple machine instructions, I\u0027d expect that most instructions we will add in the future, including SVE and NEON instructions, don\u0027t need rewrite. So they really don\u0027t need to go through the unfolding process and the complexity around it.\n\nI can see one of the challenge of adding SVE, NEON, or other new instructions is the current \"optab\" table (and related operand classification) isn\u0027t very easy to extend to work with those instructions. The optab is designed to work with relatively simple instruction set where there are relatively few operand types and instruction encodings. The integer instructions are like that, and the optab works reasonable well with that. (There are problems, but I think they are more implementation details instead of overall design problems.) For SVE and NEON, they don\u0027t have to use the same table. We can have new tables specifically for SVE, or for NEON, or other new type of instructions. We can check whether an instruction is an integer instruction, or SVE or NEON, and use different tables and possibly even code paths. (There are currently NEON instructions in the current optab. We can remove them once the new NEON support is complete.)\n\nOverall, I think the structure is clearer: for integer instructions, use the current optab. For SVE and other new instructions, use new tables. And no unfolding is necessary.\n\nThanks.",
      "parentUuid": "34ecc13b_31c79ca3",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1150c53b_95636f5a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-08-02T10:15:44Z",
      "side": 1,
      "message": "\u003e And no unfolding is necessary.\n\nThis is hard, we need a way to know how many machine instructions a Prog corresponds to, and what machine instructions. Either through the current method, analyze the operator class of Prog, and then match with the item of optab. This approach puts the complexity in operator matching. Either use a method similar to this CL, unfolding analysis, which put the complexity in unfolding process.\n\nThanks for your suggestion, let me think about how to do it.",
      "parentUuid": "00c683a2_52e1acec",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "203c391e_46b7312f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-08-02T14:34:56Z",
      "side": 1,
      "message": "\u003e we need a way to know how many machine instructions a Prog corresponds to\n\nMy point is that for most SVE and other new instructions that we\u0027re planning to add, we know it -- it is one, and it is the same machine instruction as the Prog represents.\n\nFor existing integer instructions, we still use optab, which works. For new instructions, they don\u0027t need to use optab, also don\u0027t need unfolding, just new tables for operand handling and encoding.\n\nThanks.",
      "parentUuid": "1150c53b_95636f5a",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6fde913a_32991d1f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2022-08-03T09:10:36Z",
      "side": 1,
      "message": "OK, I think if we stipulate that the Prog of the newly added instruction and the machine instruction are 1:1 mapping, then the biggest trouble is gone. This is very good, a few things that come to my mind:\n\n1. The constant or offset value of the newly added Go assembly instruction must be consistent with that of the arm instruction. I hope this is no problem.\n\n2. I think we\u0027ll continue to use operand matching to find the corresponding item in the new table for a Prog. It is expected that here we need to classify the operand of the Arm instruction, and then map it with the class of Prog. Operand matching is expected to be simple because there are no more complex operands.\n\n3. For encoding, I hope to adopt the method of this CL, that is, we will still introduce a semi-automatically generated instruction table (see above inst.go), this table contains the skeleton and operand types of the arm instruction, but compare to the one in inst.go, we do not need to manually specify its index. After finding a Prog\u0027s corresponding machine instruction in the table, use encoding(prog) \u003d skeleton|opcode|arg1|arg2|...|argn to encode. This way we don\u0027t need to encode each machine instruction, but encode each operand type, the operand type is much less than the instruction. Do you have any concern about this? We can add both general, NEON and SVE instructions at one time, or add them one by one.\n\n4, Before coding, we need to consider the difference in operand order between Go assembly instructions and Arm assembly instructions. I expect that the operand order of instructions in the new instruction table is the same as that of the Arm instruction，then before encoding, we adjusted the operand order of Prog to the same as that of the arm instruction. Maybe we should make the operand order of the table\u0027s instructions consistent with Go\u0027s, then this problem doesn\u0027t exist. It\u0027s just that when generating this table we may not be sure what the operant order should be for instructions that are not yet supported. Or for an unsupported instruction we can temporarily ignore its operator order in the table?\n\nI think this design is simpler than both this CL and the current implementation. If my thoughts above agree with yours, I will reimplement this CL, and if there are other issues, let\u0027s get it done before coding. Thanks.",
      "parentUuid": "203c391e_46b7312f",
      "revId": "cd94b29118eb7cf35c4b3b516751ef7bcedcaf5f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}