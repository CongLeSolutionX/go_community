{
  "comments": [
    {
      "key": {
        "uuid": "71ed7d37_02044cf6",
        "filename": "src/compress/gzip/gunzip.go",
        "patchSetId": 1
      },
      "lineNbr": 272,
      "author": {
        "id": 5065
      },
      "writtenOn": "2016-03-30T06:55:57Z",
      "side": 0,
      "message": "Are you sure this is right? Isn\u0027t this what\u0027s preventing one Read from doing two underlying Reads?",
      "revId": "354e9778a3327e125ed99e86d7b6e648ed0ccd53",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "71ed7d37_2222307e",
        "filename": "src/compress/gzip/gunzip.go",
        "patchSetId": 1
      },
      "lineNbr": 272,
      "author": {
        "id": 9735
      },
      "writtenOn": "2016-03-30T07:14:36Z",
      "side": 0,
      "message": "With the upcoming change to compress/flate, we now return (n, io.EOF).\n\nThe problem with this check is that the n !\u003d 0 condition is now satisfied. The z.err \u003d err line below will store the io.EOF as a sticky error. This has two problems:\n1) it breaks multistream logic\n2) it skips the GZIP footer consistency checks\n\nAnother way to look at it is: after this check, z.err must be io.EOF, which means we should definitely be going through the Reads that follow to check the footer and all. If we don\u0027t do that, then we may silently report that an invalid GZIP file as valid.",
      "parentUuid": "71ed7d37_02044cf6",
      "revId": "354e9778a3327e125ed99e86d7b6e648ed0ccd53",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}