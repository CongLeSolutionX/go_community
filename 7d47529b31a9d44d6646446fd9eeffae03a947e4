{
  "comments": [
    {
      "key": {
        "uuid": "8f034054_a2c93bcc",
        "filename": "src/archive/tar/common.go",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "I\u0027m not sure about this sentence, it doesn\u0027t sound right to me. I suggest an alternative:\n\nA sparse file consists of fragments of data, intermixed with holes (described\nby this field); a hole is semantically a block of NUL bytes, but it is not\nactually written to disk.",
      "range": {
        "startLine": 79,
        "startChar": 1,
        "endLine": 80,
        "endChar": 66
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a249de51_91fbe732",
        "filename": "src/archive/tar/common.go",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "Done.\n\nI avoided the word \"disk\" since some TAR files never hit disk (e.g., may be sent over the network).",
      "parentUuid": "8f034054_a2c93bcc",
      "range": {
        "startLine": 79,
        "startChar": 1,
        "endLine": 80,
        "endChar": 66
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2c382377_637a3404",
        "filename": "src/archive/tar/common.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "With my rewording, \"fragments\" is data, so this should be \"holes\".",
      "range": {
        "startLine": 82,
        "startChar": 8,
        "endLine": 82,
        "endChar": 17
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17e1d2b7_64708de1",
        "filename": "src/archive/tar/common.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2c382377_637a3404",
      "range": {
        "startLine": 82,
        "startChar": 8,
        "endLine": 82,
        "endChar": 17
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7de232b7_b42b527c",
        "filename": "src/archive/tar/example_test.go",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "This example helps a lot, thanks. I\u0027m only thinking that I would like it go away later when we have proper hole detection and read/write support for sparse files on disk. When those parts are in, this should be an example on how to properly use the high-level API, rather than the low-level one (which can remain lightly documented as it is without this example).",
      "range": {
        "startLine": 80,
        "startChar": 0,
        "endLine": 80,
        "endChar": 23
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ee9832fe_27962c6c",
        "filename": "src/archive/tar/example_test.go",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "I\u0027m in support of a high-level API, but I still believe that the high-level API should just be filling out SparseHoles.",
      "parentUuid": "7de232b7_b42b527c",
      "range": {
        "startLine": 80,
        "startChar": 0,
        "endLine": 80,
        "endChar": 23
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b8447da_d6bc75df",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "Why not just leave this empty? It looks like a gratuitous object allocation that is then always discarded.",
      "range": {
        "startLine": 37,
        "startChar": 22,
        "endLine": 37,
        "endChar": 48
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1114fb9b_7c606915",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "It simplifies the implementation so I dont have to keep checking:\n\n tw.curr !\u003d nil { ... }\n\nin all of the methods.",
      "parentUuid": "8b8447da_d6bc75df",
      "range": {
        "startLine": 37,
        "startChar": 22,
        "endLine": 37,
        "endChar": 48
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "806380b2_5fb88eaf",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-23T01:21:00Z",
      "side": 1,
      "message": "It looks like only Flush() would require that check, if I\u0027m reading the code correctly.",
      "parentUuid": "1114fb9b_7c606915",
      "range": {
        "startLine": 37,
        "startChar": 22,
        "endLine": 37,
        "endChar": 48
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a4d771e7_2ad73b2c",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 181,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-23T01:21:00Z",
      "side": 1,
      "message": "I think this should be tw.w.Write",
      "range": {
        "startLine": 181,
        "startChar": 15,
        "endLine": 181,
        "endChar": 28
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bc78c0f5_c69cfa20",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 444,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "maybe \"overflow\"?",
      "range": {
        "startLine": 444,
        "startChar": 1,
        "endLine": 444,
        "endChar": 10
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bdbfa057_aca23aac",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 444,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "The comes with the connotation of numerical overflow. Also, \"overwrite\" corresponds with the fact that ErrWriteTooLong is returned.",
      "parentUuid": "bc78c0f5_c69cfa20",
      "range": {
        "startLine": 444,
        "startChar": 1,
        "endLine": 444,
        "endChar": 10
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "81145d02_267a85b3",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 444,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-23T01:21:00Z",
      "side": 1,
      "message": "Oh I see, you think \"overwrite\" as in \"writing too much\"; I think of \"overwrite\" only as \"replacing the old with the new\", like \"this file has been overwritten by zeros\"; this is the only meaning I was aware of. I was suggesting \"overflow\" as in \"buffer overflow\", that is going beyond the limit. Anyway, I\u0027m not a native speaker, so up to you.",
      "parentUuid": "bdbfa057_aca23aac",
      "range": {
        "startLine": 444,
        "startChar": 1,
        "endLine": 444,
        "endChar": 10
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "81440681_e4004f21",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 447,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "Does it really matter? Can\u0027t you just return ErrWriteTooLong right away as soon as an overwrite is detected?",
      "range": {
        "startLine": 445,
        "startChar": 1,
        "endLine": 447,
        "endChar": 2
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3ba9d9f_5f522a6a",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 447,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "We should still try to write as much as possible.",
      "parentUuid": "81440681_e4004f21",
      "range": {
        "startLine": 445,
        "startChar": 1,
        "endLine": 447,
        "endChar": 2
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1b3ee08d_ee78de0a",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 468,
      "author": {
        "id": 5810
      },
      "writtenOn": "2017-08-22T22:16:57Z",
      "side": 1,
      "message": "s/fileReader/fileWriter/\n(presumably)",
      "range": {
        "startLine": 468,
        "startChar": 25,
        "endLine": 468,
        "endChar": 35
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d54615b_f280e09b",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 468,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1b3ee08d_ee78de0a",
      "range": {
        "startLine": 468,
        "startChar": 25,
        "endLine": 468,
        "endChar": 35
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ac5c0b2b_19be85e1",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 469,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "I thought of a different implementation, but I\u0027m not sure it\u0027s better. \n\nAssuming a very simple limitedWriter (like io.LimitedReader), that EOFs after the specified number of bytes, one could use a MultiWriter to combine a sequence of alternated limitedWriter{zeroWriter{}} (for holes) and limitedWriter{tw} (for data). This would require much less code.",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 30
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ebe6082_e8d81303",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 469,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:17:58Z",
      "side": 1,
      "message": "eww, my brain tricked on me. MultiWriter does a different thing from MultiReader, so the above cannot be done without a custom ChainedWriter or something which would need to be written anyway, at which point I\u0027m not sure we\u0027re saving much.",
      "parentUuid": "ac5c0b2b_19be85e1",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 30
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "83068771_63103fc1",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 469,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "Your idea is still interesting. I like the simplicity of it, but you can\u0027t implement FillZeros with it.",
      "parentUuid": "8ebe6082_e8d81303",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 30
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "58d920cf_6d720a40",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 515,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "Why not just io.CopyN(sw, zeroReader{}, n) like above?\n\nI can see the performance argument (though the code duplication is really bad), but I don\u0027t think anybody should be doing this anyway; this is zero-expansion of a sparse file, which shouldn\u0027t normally happen in the first place. When it happens, I don\u0027t think it needs to absolutely be super fast.",
      "range": {
        "startLine": 515,
        "startChar": 0,
        "endLine": 515,
        "endChar": 63
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51f97458_219a7b55",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 515,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "The code deplication is unfortunate. It could be simplified with a little function programming, but I feel like it makes it less readable.\n\nWithout FillZeros, there is no way to efficiently populate the data for a sparse file without this method. In fact, the unit tests depend on this to finish writing a 60GB (logical size) file with a sane amount of time.\n\nAlso, if we\u0027re serious about adding ReadFrom, we may just change this method to implement that and switch the unit tests to use ReadFrom instead.",
      "parentUuid": "58d920cf_6d720a40",
      "range": {
        "startLine": 515,
        "startChar": 0,
        "endLine": 515,
        "endChar": 63
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "628ebec9_9c384500",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 515,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-23T01:21:00Z",
      "side": 1,
      "message": "yes, I think the tests should eventually use ReadFrom. The would still be a codepath in which FillZeros can be used (populating holes in non-seekable writers), but I\u0027m not sure if it\u0027s worth to keep it at that point.\n\nMoreover, I would need to study the profile; maybe the slowness without FillZeros was coming from the inefficient zeroWriter using TrimLeft.",
      "parentUuid": "51f97458_219a7b55",
      "range": {
        "startLine": 515,
        "startChar": 0,
        "endLine": 515,
        "endChar": 63
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16953b94_873dc249",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 557,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "Maybe add a comment: zeroWriter is a writer that expect only zeros to be written, and returns errWriteHole otherwise.\n\nAlso: do we really need to do this check? Can\u0027t we just ignore and assume the user was smart, or let it generate a possibly \"corrupted\" file if his code is buggy?",
      "range": {
        "startLine": 557,
        "startChar": 0,
        "endLine": 557,
        "endChar": 24
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "427a92be_16ed5505",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 557,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "Comment added.\n\nFor the time being, I\u0027d rather be a little more strict. If this causes issues, we can trivially change it to ignoreWriter, where it reports all writes as a success.",
      "parentUuid": "16953b94_873dc249",
      "range": {
        "startLine": 557,
        "startChar": 0,
        "endLine": 557,
        "endChar": 24
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cdf565b7_0208bba3",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 560,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-22T22:09:41Z",
      "side": 1,
      "message": "I expect bytes.Equal() with a 1k empty block to be much much faster, because it\u0027s assembly optimized on most platform and would probably check many bytes at a time, plus there\u0027s no allocation (TrimLeft allocates a closure).",
      "range": {
        "startLine": 560,
        "startChar": 1,
        "endLine": 560,
        "endChar": 48
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a00e351_7bbe51a4",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 560,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-08-22T23:10:18Z",
      "side": 1,
      "message": "I converted it to just a simple for-loop. comparison with 1k block of zeroes is a nice idea, but I think it\u0027s premature optimization. It\u0027s just reducing O(K*n) to O(k*n).",
      "parentUuid": "cdf565b7_0208bba3",
      "range": {
        "startLine": 560,
        "startChar": 1,
        "endLine": 560,
        "endChar": 48
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "af3ca7e2_14fbcc10",
        "filename": "src/archive/tar/writer.go",
        "patchSetId": 4
      },
      "lineNbr": 560,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-08-23T01:21:00Z",
      "side": 1,
      "message": "Ok, now the code is only 16 times slower than bytes.Equal (give it or take it). It could be premature optimization, yes, but I wonder if this is the reason why Write() is so much slower than FillZeros(). Of course FillZeros will always be faster, but it shouldn\u0027t be that much faster. Comparing 60Gb of data is still quite fast on modern CPUs, so it should be slower but not enough to justify a dedicated FillZero function.",
      "parentUuid": "2a00e351_7bbe51a4",
      "range": {
        "startLine": 560,
        "startChar": 1,
        "endLine": 560,
        "endChar": 48
      },
      "revId": "7d47529b31a9d44d6646446fd9eeffae03a947e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}