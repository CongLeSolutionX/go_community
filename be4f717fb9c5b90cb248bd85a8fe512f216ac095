{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "12deb17f_e679ebcb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-10-25T19:25:09Z",
      "side": 1,
      "message": "The code might be okay, but I don\u0027t think the reasoning is correct. Here the OpSB is just a pseudo-register (which has nothing to do with R28) and should not affect code generation. What happens if you don\u0027t do this?",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 14,
        "endChar": 13
      },
      "revId": "be4f717fb9c5b90cb248bd85a8fe512f216ac095",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f881f30_c6a39fd8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 45165
      },
      "writtenOn": "2021-10-26T13:02:01Z",
      "side": 1,
      "message": "If I don\u0027t do this change, there is a link error as following:\ngo build -a -x -ldflags\u003d\u0027-tmpdir\u003d./tmp\u0027 -buildmode\u003dc-shared -o awesome.so awesome.go \u0026\u003e log\n...\n# command-line-arguments\n/go/pkg/tool/linux_mips64le/link: running gcc failed: exit status 1\ncollect2: fatal error: ld terminated with signal 10 [Bus error], core dumped\ncompilation terminated.\n/usr/bin/ld: tmp/go.o: relocation R_MIPS_HI16 against `a local symbol\u0027 can not be used when making a shared object; recompile with -fPIC\n/usr/bin/ld: BFD (GNU Binutils for Debian) 2.31.1 assertion fail ../../bfd/elfxx-mips.c:6550\n/usr/bin/ld: BFD (GNU Binutils for Debian) 2.31.1 assertion fail ../../bfd/elfxx-mips.c:6550\n\nAnd I found the symbol that has R_MIPS_HI16 relocation type.\n    ab70c:       3c170000        lui     s7,0x0\n                        ab70c: R_MIPS_HI16      reflect..stmp_162  \n                        ab70c: R_MIPS_NONE      *ABS*\n                        ab70c: R_MIPS_NONE      *ABS*\n   ab710:       02fcb82d        daddu   s7,s7,gp\n   ab714:       92e10000        lbu     at,0(s7)\n                        ab714: R_MIPS_LO16      reflect..stmp_162\n                        ab714: R_MIPS_NONE      *ABS*\n                        ab714: R_MIPS_NONE      *ABS*\n                        \nI added this change and built go tool chain again, the right relocation type is:\n   ae64c:       df970000        ld      s7,0(gp)\n                        ae64c: R_MIPS_GOT_PAGE  reflect..stmp_162\n                        ae64c: R_MIPS_NONE      *ABS*\n                        ae64c: R_MIPS_NONE      *ABS*\n   ae650:       62e10000        daddi   at,s7,0\n                        ae650: R_MIPS_GOT_OFST  reflect..stmp_162\n                        ae650: R_MIPS_NONE      *ABS*\n                        ae650: R_MIPS_NONE      *ABS*\n   ae654:       90210000        lbu     at,0(at)\n   \n \nThere may be a problem with my expression, I will fix it.",
      "parentUuid": "12deb17f_e679ebcb",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 14,
        "endChar": 13
      },
      "revId": "be4f717fb9c5b90cb248bd85a8fe512f216ac095",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d034b4b8_e7f4d1ff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 45165
      },
      "writtenOn": "2021-10-27T13:09:28Z",
      "side": 1,
      "message": "Hiï¼Œ\n\nFrom the above relocation type error, it can be seen that the relocation type corresponding to the static code is incorrectly used in the assembly process. The assembly process relies on the cmd/compile to generate correct assembly code. Since we modified the MIPS64.rule file and only affected the lower pass to rewrite the SSA, I compared the values that related stmp_162 value nearby the lower pass. It is found that the rule (X) is applied, resulting in symbol merging. \n\nThe original values (before lower pass):\nv3 (?) \u003d SB \u003cuintptr\u003e\n...\nv6 (?) \u003d Addr \u003c*uint8\u003e {\"\"..stmp_162} v3\n...\nv1 (?) \u003d InitMem \u003cmem\u003e\nv7 (+1285) \u003d Load \u003cuint8\u003e v6 v1\n\nThe rule (X):\n(MOVBUload [off1] {sym1} (MOVVaddr [off2] {sym2} ptr) mem) \u0026\u0026 canMergeSym(sym1,sym2) \u0026\u0026 is32Bit(int64(off1)+int64(off2)) \u003d\u003e (MOVBUload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)                   \n\nThe merge results (after lower pass):\nMOVBUload \u003cuint8\u003e {\"\"..stmp_162} v3 v1\n\nThe generated assembly code is as follows(genssa phase):\nv7 00004 (+1285) MOVBU \"\"..stmp_162(SB), R1                  (Y)\n\nOn the other hand, I added the modification to MIPS64.rule of this CL, and analyzed the values that related stmp_162 value nearby the lower pass. It is found that the rule (X) is not applied, and there is no folding of offset and merging of symbols. The final generated assembly code is as follows:\nv57 00004 (+1285) MOVV $\"\"..stmp_162(SB), R1\nv7 00005 (1285) MOVBU (R1), R1\n\nThe stmp_162 variable should be a ADDR type global variable accoring to the decription of v6. Then I substitute the above assembly code into the assembler implementation. There are three findings:\n(1) In shared mode, assembly does not support the loading ADDR type global variables with opcode named MOVBU, the generated assembly code (Y) is not right for assembler.\n(2) The code in which the symbol merging occurs with applying the rule (X) will use case 51 in asmout function to generate machine code, and use relocation type R_ ADDRMIPSU/R_ ADDRMIPS.\n(3) In shared mode, global variable access must use GOT. When the assembler rewrites the assembly code for ADDR type, only MOVV type instructions are rewritten at present. The information that stmp_162 is ADDR type is lost caused by rewrite in lower pass.\n\nTherefore, I think the reasons for adding this CL are as following:\nIn the shared mode, GOT must be used to access global variables. To use GOT, the assembly code needs to be rewritten to use GOT in the assembler. To simplify the implementation of assembler and prevent information loss caused by rewrite in lower pass. We need to limit the rewrite that related to GOT. The limit condition is: \n(ptr.Op !\u003d OpSB || !config.ctxt.Flag_shared)\n\nThanks!",
      "parentUuid": "5f881f30_c6a39fd8",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 14,
        "endChar": 13
      },
      "revId": "be4f717fb9c5b90cb248bd85a8fe512f216ac095",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce2ba392_3aea05eb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 45165
      },
      "writtenOn": "2021-10-28T01:54:55Z",
      "side": 1,
      "message": "Done! PTAL.",
      "parentUuid": "d034b4b8_e7f4d1ff",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 14,
        "endChar": 13
      },
      "revId": "be4f717fb9c5b90cb248bd85a8fe512f216ac095",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f2950e3_f9d87aca",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-10-28T14:36:05Z",
      "side": 1,
      "message": "Yes, I understand what\u0027s going on here. The problem is that the assembly backend (your next CL) seems not correctly rewriting a load from global variable to use GOT. I didn\u0027t look into your next CL to see why it doesn\u0027t, but it seems not. It probably should. In the end there can be user-written assembly code that loads from a global variable and we should handle that correctly. I.e. the assembler should be able to rewrite\n\nMOVBU x(SB), R1\n\nto something like\n\nMOVV x@GOT(SB), Rtmp;  MOVBU (Rtmp), R1\n\nI can see why these rules are beneficial: If there are a sequence of such loads/stores in nearby addresses, we only want to load the address from GOT once instead of every time. But again, the reasoning here doesn\u0027t sound right. Thanks.\n\n\n\u003e assembly does not support the loading ADDR type global variables \n\nSorry, I don\u0027t understand this. What is ADDR type global variable?",
      "parentUuid": "ce2ba392_3aea05eb",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 14,
        "endChar": 13
      },
      "revId": "be4f717fb9c5b90cb248bd85a8fe512f216ac095",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7728da8_e481a54a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 45165
      },
      "writtenOn": "2021-10-29T11:06:05Z",
      "side": 1,
      "message": "Sorry. Here ADDR type global variable, what I want to say is a global variable with prog.Type \u003d\u003d obj.TYPE_ADDR (look like $sym(SB)).\nI\u0027m developing the code. I\u0027ll reply to you as soon as possible.",
      "parentUuid": "1f2950e3_f9d87aca",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 14,
        "endChar": 13
      },
      "revId": "be4f717fb9c5b90cb248bd85a8fe512f216ac095",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76c2fde8_182baa64",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 45165
      },
      "writtenOn": "2021-11-04T13:09:13Z",
      "side": 1,
      "message": "\u003e The problem is that the assembly backend (your next CL) seems not correctly rewriting a load from global variable to use GOT. I didn\u0027t look into your next CL to see why it doesn\u0027t, but it seems not. It probably should. In the end there can be user-written assembly code that loads from a global variable and we should handle that correctly. I.e. the assembler should be able to rewrite\n\n\u003e MOVBU x(SB), R1\n\n\u003e to something like\n\n\u003e MOVV x@GOT(SB), Rtmp;  MOVBU (Rtmp), R1\n\nI have changed the code (rewriteToUseGot \u0026 asmout function) in my next CL(cmd/internal). The code rewritting is OK now.\n\n\u003e I can see why these rules are beneficial: If there are a sequence of such loads/stores in nearby addresses, we only want to load the address from GOT once instead of every time. But again, the reasoning here doesn\u0027t sound right. Thanks.\n\nYes, you are right. I changed the next CL(cmd/internal) and it can work normally without modifying the rules. \n\nThanks, I have done the work, PTAL.",
      "parentUuid": "c7728da8_e481a54a",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 14,
        "endChar": 13
      },
      "revId": "be4f717fb9c5b90cb248bd85a8fe512f216ac095",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}