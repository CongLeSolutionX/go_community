{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2e683577_a62e58ce",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 25391
      },
      "writtenOn": "2023-11-21T23:18:13Z",
      "side": 1,
      "message": "this is normally called on the systemstack, but I don\u0027t remember why. it doesn\u0027t have the annotation which is even more confusing. :(",
      "range": {
        "startLine": 37,
        "startChar": 6,
        "endLine": 37,
        "endChar": 14
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95328db3_54e01ece",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 5056
      },
      "writtenOn": "2023-12-05T20:51:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2e683577_a62e58ce",
      "range": {
        "startLine": 37,
        "startChar": 6,
        "endLine": 37,
        "endChar": 14
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc3e49db_94874428",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 25391
      },
      "writtenOn": "2023-11-21T23:18:13Z",
      "side": 1,
      "message": "I\u0027m not sure I follow why a CAS would be necessary here",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 62,
        "endChar": 18
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a2ae3a7_7289782a",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5056
      },
      "writtenOn": "2023-12-05T20:51:43Z",
      "side": 1,
      "message": "Stale comment. Removed.",
      "parentUuid": "cc3e49db_94874428",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 62,
        "endChar": 18
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e972867f_289287b9",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 25391
      },
      "writtenOn": "2023-11-21T23:18:13Z",
      "side": 1,
      "message": "this needs to be modeled in the execution tracer, but I\u0027m not sure what the best way to model it is. we can have a pair of GoBlock and GoStart events, but that seems expensive. we can also add a new GoSwitch event to make that a single event but it\u0027s a bit more work in the parser (should be easy though).\n\nhappy to do this work to keep the tracer overhead low for coroutine switches. for now, you can probably get everything happy with the tracer by doing:\n\n```\ntrace :\u003d traceAcquire()\nif !gp.atomicstatus.CompareAndSwap(_Grunning, _Gwaiting) {\n    // The CAS failed: use casgstatus, which will take care of\n    // coordinating with the garbage collector about the state change.\n    casgstatus(gp, _Grunning, _Gwaiting)\n}\nif trace.ok() {\n    trace.GoBlock(...)\n    traceRelease(trace)\n}\n...\ntrace :\u003d traceAcquire()\nif !gnext.atomicstatus.CompareAndSwap(_Gwaiting, _Grunning) {\n    // The CAS failed: use casgstatus, which will take care of\n    // coordinating with the garbage collector about the state change.\n    casgstatus(gnext, _Gwaiting, _Grunnable)\n    casgstatus(gnext, _Grunnable, _Grunning)\n}\nif trace.ok() {\n    trace.GoStart(...)\n    traceRelease(trace)\n}\n```",
      "range": {
        "startLine": 95,
        "startChar": 6,
        "endLine": 95,
        "endChar": 58
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "680c4045_7b587628",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 5056
      },
      "writtenOn": "2023-12-05T20:51:43Z",
      "side": 1,
      "message": "I think this is too heavyweight: it\u0027s two more atomic loads (during traceAcquire) even when the tracer is off. The tracer should not be this expensive generally, but especially here.\n\nAlso this can\u0027t be the right place for trace.GoStart since it will see the wrong curg. \n\nCan we leave the tracing for after Go 1.22?",
      "parentUuid": "e972867f_289287b9",
      "range": {
        "startLine": 95,
        "startChar": 6,
        "endLine": 95,
        "endChar": 58
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fafcbf0_6e3fd380",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 25391
      },
      "writtenOn": "2023-12-05T21:56:52Z",
      "side": 1,
      "message": "\u003e I think this is too heavyweight: it\u0027s two more atomic loads (during traceAcquire) even when the tracer is off. The tracer should not be this expensive generally, but especially here.\n\nI\u0027ll check this again on arm64, but I ran some smoke test scheduler stress benchmarks on linux/arm64 and didn\u0027t notice any meaningful performance difference. the load should be very cacheable since the value changes so infrequently, so even if it needs to stall for the barrier, the stall should be very short. similarly, the branch following the load should be very predictable.\n\nalso sorry, my example above was unnecessarily slow. you can hold `trace` across all 3 CAS operations.\n\n\u003e Also this can\u0027t be the right place for trace.GoStart since it will see the wrong curg.\n\nthat\u0027s true for the way trace.GoStart is currently implemented (and you\u0027re right, would be broken if it was just called directly), but a GoStart event is the right way to model this scheduler interaction without adding any new events.\n\nactually, this is even worse than I proposed -- the tracer has no way to model a direct transition from waiting -\u003e running. it currently always goes through runnable, so this would need a GoUnblock event as well.\n\nI think a bespoke coroutine switch event is really the right call here. I do not mind implementing it in a follow-up CL; it\u0027ll take an hour at worst for the new tracer. (unfortunately it\u0027ll take longer for the old tracer, because all the downstream tooling for it needs to be aware of all events. ðŸ˜ž)\n\n\u003e Can we leave the tracing for after Go 1.22?\n\nonly if we\u0027re OK with broken traces. if a goroutine blocks after the coroutine switch the trace parser is always going to have the wrong state to handle that. it is a GOEXPERIMENT, so I\u0027m not opposed, but if we do decide to leave traces broken then that should probably be documented.\n\nalternatively, since it is just a GOEXPERIMENT, is there any reason not to just support it and make it faster for the real thing, if it really does matter for performance?",
      "parentUuid": "680c4045_7b587628",
      "range": {
        "startLine": 95,
        "startChar": 6,
        "endLine": 95,
        "endChar": 58
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "01a0c09c_4ca5f052",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 5056
      },
      "writtenOn": "2023-12-06T20:18:21Z",
      "side": 1,
      "message": "Added comments. I\u0027m OK with broken traces.\n(The whole point of this package is to show the expected performance,\nso shipping something unnecessarily slow seems like a mistake.)",
      "parentUuid": "0fafcbf0_6e3fd380",
      "range": {
        "startLine": 95,
        "startChar": 6,
        "endLine": 95,
        "endChar": 58
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84520190_109bb741",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 25391
      },
      "writtenOn": "2023-11-21T23:18:13Z",
      "side": 1,
      "message": "I\u0027m having some difficulty reasoning about this as a non-atomic load on weak memory architectures. I could be convinced it\u0027s correct, but IMO it would be a bit clearer to make this atomic.",
      "range": {
        "startLine": 109,
        "startChar": 2,
        "endLine": 109,
        "endChar": 14
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ae96437_10015e81",
        "filename": "src/runtime/coro.go",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 5056
      },
      "writtenOn": "2023-12-05T20:51:43Z",
      "side": 1,
      "message": "Added a comment. The speed of this code path is measured in atomic operations, so adding another here is not great. Nothing bad can happen because of the cas, and if memory is out of sync, the cas will take care of it, so it\u0027s not like the loop will run forever either.",
      "parentUuid": "84520190_109bb741",
      "range": {
        "startLine": 109,
        "startChar": 2,
        "endLine": 109,
        "endChar": 14
      },
      "revId": "135df7d99ec5669a6afc0b0004d2a995b2bb6e74",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}