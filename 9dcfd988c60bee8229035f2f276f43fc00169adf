{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ff8ed979_ff495dd2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-04T13:18:39Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d9dcfd988\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "572503e7_32fa0113",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-04T13:27:18Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "ff8ed979_ff495dd2",
      "tag": "autogenerated:trybots~happy",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5191a93_dd9f31b8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-04T13:39:03Z",
      "side": 1,
      "message": "LGTM üëç",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf8ac1b8_04639479",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-04-04T23:01:28Z",
      "side": 1,
      "message": "This is probably reasonable. I\u0027m just trying to understand what exactly the problem is here. The LR is only meaningful for leaf functions, and we only use the pushed LR for unwinding if it is a frameless leaf function. Does this only matter for frameless leaf functions? Also, the injected sigpanic will save the FP on the its own frame, and the FP should point to the actual panicking function, skipping the \"faked\" frame. Or this is an issue if sigpanic immediately triggers a stack grow? Thanks.",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc5dbaae_315f8167",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-04T23:38:28Z",
      "side": 1,
      "message": "\u003e I\u0027m just trying to understand what exactly the problem is here\n\nWe want to make sure arm64 frame pointer support is rock solid. Our approach has been to set the internal `debugCheckBP \u003d true` check to true and try to pass all tests. This CL fixes TestStackWrapperStackPanic failing when `debugCheckBP \u003d true`.\n\nIdeally we\u0027d like to turn `debugCheckBP` on by default to avoid future regressions on frame pointer management.\n\n\u003e Or this is an issue if sigpanic immediately triggers a stack grow? Thanks.\n\nYeah, I think that\u0027s what causes the `debugCheckBP` check to fail here, but I\u0027ll let Nick confirm.",
      "parentUuid": "cf8ac1b8_04639479",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6beb48df_29c0d66b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 57733
      },
      "writtenOn": "2023-04-05T15:12:12Z",
      "side": 1,
      "message": "To clarify the problem we saw: with debugCheckBP enabled, we saw frame pointer check failures in TestStackWrapperPanic. I captured some detailed output in the following gist: https://gist.github.com/nsrip-dd/d131d9d57ede9db4a610557836ccd6bf\n\nEssentially, that tests causes a panic, and then makes some assertions about the call stack collected when recovering from the panic. In this test, the stack happens to grow within this deferred function, so the debugCheckBP check happens. That check fails when looking at the runtime.sigpanic frame. This happens because runtime.sigpanic isn\u0027t called like a regular function, where the caller would record its frame pointer. Instead, preparePanic takes over the stack and then jumps into runtime.sigpanic. The spot where the caller\u0027s frame pointer would have been saved, at the top of the callees stack frame, just has whatever data happened to be on the stack. This CL puts a valid frame pointer there instead.\n\nPractically speaking, doing frame pointer unwinding from within a panic stack still works okay without this change since sigpanic will set up a frame pointer before calling into one of the panic functions. But as Felix said, it would be good if frame pointers are consistent so that we could have that check on all the time and be more confident about frame pointers being handled correctly.",
      "parentUuid": "cc5dbaae_315f8167",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e11d6b9f_a563f26f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-04-05T15:18:25Z",
      "side": 1,
      "message": "Thanks for the explanation, Felix and Nick! It may be helpful to add a comment mentioning that this pushed FP is not used for unwinding, but to make debugCheckBP happy.\n\n\u003e Ideally we\u0027d like to turn debugCheckBP on by default to avoid future regressions on frame pointer management.\n\nWhat is the performance overhead for turning on the check? Maybe we don\u0027t turn it on by default, but we could have special builders to run in this mode (like we have the SSA check builder, lock ranking check builder, race builder, etc.)",
      "parentUuid": "6beb48df_29c0d66b",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dbf58af_eb9d5254",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-05T15:30:59Z",
      "side": 1,
      "message": "Thanks for your review and comments!\n\n\u003e What is the performance overhead for turning on the check?\n\nWe suspect it will be negligible and not show up on benchmarks. We\u0027ll try to measure it.\n\nIf we get to the point where frame pointers are as reliable as return addresses we could consider integrating them into the normal unwinder. This would allow us to skip the `funcspdelta` lookup on arm64/amd64.\n\nSo ultimately this could become a performance win.\n\n\u003e Maybe we don\u0027t turn it on by default, but we could have special builders to run in this mode (like we have the SSA check builder, lock ranking check builder, race builder, etc.)\n\nThat would also work for us. We\u0027re interested in anything that will ensure that frame pointers are highly reliable.",
      "parentUuid": "e11d6b9f_a563f26f",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3ce7d7c_da8af47c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 57733
      },
      "writtenOn": "2023-04-05T15:35:38Z",
      "side": 1,
      "message": "\u003e It may be helpful to add a comment mentioning that this pushed FP is not used for unwinding, but to make debugCheckBP happy.\n\nDone.",
      "parentUuid": "0dbf58af_eb9d5254",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c60b6046_4a1578aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-04-05T15:47:01Z",
      "side": 1,
      "message": "Thanks. I think it is still helpful to mention this is not used for unwinding.",
      "parentUuid": "c3ce7d7c_da8af47c",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38823b72_28f57498",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-05T16:18:50Z",
      "side": 1,
      "message": "Unwinding wasn\u0027t our motivation here, but unless I\u0027m missing something, this patch will also benefit external unwinders such a linux perf?",
      "parentUuid": "c60b6046_4a1578aa",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d04f35c_fb0324a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-04-05T16:31:40Z",
      "side": 1,
      "message": "I honestly don\u0027t know how external unwinders handle the injected frame like sigpanic. As the pushed LR is not always meaningful, I\u0027m not sure this FP would help much. Also, for external unwinder, if I understand correctly, unless we\u0027re in the prologue of sigpanic, it will probably use the saved frame pointer in the sigpanic frame, which should point to the actual panicking frame, skipping over the pushed fake frame. So I don\u0027t think it matters too much. Anyway, saying this is not used by the Go runtime unwinder is probably enough, and helpful. Thanks.",
      "parentUuid": "38823b72_28f57498",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c08f8ac7_2d30dd14",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 57733
      },
      "writtenOn": "2023-04-05T16:36:43Z",
      "side": 1,
      "message": "Cherry beat me to it, but here\u0027s the sequence, as I understand it:\n\n* We\u0027re in function X\n* Function X dereferences a nil pointer or something, and gets a SEGV signal\n* Go\u0027s signal handler takes over the stack, to pretend that runtime.sigpanic was called at the point where the signal happened. It jumps right into runtime.sigpanic.\n* runtime.sigpanic is going to call into another panic function, so it saves the current frame pointer value and sets up its own frame pointer. It could call panicmem, for example.\n* The current frame pointer at that point would have been whatever function X had saved.\n* Lets say we\u0027re now in the panic proper, running a deferred function, and we tried to do frame pointer unwinding at that point.\n* Unwinding gets to the panicmem frame.\n* At this point, the caller\u0027s frame pointer is going to be what sigpanic saved, meaning it\u0027s going to be function X\u0027s frame pointer.\n\nSo we won\u0027t actually visit sigpanic\u0027s frame, as far as I can tell, when we do frame pointer unwinding. Even without this patch, I think that would still be true because sigpanic is going to save the same frame pointer before calling panicmem/etc.\n\nI\u0027ve updated the comments as requested. Okay to mark this as resolved?",
      "parentUuid": "38823b72_28f57498",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}