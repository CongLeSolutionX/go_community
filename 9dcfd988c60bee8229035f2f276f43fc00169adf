{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ff8ed979_ff495dd2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-04T13:18:39Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d9dcfd988\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "572503e7_32fa0113",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-04T13:27:18Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "ff8ed979_ff495dd2",
      "tag": "autogenerated:trybots~happy",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5191a93_dd9f31b8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-04T13:39:03Z",
      "side": 1,
      "message": "LGTM üëç",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf8ac1b8_04639479",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-04-04T23:01:28Z",
      "side": 1,
      "message": "This is probably reasonable. I\u0027m just trying to understand what exactly the problem is here. The LR is only meaningful for leaf functions, and we only use the pushed LR for unwinding if it is a frameless leaf function. Does this only matter for frameless leaf functions? Also, the injected sigpanic will save the FP on the its own frame, and the FP should point to the actual panicking function, skipping the \"faked\" frame. Or this is an issue if sigpanic immediately triggers a stack grow? Thanks.",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc5dbaae_315f8167",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-04T23:38:28Z",
      "side": 1,
      "message": "\u003e I\u0027m just trying to understand what exactly the problem is here\n\nWe want to make sure arm64 frame pointer support is rock solid. Our approach has been to set the internal `debugCheckBP \u003d true` check to true and try to pass all tests. This CL fixes TestStackWrapperStackPanic failing when `debugCheckBP \u003d true`.\n\nIdeally we\u0027d like to turn `debugCheckBP` on by default to avoid future regressions on frame pointer management.\n\n\u003e Or this is an issue if sigpanic immediately triggers a stack grow? Thanks.\n\nYeah, I think that\u0027s what causes the `debugCheckBP` check to fail here, but I\u0027ll let Nick confirm.",
      "parentUuid": "cf8ac1b8_04639479",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6beb48df_29c0d66b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 57733
      },
      "writtenOn": "2023-04-05T15:12:12Z",
      "side": 1,
      "message": "To clarify the problem we saw: with debugCheckBP enabled, we saw frame pointer check failures in TestStackWrapperPanic. I captured some detailed output in the following gist: https://gist.github.com/nsrip-dd/d131d9d57ede9db4a610557836ccd6bf\n\nEssentially, that tests causes a panic, and then makes some assertions about the call stack collected when recovering from the panic. In this test, the stack happens to grow within this deferred function, so the debugCheckBP check happens. That check fails when looking at the runtime.sigpanic frame. This happens because runtime.sigpanic isn\u0027t called like a regular function, where the caller would record its frame pointer. Instead, preparePanic takes over the stack and then jumps into runtime.sigpanic. The spot where the caller\u0027s frame pointer would have been saved, at the top of the callees stack frame, just has whatever data happened to be on the stack. This CL puts a valid frame pointer there instead.\n\nPractically speaking, doing frame pointer unwinding from within a panic stack still works okay without this change since sigpanic will set up a frame pointer before calling into one of the panic functions. But as Felix said, it would be good if frame pointers are consistent so that we could have that check on all the time and be more confident about frame pointers being handled correctly.",
      "parentUuid": "cc5dbaae_315f8167",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e11d6b9f_a563f26f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-04-05T15:18:25Z",
      "side": 1,
      "message": "Thanks for the explanation, Felix and Nick! It may be helpful to add a comment mentioning that this pushed FP is not used for unwinding, but to make debugCheckBP happy.\n\n\u003e Ideally we\u0027d like to turn debugCheckBP on by default to avoid future regressions on frame pointer management.\n\nWhat is the performance overhead for turning on the check? Maybe we don\u0027t turn it on by default, but we could have special builders to run in this mode (like we have the SSA check builder, lock ranking check builder, race builder, etc.)",
      "parentUuid": "6beb48df_29c0d66b",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dbf58af_eb9d5254",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-05T15:30:59Z",
      "side": 1,
      "message": "Thanks for your review and comments!\n\n\u003e What is the performance overhead for turning on the check?\n\nWe suspect it will be negligible and not show up on benchmarks. We\u0027ll try to measure it.\n\nIf we get to the point where frame pointers are as reliable as return addresses we could consider integrating them into the normal unwinder. This would allow us to skip the `funcspdelta` lookup on arm64/amd64.\n\nSo ultimately this could become a performance win.\n\n\u003e Maybe we don\u0027t turn it on by default, but we could have special builders to run in this mode (like we have the SSA check builder, lock ranking check builder, race builder, etc.)\n\nThat would also work for us. We\u0027re interested in anything that will ensure that frame pointers are highly reliable.",
      "parentUuid": "e11d6b9f_a563f26f",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3ce7d7c_da8af47c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 57733
      },
      "writtenOn": "2023-04-05T15:35:38Z",
      "side": 1,
      "message": "\u003e It may be helpful to add a comment mentioning that this pushed FP is not used for unwinding, but to make debugCheckBP happy.\n\nDone.",
      "parentUuid": "0dbf58af_eb9d5254",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}