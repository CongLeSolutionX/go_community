{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ff8ed979_ff495dd2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-04T13:18:39Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d9dcfd988\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "572503e7_32fa0113",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-04T13:27:18Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "ff8ed979_ff495dd2",
      "tag": "autogenerated:trybots~happy",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5191a93_dd9f31b8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-04T13:39:03Z",
      "side": 1,
      "message": "LGTM üëç",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf8ac1b8_04639479",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-04-04T23:01:28Z",
      "side": 1,
      "message": "This is probably reasonable. I\u0027m just trying to understand what exactly the problem is here. The LR is only meaningful for leaf functions, and we only use the pushed LR for unwinding if it is a frameless leaf function. Does this only matter for frameless leaf functions? Also, the injected sigpanic will save the FP on the its own frame, and the FP should point to the actual panicking function, skipping the \"faked\" frame. Or this is an issue if sigpanic immediately triggers a stack grow? Thanks.",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc5dbaae_315f8167",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2023-04-04T23:38:28Z",
      "side": 1,
      "message": "\u003e I\u0027m just trying to understand what exactly the problem is here\n\nWe want to make sure arm64 frame pointer support is rock solid. Our approach has been to set the internal `debugCheckBP \u003d true` check to true and try to pass all tests. This CL fixes TestStackWrapperStackPanic failing when `debugCheckBP \u003d true`.\n\nIdeally we\u0027d like to turn `debugCheckBP` on by default to avoid future regressions on frame pointer management.\n\n\u003e Or this is an issue if sigpanic immediately triggers a stack grow? Thanks.\n\nYeah, I think that\u0027s what causes the `debugCheckBP` check to fail here, but I\u0027ll let Nick confirm.",
      "parentUuid": "cf8ac1b8_04639479",
      "revId": "9dcfd988c60bee8229035f2f276f43fc00169adf",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}