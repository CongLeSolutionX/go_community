{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "dda3dabb_ce697074",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 8495
      },
      "writtenOn": "2023-03-31T07:57:26Z",
      "side": 1,
      "message": "Drop \"src/\"",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 4
      },
      "revId": "08d055bf6818fef53526df9bce9755af94641b30",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a52c1425_d4721368",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 8495
      },
      "writtenOn": "2023-03-31T07:57:26Z",
      "side": 1,
      "message": "I\u0027m not sure what this means. The \"encoding/json\" package doesn\u0027t automatically escape large integers.\n\nSee https://go.dev/play/p/obLT5-zmgb7",
      "range": {
        "startLine": 20,
        "startChar": 2,
        "endLine": 20,
        "endChar": 62
      },
      "revId": "08d055bf6818fef53526df9bce9755af94641b30",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae436e47_1e5bbe08",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-03-30T23:23:25Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d08d055bf\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "08d055bf6818fef53526df9bce9755af94641b30",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d660d5d_3c266a96",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-03-30T23:26:55Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003d08d055bf\nFailed on freebsd-amd64-12_3: https://storage.googleapis.com/go-build-log/08d055bf/freebsd-amd64-12_3_eff0d0b2.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "ae436e47_1e5bbe08",
      "tag": "autogenerated:trybots~progress",
      "revId": "08d055bf6818fef53526df9bce9755af94641b30",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d76b9c4_29a94da3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-03-30T23:31:47Z",
      "side": 1,
      "message": "10 of 44 TryBots failed.\nFailed on freebsd-amd64-12_3: https://storage.googleapis.com/go-build-log/08d055bf/freebsd-amd64-12_3_eff0d0b2.log\nFailed on linux-arm64: https://storage.googleapis.com/go-build-log/08d055bf/linux-arm64_66a20ec8.log\nFailed on linux-amd64-boringcrypto: https://storage.googleapis.com/go-build-log/08d055bf/linux-amd64-boringcrypto_c16607c9.log\nFailed on linux-amd64: https://storage.googleapis.com/go-build-log/08d055bf/linux-amd64_bfc8b598.log\nFailed on js-wasm-node18: https://storage.googleapis.com/go-build-log/08d055bf/js-wasm-node18_14d4a00b.log\nFailed on linux-386: https://storage.googleapis.com/go-build-log/08d055bf/linux-386_9b4affc4.log\nFailed on openbsd-amd64-72: https://storage.googleapis.com/go-build-log/08d055bf/openbsd-amd64-72_db05e688.log\nFailed on windows-amd64-2016: https://storage.googleapis.com/go-build-log/08d055bf/windows-amd64-2016_bde12a41.log\nFailed on linux-amd64-race: https://storage.googleapis.com/go-build-log/08d055bf/linux-amd64-race_2ad48574.log\nFailed on windows-386-2016: https://storage.googleapis.com/go-build-log/08d055bf/windows-386-2016_1f7f0d09.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\n",
      "parentUuid": "ae436e47_1e5bbe08",
      "tag": "autogenerated:trybots~failed",
      "revId": "08d055bf6818fef53526df9bce9755af94641b30",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04b4b48c_ab3bb0f5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8495
      },
      "writtenOn": "2023-03-31T07:57:26Z",
      "side": 1,
      "message": "SGTM so long as you\u0027re convinced this is the best output format, rather than doing what the \"github.com/go-json-experiment/json\" prototype does. We\u0027re not particularly tied to using time.Duration.String as the format, but I think there\u0027s a significant benefit to consistency between slog and the possible future v2 \"encoding/json\".\n\nHere\u0027s an overview of possible representations and their strengths and weaknesses. There is no obviously right approach.\n\n* JSON integer in nanoseconds (e.g., 47683228428000)\n  * Pro: It\u0027s what \"encoding/json\" does today.\n  * Con: It lacks any context as to its meaning. Is it in seconds, milliseconds, microseconds, nanoseconds? Lacking context, seconds is often a reasonable first guess.\n  * Con: It overflows the exact representation of float64 in about 104 days, which will reduce accuracy on JSON parsers without real 64-bit integer support.\n  \n* JSON fractional number in seconds (e.g., 47683.228428)\n  * Pro: The presence of a fractional component is a strong signal that this is in seconds.\n  * Con: Its representation in float64 is lossy. For example, `time.Duration(strconv.ParseFloat(\"0.000000015\", 64)*1e9)` results in 14ns (rather than the expected 15ns).\n\n* JSON string using time.Duration.String (e.g., \"13h14m43.228428s\")\n  * Pro: The meaning is fairly unambiguous to a human reader.\n  * Pro: The representation is exact (in that there\u0027s no accidental loss due to float64 handling of JSON parsers).\n  * Pro: There is built-in formatting and parsing of this in Go.\n  * Con: It\u0027s fairly Go specific. The use of \"m\" for minute may be considered non-standard, since the SI symbol for minute is actually \"min\", while \"m\" is usually the unit for meters.\n\n* JSON string using stop-watch representation (e.g., \"13:14:43.228428\")\n  * Pro: This is the reading you often see when reading a stop-watch or also defacto used by popular programs (e.g. `ffmpeg`). There\u0027s more precedence for this representation outside of Go.\n  * Pro: The meaning is fairly unambiguous to a human reader.\n  * Pro: The representation can be exact.\n  * Con: To my knowledge, there\u0027s no standard specification for this.\n  * Con: There\u0027s no native formatter or parser for this in Go.\n  * Con: Representation of small durations is verbose (e.g., 1ns would be \"00:00.000000001\" as opposed to \"1ns\" with time.Duration.String).",
      "revId": "08d055bf6818fef53526df9bce9755af94641b30",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66a49947_3ffdd0f9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8495
      },
      "writtenOn": "2023-03-31T08:17:36Z",
      "side": 1,
      "message": "I mentioned in a different CL another the detriment of nanosecond decimal is that it assumes nanosecond resolution is what we\u0027re going to have forever. Two decades ago, most APIs used microseconds until CPUs got faster and then nanoseconds became more popular, leading to awkwardness where some APIs still operated on microseconds, and yet others on nanoseconds.\n\nCPU frequency has plateaued since the end of Dennard scaling [1] around 2006, and it seems nanosecond resolution is here to stay for some time. However, it\u0027s still entirely possible that some breakthrough technology brings clock speeds higher and then we\u0027re all of a sudden talking about durations at picosecond resolution.\n\n[1] https://en.wikipedia.org/wiki/Dennard_scaling",
      "parentUuid": "04b4b48c_ab3bb0f5",
      "revId": "08d055bf6818fef53526df9bce9755af94641b30",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}