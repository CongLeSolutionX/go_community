{
  "comments": [
    {
      "key": {
        "uuid": "9ceae06a_8316f7e9",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-10-04T18:16:31Z",
      "side": 1,
      "message": "Thinking about this some more, if we used a `chan token` for wrMu we could eliminate these fields: we can close wrCh instead of using a separate channel.\n\nThe locking discipline would make it something like:\n\nfunc (p *pipe) unblock() {\n\tselect {\n\tcase p.sem \u003c- token{}:\n\t\tdefer func() { \u003c-p.sem}()\n\t\tselect {\n\t\tcase \u003c-p.wrCh:\n\t\t\treturn  // Already unblocked.\n\t\tdefault:\n\t\t}\n\tcase _, ok :\u003d \u003c-p.wrCh:\n\t\tif !ok {\n\t\t\treturn  // Already unblocked.\n\t\t}\n\t\t// Interrupted a pending Write, which is now blocked on our reply.\n\t}\n\tclose(p.wrCh)\n}\n\nfunc (p *pipe) CloseRead(err error) error {\n\t…\n\tp.rerr.Store(err)\n\tp.unblock()\n\treturn nil\n}\n\nfunc (p *pipe) CloseWrite(err error) error {\n\t…\n\tp.werr.Store(err)\n\tp.unblock()\n\treturn nil\n}\n\nfunc (p *pipe) Write(b []byte) (n int, err error) {\n\tp.sem \u003c- token{}\n\tdefer func() { \u003c-p.sem }()\n\n\tselect {\n\tcase \u003c-p.wrCh:\n\t\treturn 0, p.writeCloseError()\n\tdefault:\n\t}\n\n\tfor {\n\t\tp.wrCh \u003c- b\n\t\tselect {\n\t\tcase \u003c-p.wrCh:\n\t\t\t// Interrupted by unblock.\n\t\t\treturn n, p.writeCloseError()\n\t\tcase dn :\u003d \u003c-p.rdCh:\n\t\t\tn +\u003d dn\n\t\t\tb \u003d b[dn:]\n\t\t}\n\t\tif len(b) \u003d\u003d 0 {\n\t\t\treturn n, nil\n\t\t}\n\t}\n}\n\nfunc (p *pipe) Read(b []byte) (n int, err error) {\n\tfor bw :\u003d range p.wrCh {\n\t\tnr :\u003d copy(b, bw)\n\t\tp.rdCh \u003c- nr\n\t\tif nr \u003e 0 {\n\t\t\treturn nr, nil\n\t\t}\n\t}\n\treturn 0, p.readCloseError()\n}",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 26,
        "endChar": 19
      },
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "843ce454_598892aa",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-10-09T21:13:41Z",
      "side": 1,
      "message": "My thoughts:\n* The performance is basically the same as patch set 2 for the case where we\u0027re just bouncing Reads and Writes off of each other (probably most common use case).\n* The main advantage of this is that it reduces the pipe struct by ~24B (sync.Once and chan struct{}).\n* However, it increasing complexity by:\n  * folding the protection of sync.Once into a semaphore channel, which is used by Write as well.\n  * folding the done channel\u0027s broadcast into wrCh. The fact that we need to select over both wrCh and rdCh in Write is unfortunate.\n\nBTW, the original pipe struct occupied 192B. My version in patch set 2 is 80B, while yours is 56B. However, this does not count the bytes allocated when making the channels. Note that both my version and yours have 3 channels.",
      "parentUuid": "9ceae06a_8316f7e9",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 26,
        "endChar": 19
      },
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67211ed0_4faf534b",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-10-10T15:49:21Z",
      "side": 1,
      "message": "\u003e My thoughts:\n\u003e * The performance is basically the same as patch set 2 for the case where we\u0027re just bouncing Reads and Writes off of each other (probably most common use case).\n\u003e * The main advantage of this is that it reduces the pipe struct by ~24B (sync.Once and chan struct{}).\n\u003e * However, it increasing complexity by:\n\u003e   * folding the protection of sync.Once into a semaphore channel, which is used by Write as well.\n\u003e   * folding the done channel\u0027s broadcast into wrCh. The fact that we need to select over both wrCh and rdCh in Write is unfortunate.\n\nYep, I think that\u0027s a fair assessment. So keeping the Mutex version seems mostly harmless.\n\n\n\u003e BTW, the original pipe struct occupied 192B. My version in patch set 2 is 80B, while yours is 56B. However, this does not count the bytes allocated when making the channels. Note that both my version and yours have 3 channels.\n\nYep. But note that 56B potentially puts the whole struct in one cache line, whereas 80B puts rerr and werr in a separate cache line from wrCh and rdCh.  :)\n\n(You could mitigate that somewhat by placing wrMu and once at the end of the struct, so that the second cache miss only occurs for Write and Close calls.)",
      "parentUuid": "843ce454_598892aa",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 26,
        "endChar": 19
      },
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "66c69668_0511e32a",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-10-10T18:08:06Z",
      "side": 1,
      "message": "I think I\u0027ll keep it as is. There is a stylistic benefit to keep the mutex right above what it protects (and once right above what it protects).\n\nIgnoring the last two atomic.Value fields, the rest of the fields are 48B, and will fit in a single cache line. That being said, I\u0027m not sure if Go\u0027s memory allocator even creates objects on 64B boundaries.",
      "parentUuid": "67211ed0_4faf534b",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 26,
        "endChar": 19
      },
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c8a5929_0f789e03",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-10-04T18:16:31Z",
      "side": 1,
      "message": "“Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) \u003d\u003d 0.”\n\nWhat happens in this draft if the caller issues a `Write(nil)` on the PipeWriter concurrent to a `Read(p)` with a non-zero-length `p`? (And what was the behavior before this change?)",
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf418bba_e1f03834",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-10-09T21:13:41Z",
      "side": 1,
      "message": "A Write(nil) blocks until there is a corresponding Read(p) where p may be any length including zero.\n\nThe \"for once :\u003d true; once || len(b) \u003e 0; once \u003d false\" logic in Write was added to replicate this behavior.",
      "parentUuid": "2c8a5929_0f789e03",
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5bfaadde_336c778d",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-10-10T15:49:21Z",
      "side": 1,
      "message": "\u003e A Write(nil) blocks until there is a corresponding Read(p) where p may be any length including zero.\n\u003e \n\u003e The \"for once :\u003d true; once || len(b) \u003e 0; once \u003d false\" logic in Write was added to replicate this behavior.\n\nThat covers Write, not Read: arguably a Write(nil) ought to block until there is any Read(p), but to comply with the io.Reader best practice the Read(p) should not unblock until a Write with a non-empty payload occurs.",
      "parentUuid": "bf418bba_e1f03834",
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7698e95_a4b67688",
        "filename": "src/io/pipe.go",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 9735
      },
      "writtenOn": "2017-10-10T18:08:06Z",
      "side": 1,
      "message": "r.Read(nil) also blocks: https://play.golang.org/p/rLmfdBBPnH\n\nio.Reader doesn\u0027t explicitly say a read of zero bytes should not block. Let\u0027s keep the previous behavior.\n\nThe new implementation maintains the old behavior where a non-empty Read blocks until there is another Write. Even if that Write is empty, it still unblocks.",
      "parentUuid": "5bfaadde_336c778d",
      "revId": "cab2e9a87c4d7c34d06e64570288b01ff23caef7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}