{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a0ba574a_af1df45e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 68008
      },
      "writtenOn": "2024-06-26T17:05:17Z",
      "side": 1,
      "message": "Hello, it looks like the tests failures of TryBots were due version difference. I\u0027ve just rebased the changes. Could you please restart the tests?",
      "revId": "536fcf51a11aac58aae6b53b362bb40f5614eb4e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c659c54_2eb20fb2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 6005
      },
      "writtenOn": "2024-07-25T21:48:38Z",
      "side": 1,
      "message": "@khr@golang.org You +2ed this but this was previously waiting for the tree to reopen. Submit now?",
      "revId": "536fcf51a11aac58aae6b53b362bb40f5614eb4e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcc6f7ab_bafde93d",
        "filename": "test/codegen/tailcall.go",
        "patchSetId": 5
      },
      "lineNbr": 11,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-07-25T22:20:29Z",
      "side": 1,
      "message": "Do these JMPs really get the line number here? I would hope they would be at line 17, where Bar is defined.\nMaybe that\u0027s not the case though. Possibly related, CL 416455.",
      "revId": "536fcf51a11aac58aae6b53b362bb40f5614eb4e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0963b9ec_af9966f8",
        "filename": "test/codegen/tailcall.go",
        "patchSetId": 5
      },
      "lineNbr": 11,
      "author": {
        "id": 68008
      },
      "writtenOn": "2024-07-27T19:41:46Z",
      "side": 1,
      "message": "Yes, the JMPs get this line number because the OTAILCALL is created with `method.Pos` instead of just `pos` line number. This seems more convenient because `pos` obtained currently is \u003cautogenerated\u003e (also it allows to attach a check for the `asmcheck` test -- it seems it cannot check the \u003cautogenerated\u003e lines currently). On the other hand, this may be inconsistent for the two different cases (tail call and regular call+return), so probably better to use `pos` in this case (and maybe change the `pos` passed to the `addTailCall` function in some separate MR).",
      "parentUuid": "bcc6f7ab_bafde93d",
      "revId": "536fcf51a11aac58aae6b53b362bb40f5614eb4e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4cfc157b_f0faefaa",
        "filename": "test/codegen/tailcall.go",
        "patchSetId": 5
      },
      "lineNbr": 13,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-07-25T22:20:29Z",
      "side": 1,
      "message": "More generally, I\u0027m not sure making a tail call is always the right thing to do. Particularly, if the standard call will be inlined we end up with better code.\n\nThis example is a case in point. Before your CL, `Bar.GetVals` and `(*Bar).GetVals` are both very short and contain no calls at all, tail or otherwise, because the call to (*Foo).GetVals was inlined. After your CL, the inlining doesn\u0027t happen.\n\nMaybe that could be fixed by teaching the inliner to inline tail calls, although that does seem a bit odd. The other possibility is to only convert to a tail call if we know the regular call won\u0027t inline.",
      "revId": "536fcf51a11aac58aae6b53b362bb40f5614eb4e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f9ace22_039cbd48",
        "filename": "test/codegen/tailcall.go",
        "patchSetId": 5
      },
      "lineNbr": 13,
      "author": {
        "id": 68008
      },
      "writtenOn": "2024-07-27T19:41:46Z",
      "side": 1,
      "message": "Yes, there\u0027s a tradeoff between code size and performance and in some cases inlining into the wrapper should be more efficient. I\u0027ll try and measure the second approach that you suggest, maybe it should be enough to add a check `!unifiedHaveInlineBody(ir.MethodExprName(dot).Func)` in addition to other conditions before emitting TAILCALL to let inliner handle potentially inlineable functions...",
      "parentUuid": "4cfc157b_f0faefaa",
      "revId": "536fcf51a11aac58aae6b53b362bb40f5614eb4e",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}