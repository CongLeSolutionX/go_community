{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a0b6985e_ede05b9a",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-14T03:10:44Z",
      "side": 1,
      "message": "Is there a particular reason for this to be a regexp rather than a package pattern?\n\nFor `cmd/go` we generally pass package patterns (for cmd/go argument lists) or prefix globs (for `GOPRIVATE` and `GOINSECURE`), so using regular expressions here it seems likely that users will need to convert between the two.",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64ccf6ae_8046e6ac",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-15T15:43:11Z",
      "side": 1,
      "message": "It\u0027s true, this is indeed incompatible with go command package patterns. It just seemed as though it is a bit more flexible/powerful.\n\nFrom my perspective the strength/power of package patterns lies in being able to pick out packages using relative paths, e.g if I am sitting in \"$GOROOT/src/cmd\", it is great to be able to do things like\n\n  $ go test ./internal/obj/...\n\nor\n\n  $ go vet ./compile/internal/...\n\nWhen working with coverage profile data for applications, it seems less likely (at least to me) that folks will be working from within a specific point in their source tree, meaning that picking out specific pieces with patterns seems problematic (maybe there is a way to do this that I don\u0027t know about?).\n\nIf I am working with a coverage profile from Kubernetes kubelet, with a regular xpresssion I can do things like\n\n  $ go tool covdata percent -pkgre\u003dpkg/admission/plugin/webhook/config -i\u003d./covdata\n  k8s.io/apiserver/pkg/admission/plugin/webhook/config\tcoverage: 15.8% of statements\n  k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission\tcoverage: 18.8% of statements\n  k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1\tcoverage: 24.1% of statements\n k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1alpha1\tcoverage: 24.1% of statements\n  $\n  \nIs there a straightforward way to do that with package patterns, other than locating the proper place in the source hierarchy and then running \"go tool covdata\" from there?\n\nThere is also the question of implementation (I had assumed that the machinery for package pattern matching was all internal to the go tool).",
      "parentUuid": "a0b6985e_ede05b9a",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f33b34e_f8008ef2",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-16T15:19:19Z",
      "side": 1,
      "message": "\u003e It\u0027s true, this is indeed incompatible with go command package patterns. It just seemed as though it is a bit more flexible/powerful.\n\u003e \n\u003e From my perspective the strength/power of package patterns lies in being able to pick out packages using relative paths, e.g if I am sitting in \"$GOROOT/src/cmd\", it is great to be able to do things like\n\u003e \n\u003e   $ go test ./internal/obj/...\n\u003e \n\u003e or\n\u003e \n\u003e   $ go vet ./compile/internal/...\n\u003e \n\u003e When working with coverage profile data for applications, it seems less likely (at least to me) that folks will be working from within a specific point in their source tree, meaning that picking out specific pieces with patterns seems problematic (maybe there is a way to do this that I don\u0027t know about?).\n\u003e \n\u003e If I am working with a coverage profile from Kubernetes kubelet, with a regular xpresssion I can do things like\n\u003e \n\u003e   $ go tool covdata percent -pkgre\u003dpkg/admission/plugin/webhook/config -i\u003d./covdata\n\u003e   k8s.io/apiserver/pkg/admission/plugin/webhook/config\tcoverage: 15.8% of statements\n\u003e   k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission\tcoverage: 18.8% of statements\n\u003e   k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1\tcoverage: 24.1% of statements\n\u003e  k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1alpha1\tcoverage: 24.1% of statements\n\u003e   $\n\u003e   \n\u003e Is there a straightforward way to do that with package patterns, other than locating the proper place in the source hierarchy and then running \"go tool covdata\" from there?\n\nYes: a package pattern can have an arbitrary prefix, not just `./`, and that prefix can even include wildcards. So for that particular case you could run\n```\ngo tool covdata percent -pkg\u003dk8s.io/apiserver/pkg/admission/plugin/webhook/config/...\n```\nor even\n```\ngo tool covdata percent -pkg\u003d.../pkg/admission/plugin/webhook/config/...\n```\n\n\n\u003e There is also the question of implementation (I had assumed that the machinery for package pattern matching was all internal to the go tool).\n\nIt is, at the moment (in `cmd/go/internal/search.MatchPattern`, and to a lesser extent the `IsMetaPackage` function in the same package). But as far as I am aware there is no fundamental reason that functionality couldn\u0027t be moved to `cmd/internal`.",
      "parentUuid": "64ccf6ae_8046e6ac",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25dfcd78_e8cae8d3",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-20T19:14:17Z",
      "side": 1,
      "message": "I took an initial look at separating out the package pattern matching\nlogic from cmd/go/internal/search into a new dir in cmd/internal.\n\nThere is a fair amount of logic in the search code for handling relative\nimport path references (e.g. ./cmd/foo, ./x/..., etc), and for\nensuring that wildcards don\u0027t pick up things in vendor directories.\n\nThis makes me wonder whether or how it makes sense to support relative\npackage paths for \"go tool covdata\". \n\nFor commands like \"go build\" or \"go test\", users have been trained\nover the years to understand that when they refer to packages, those\npackages can be relative to GOPATH, GOROOT, or the module or modules\nthey are working with, depending on where they are relative to those\ndirs (most of which have concrete representations in the filesystem).\n\nWhen running \"go tool covdata\" on a corpus of coverage data files, it is not\nclear that this same usage pattern is going to hold (e.g. running the\ntool from within the module source tree or equivalent). \n\nSo for example, if a user does:\n\n  $ cd myapp\n  $ go build -cover -o myapp.exe cmd/app\n  $ GOCOVERDIR\u003d/tmp/cdata ./myapp.exe ...\n  $\n\nit\u0027s possible to imagine more than once way of looking at the data. One way would be to run the \"covdata\" command from within the module, in which case relative paths make sense, e.g.\n\n  $ cd mymodrepo\n  $ go tool covdata percent -pkgpat\u003d./cmd/internal/... -i\u003d/tmp/cdata\n  myapp/cmd/internal/first \tcoverage: 74.4% of statements\n  myapp/cmd/internal/second \tcoverage: 93.4% of statements\n  $\n\nhowever if the user runs \"go tool covdata\" somewhere else, then there is no way to interpret the relative paths.\n\nIt seems unfriendly to reject this sort of usage model entirely (e.g. require that you always have to be within your source tree), but I suppose we could issue an error if this happens, e.g. \n\n  $ cd /tmp/cdata\n  $ go tool covdata percent -pkgpat\u003d./cmd/internal/... -i\u003d.\n  \u003cerror\u003e\n  $ \n\nOn the other hand it might be an easier model for users if we just\nask them to fall back just on paths and wildcards (and not relative refs).\n\nDo you have any thoughts on this?",
      "parentUuid": "3f33b34e_f8008ef2",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2933898f_6a5e0ddf",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-20T19:38:14Z",
      "side": 1,
      "message": "I think it would be fine to require that the arguments to `go tool covdata` be absolute package patterns, given that the tool invocation could be in a completely different location from the `go build` command that generated the binary.\n\nAre there cases that involve `go test` (without running a separate binary) that would become awkward? Those are about the only ones I can think of where ‚Äú`.`‚Äù remains well-defined. ü§î",
      "parentUuid": "25dfcd78_e8cae8d3",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c59545fb_bd643e45",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-14T03:10:44Z",
      "side": 1,
      "message": "Given that we know the module path for each package, it seems like it would be more flexible (and more consistent with other module tooling) to filter on module paths ‚Äî perhaps a list of exact module paths, or a list of module path patterns (as would be passed to `go list -m`)?\n\nI could reasonably see users running coverage to answer questions like ‚Äúwhat are we actually using from \u003cdependency we\u0027d like to drop\u003e?‚Äù or ‚Äúwhat is \u003cimportant customer\u003e actually using from \u003cour module\u003e?‚Äù, but in those cases the coverage you\u0027d be after is either a package pattern or a single specific module. (The use-case for ‚Äúeverything but the main module‚Äù is maybe interesting for exploration, but doesn\u0027t seem as central as asking about either specific modules or the entire program.)",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40310e9a_15d1f9f0",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-14T14:06:29Z",
      "side": 1,
      "message": "I would like to point out that this feature (the distinction between \"main module\" only, \"dependencies listed in go.mod\" and \"all packages, including stdlib) is something that has been part of my design since day one. It was in the original internal design document, it was in the public proposal that was circulated + discussed + accepted, and it was in the first version of my CLs that I sent you to review last May (more than four months ago).\n\nBased on your comment here (as well as your previous comment in https://go-review.git.corp.google.com/c/go/+/355452/comment/132e87b7_cee2c3d8/ ) it is now finally becoming clear to me that you feel it is basically just a bad idea at any level and in any form (either in the cmd/go \"-coverpkg\u003dmod.main\" syntax or here as an option for cmd/covdata), and I have to say I am a bit frustrated by the timing.  It would have been great if you could have made your objections known a little earlier on in the process. Oh well.\n\nI personally feel that the ability to refer to dependent packages (those pulled in via go.mod but not part of the main module) via this sort of special syntax as a useful feature, but at this point I don\u0027t think I want to try to argue/discuss any more about it. I will defer to your expertise and remove it, in the interests of moving the project along.\n\nThanks.",
      "parentUuid": "c59545fb_bd643e45",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad58f5e1_1267a161",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-14T17:11:38Z",
      "side": 1,
      "message": "\u003e I would like to point out that this feature (the distinction between \"main module\" only, \"dependencies listed in go.mod\" and \"all packages, including stdlib) is something that has been part of my design since day one. It was in the original internal design document, it was in the public proposal that was circulated + discussed + accepted, and it was in the first version of my CLs that I sent you to review last May (more than four months ago).\n\u003e \n\u003e Based on your comment here (as well as your previous comment in https://go-review.git.corp.google.com/c/go/+/355452/comment/132e87b7_cee2c3d8/ ) it is now finally becoming clear to me that you feel it is basically just a bad idea at any level and in any form (either in the cmd/go \"-coverpkg\u003dmod.main\" syntax or here as an option for cmd/covdata), and I have to say I am a bit frustrated by the timing.  It would have been great if you could have made your objections known a little earlier on in the process. Oh well.\n\nI agree that the distinction has been present throughout the drafts. I had not realized the finer implications of that detail until I looked in more depth at these CLs ‚Äî the current design doc does not mention the `pkgclass` flag, nor the `depmod`, `mainmod`, etc. tokens, nor the `mod.main` package pattern. (The `mod.deps` pattern was mentioned, but only in an example; I apparently overlooked that example.)\n\nI had interpreted that part of the design was a framework for thinking about the concrete command-line interface, with details to be worked out later ‚Äî and I\u0027m not satisfied with how the details have worked out.\n\nI am sorry that I hadn\u0027t been able to pay more attention to this detail earlier in the design process. (This is unfortunately one of several issues I haven\u0027t been able to attend as closely as I\u0027d like, due to a variety of factors.)",
      "parentUuid": "40310e9a_15d1f9f0",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c44c3fe6_88b14b11",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-19T15:06:55Z",
      "side": 1,
      "message": "I have started work on removing package classification from my CL stack.\n\nWithout \"go build -coverpkg\u003dmod.deps\", it seems likely that users who want to see coverage for things outside the main module will be using \"-coverpkg\u003dall\", then filtering by module path later on (so that they can filter out Go stdlib packages and/or select only the dependencies they are interested in).\n\nMy plan is to add a \"-modpaths\" argument to cmd/covdata; this flag will accept a \":\" separated list of module paths, and will restrict output to only those packages whose module path appears in the list. Thus the recipe for \"show me coverage for every package mentioned in my module, but not the Go stdlib\" will be something along the lines of:\n\n  $ go build -coverpkg\u003dall -o myapp.exe .\n  $ GOCOVERDIR\u003d/tmp/dir ./myapp.exe ...\n  $ go list -mod\u003dmod -m all | tr \u0027\\n\u0027 \u0027:\u0027 \u003e modpaths.txt\n  $ go tool covdata percent -modpaths\u003d`cat modpaths.txt`\n  ...\n\nOne mild item of concern is that there doesn\u0027t seem to be a good way to distinguish between packages in the the Go stdlib (which in the current scheme are explicitly tagged via PkgClassification) and packages that have no module path due to a GOPATH-style GO111MODULE\u003doff build. Do we care about this case? E.g. if I do something like\n\n  $ cd `go env GOPATH`\n  $ cd src/tmp/legacy\n  $ cat main.go\n  package main\n  import \"github.com/thanm/sandbox/plex\"\n  func main() {\n  \tprintln(plex.Single())\n  }\n  $ GO111MODULE\u003doff go build -o legacy.exe -coverpkg\u003dall .\n  $ GOCOVERDIR\u003d/tmp/dir ./legacy.exe ...\n  $\n\nAt this point in the collected coverage data none of the packages will have associated module paths, so there is no way I can pick out code just from GOPATH (e.g. filter out the stdlib packages). Let me know if you are ok with this.",
      "parentUuid": "ad58f5e1_1267a161",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b642f8b_aac03fc0",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-19T16:43:31Z",
      "side": 1,
      "message": "\u003e I have started work on removing package classification from my CL stack.\n\u003e \n\u003e Without \"go build -coverpkg\u003dmod.deps\", it seems likely that users who want to see coverage for things outside the main module will be using \"-coverpkg\u003dall\", then filtering by module path later on (so that they can filter out Go stdlib packages and/or select only the dependencies they are interested in).\n\u003e\n\u003e My plan is to add a \"-modpaths\" argument to cmd/covdata; this flag will accept a \":\" separated list of module paths, and will restrict output to only those packages whose module path appears in the list.\n\nMakes sense. That flag could reasonably be comma-separated, too: valid module paths cannot include a bunch of characters, including both `,` and `:`.\n\n\n\u003e Thus the recipe for \"show me coverage for every package mentioned in my module, but not the Go stdlib\" will be something along the lines of:\n\u003e \n\u003e   $ go build -coverpkg\u003dall -o myapp.exe .\n\u003e   $ GOCOVERDIR\u003d/tmp/dir ./myapp.exe ...\n\u003e   $ go list -mod\u003dmod -m all | tr \u0027\\n\u0027 \u0027:\u0027 \u003e modpaths.txt\n\u003e   $ go tool covdata percent -modpaths\u003d`cat modpaths.txt`\n\u003e   ...\n\nThat seems fine, although simpler still would be to only add the flag for filtering by package for now, and relying on `go list` for the module mapping. (That would give us the flexibility to add other filtering flags in the future without committing to any one in particular.)\n\nFWIW, the query to list ‚Äúevery package mentioned in my module, but not the Go stdlib‚Äù is:\n```\ngo list -f \u0027{{if not .Standard}}{{.ImportPath}}{{end}}\u0027 all\n```\n\nThat would give a workflow like:\n```\n$ go list -f \u0027{{if not .Standard}}{{.ImportPath}}{{end}}\u0027 all | tr \u0027\\n\u0027 \u0027,\u0027 \u003e pkgs.txt\n$ go build -coverpkg\u003d$(\u003cpkgs.txt) -o myapp.exe ...\n$ GOCOVERDIR\u003d/tmp/dir ./myapp.exe ...\n$ go tool covdata percent ...\n```\nwhich is very similar to the workflow you listed above, although because it lists packages instead of modules it run a somewhat greater chance of the arguments not fitting on the command line. (Probably at some point `cmd/go` needs to support ‚Äúresponse files‚Äù anyway.)\n\n\n\u003e One mild item of concern is that there doesn\u0027t seem to be a good way to distinguish between packages in the the Go stdlib (which in the current scheme are explicitly tagged via PkgClassification) and packages that have no module path due to a GOPATH-style GO111MODULE\u003doff build. Do we care about this case? E.g. if I do something like\n\u003e \n\u003e   $ cd `go env GOPATH`\n\u003e   $ cd src/tmp/legacy\n\u003e   $ cat main.go\n\u003e   package main\n\u003e   import \"github.com/thanm/sandbox/plex\"\n\u003e   func main() {\n\u003e   \tprintln(plex.Single())\n\u003e   }\n\u003e   $ GO111MODULE\u003doff go build -o legacy.exe -coverpkg\u003dall .\n\u003e   $ GOCOVERDIR\u003d/tmp/dir ./legacy.exe ...\n\u003e   $\n\u003e \n\u003e At this point in the collected coverage data none of the packages will have associated module paths, so there is no way I can pick out code just from GOPATH (e.g. filter out the stdlib packages). Let me know if you are ok with this.\n\nI think that could also be handled using only package filters.\n\nThe query to list ‚Äúevery package in GOPATH but not the stdlib‚Äù is fairly straightforward for non-test dependencies:\n```\ngo list -f \u0027{{if not .Standard}}{{.ImportPath}}{{end}}\u0027 -deps . | sort -u\n```\nIt does get a bit more complicated for test dependencies because of test variants, unfortunately:\n```\ngo list -f \u0027{{if not .Standard}}{{.ImportPath}}{{end}}\u0027 -deps -test . | sort -u | grep -v \u0027\\.test\u0027\n```",
      "parentUuid": "c44c3fe6_88b14b11",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9c0f91e_a4d02791",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-19T17:54:25Z",
      "side": 1,
      "message": "Thanks.\n\nI tried your \"go list -f\" recipe for a couple of apps (Delve, k8s kubelet) and it does appear to have the desired effect. One minor surprise was was a lot of warnings about packages that I listed in -coverpkg but were not being built, e.g.\n\n...\nwarning: no packages being built depend on matches for pattern golang.org/x/mod/semver\nwarning: no packages being built depend on matches for pattern golang.org/x/sys/execabs\nwarning: no packages being built depend on matches for pattern golang.org/x/tools/go/gcexportdata\nwarning: no packages being built depend on matches for pattern golang.org/x/tools/go/internal/gcimporter\n...\n\nIt looks as though what\u0027s happening here is that these packages are coming out of the vendor directory. Perhaps there is some other more sophisticated \"go list -f\" recipe that might prevent this?\n\nRegarding -modpaths: yeah, looks as though \"go list\" would probably do the trick just as well. I\u0027ll put \"-modpaths\" on the shelf for now, can be dusted off later if need be.\n\nI worry a bit about skew there, e.g. I do a \"go build -cover\" at time T, run my application to generate coverage data files, then a week later I run \"go list -f ...\" to generate a package list and then feed that into \"go tool covdata\" without realizing that my go.mod has changed slightly in the intervening time period. On the other hand, I guess this is no different from any of the other scenarios where skew can come into play (with source files, that is), so users just need to be aware of it.",
      "parentUuid": "7b642f8b_aac03fc0",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5f637f6_ce2bcaed",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-20T19:38:14Z",
      "side": 1,
      "message": "\u003e It looks as though what\u0027s happening here is that these packages are coming out of the vendor directory. Perhaps there is some other more sophisticated \"go list -f\" recipe that might prevent this?\n\nHmm... the `vendor` directory should exactly mirror the module dependencies.\n\nWere you using `go list -f` on just the specific package(s) being built, or were you building the whole tree? I see no dependency from `kubelet` on `execabs`, but `k8s.io` includes `execabs` via a different binary:\n\n```\n~/src/k8s.io/kubernetes$ go list -f \u0027{{if not .Standard}}{{.ImportPath}}{{end}}\u0027 -deps -test ./pkg/kubelet | grep execabs\n\n~/src/k8s.io/kubernetes$ go mod why golang.org/x/sys/execabs\n# golang.org/x/sys/execabs\nk8s.io/kubernetes/test/typecheck\ngolang.org/x/tools/go/packages\ngolang.org/x/sys/execabs\n\n~/src/k8s.io/kubernetes$ go list -f \u0027{{if not .Standard}}{{.ImportPath}}{{end}}\u0027 -deps -test ./test/typecheck | grep execabs\ngolang.org/x/sys/execabs\n```",
      "parentUuid": "c9c0f91e_a4d02791",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e50ef4f4_3ad0bbf4",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-20T21:05:49Z",
      "side": 1,
      "message": "\u003eWere you using go list -f on just the specific package(s) being built, or were you building the whole tree? \n\nOK that does indeed seem likely to be what I did (e.g. generated package list with \"go list -f .. all\" , which is going to overshoot for a specific binary). Thanks.",
      "parentUuid": "f5f637f6_ce2bcaed",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}