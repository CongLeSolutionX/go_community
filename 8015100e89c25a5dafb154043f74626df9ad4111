{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a0b6985e_ede05b9a",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-14T03:10:44Z",
      "side": 1,
      "message": "Is there a particular reason for this to be a regexp rather than a package pattern?\n\nFor `cmd/go` we generally pass package patterns (for cmd/go argument lists) or prefix globs (for `GOPRIVATE` and `GOINSECURE`), so using regular expressions here it seems likely that users will need to convert between the two.",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64ccf6ae_8046e6ac",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-15T15:43:11Z",
      "side": 1,
      "message": "It\u0027s true, this is indeed incompatible with go command package patterns. It just seemed as though it is a bit more flexible/powerful.\n\nFrom my perspective the strength/power of package patterns lies in being able to pick out packages using relative paths, e.g if I am sitting in \"$GOROOT/src/cmd\", it is great to be able to do things like\n\n  $ go test ./internal/obj/...\n\nor\n\n  $ go vet ./compile/internal/...\n\nWhen working with coverage profile data for applications, it seems less likely (at least to me) that folks will be working from within a specific point in their source tree, meaning that picking out specific pieces with patterns seems problematic (maybe there is a way to do this that I don\u0027t know about?).\n\nIf I am working with a coverage profile from Kubernetes kubelet, with a regular xpresssion I can do things like\n\n  $ go tool covdata percent -pkgre\u003dpkg/admission/plugin/webhook/config -i\u003d./covdata\n  k8s.io/apiserver/pkg/admission/plugin/webhook/config\tcoverage: 15.8% of statements\n  k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission\tcoverage: 18.8% of statements\n  k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1\tcoverage: 24.1% of statements\n k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1alpha1\tcoverage: 24.1% of statements\n  $\n  \nIs there a straightforward way to do that with package patterns, other than locating the proper place in the source hierarchy and then running \"go tool covdata\" from there?\n\nThere is also the question of implementation (I had assumed that the machinery for package pattern matching was all internal to the go tool).",
      "parentUuid": "a0b6985e_ede05b9a",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f33b34e_f8008ef2",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 23,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-16T15:19:19Z",
      "side": 1,
      "message": "\u003e It\u0027s true, this is indeed incompatible with go command package patterns. It just seemed as though it is a bit more flexible/powerful.\n\u003e \n\u003e From my perspective the strength/power of package patterns lies in being able to pick out packages using relative paths, e.g if I am sitting in \"$GOROOT/src/cmd\", it is great to be able to do things like\n\u003e \n\u003e   $ go test ./internal/obj/...\n\u003e \n\u003e or\n\u003e \n\u003e   $ go vet ./compile/internal/...\n\u003e \n\u003e When working with coverage profile data for applications, it seems less likely (at least to me) that folks will be working from within a specific point in their source tree, meaning that picking out specific pieces with patterns seems problematic (maybe there is a way to do this that I don\u0027t know about?).\n\u003e \n\u003e If I am working with a coverage profile from Kubernetes kubelet, with a regular xpresssion I can do things like\n\u003e \n\u003e   $ go tool covdata percent -pkgre\u003dpkg/admission/plugin/webhook/config -i\u003d./covdata\n\u003e   k8s.io/apiserver/pkg/admission/plugin/webhook/config\tcoverage: 15.8% of statements\n\u003e   k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission\tcoverage: 18.8% of statements\n\u003e   k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1\tcoverage: 24.1% of statements\n\u003e  k8s.io/apiserver/pkg/admission/plugin/webhook/config/apis/webhookadmission/v1alpha1\tcoverage: 24.1% of statements\n\u003e   $\n\u003e   \n\u003e Is there a straightforward way to do that with package patterns, other than locating the proper place in the source hierarchy and then running \"go tool covdata\" from there?\n\nYes: a package pattern can have an arbitrary prefix, not just `./`, and that prefix can even include wildcards. So for that particular case you could run\n```\ngo tool covdata percent -pkg\u003dk8s.io/apiserver/pkg/admission/plugin/webhook/config/...\n```\nor even\n```\ngo tool covdata percent -pkg\u003d.../pkg/admission/plugin/webhook/config/...\n```\n\n\n\u003e There is also the question of implementation (I had assumed that the machinery for package pattern matching was all internal to the go tool).\n\nIt is, at the moment (in `cmd/go/internal/search.MatchPattern`, and to a lesser extent the `IsMetaPackage` function in the same package). But as far as I am aware there is no fundamental reason that functionality couldn\u0027t be moved to `cmd/internal`.",
      "parentUuid": "64ccf6ae_8046e6ac",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c59545fb_bd643e45",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-14T03:10:44Z",
      "side": 1,
      "message": "Given that we know the module path for each package, it seems like it would be more flexible (and more consistent with other module tooling) to filter on module paths — perhaps a list of exact module paths, or a list of module path patterns (as would be passed to `go list -m`)?\n\nI could reasonably see users running coverage to answer questions like “what are we actually using from \u003cdependency we\u0027d like to drop\u003e?” or “what is \u003cimportant customer\u003e actually using from \u003cour module\u003e?”, but in those cases the coverage you\u0027d be after is either a package pattern or a single specific module. (The use-case for “everything but the main module” is maybe interesting for exploration, but doesn\u0027t seem as central as asking about either specific modules or the entire program.)",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40310e9a_15d1f9f0",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 14020
      },
      "writtenOn": "2022-09-14T14:06:29Z",
      "side": 1,
      "message": "I would like to point out that this feature (the distinction between \"main module\" only, \"dependencies listed in go.mod\" and \"all packages, including stdlib) is something that has been part of my design since day one. It was in the original internal design document, it was in the public proposal that was circulated + discussed + accepted, and it was in the first version of my CLs that I sent you to review last May (more than four months ago).\n\nBased on your comment here (as well as your previous comment in https://go-review.git.corp.google.com/c/go/+/355452/comment/132e87b7_cee2c3d8/ ) it is now finally becoming clear to me that you feel it is basically just a bad idea at any level and in any form (either in the cmd/go \"-coverpkg\u003dmod.main\" syntax or here as an option for cmd/covdata), and I have to say I am a bit frustrated by the timing.  It would have been great if you could have made your objections known a little earlier on in the process. Oh well.\n\nI personally feel that the ability to refer to dependent packages (those pulled in via go.mod but not part of the main module) via this sort of special syntax as a useful feature, but at this point I don\u0027t think I want to try to argue/discuss any more about it. I will defer to your expertise and remove it, in the interests of moving the project along.\n\nThanks.",
      "parentUuid": "c59545fb_bd643e45",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad58f5e1_1267a161",
        "filename": "src/cmd/covdata/covdata.go",
        "patchSetId": 61
      },
      "lineNbr": 24,
      "author": {
        "id": 6365
      },
      "writtenOn": "2022-09-14T17:11:38Z",
      "side": 1,
      "message": "\u003e I would like to point out that this feature (the distinction between \"main module\" only, \"dependencies listed in go.mod\" and \"all packages, including stdlib) is something that has been part of my design since day one. It was in the original internal design document, it was in the public proposal that was circulated + discussed + accepted, and it was in the first version of my CLs that I sent you to review last May (more than four months ago).\n\u003e \n\u003e Based on your comment here (as well as your previous comment in https://go-review.git.corp.google.com/c/go/+/355452/comment/132e87b7_cee2c3d8/ ) it is now finally becoming clear to me that you feel it is basically just a bad idea at any level and in any form (either in the cmd/go \"-coverpkg\u003dmod.main\" syntax or here as an option for cmd/covdata), and I have to say I am a bit frustrated by the timing.  It would have been great if you could have made your objections known a little earlier on in the process. Oh well.\n\nI agree that the distinction has been present throughout the drafts. I had not realized the finer implications of that detail until I looked in more depth at these CLs — the current design doc does not mention the `pkgclass` flag, nor the `depmod`, `mainmod`, etc. tokens, nor the `mod.main` package pattern. (The `mod.deps` pattern was mentioned, but only in an example; I apparently overlooked that example.)\n\nI had interpreted that part of the design was a framework for thinking about the concrete command-line interface, with details to be worked out later — and I\u0027m not satisfied with how the details have worked out.\n\nI am sorry that I hadn\u0027t been able to pay more attention to this detail earlier in the design process. (This is unfortunately one of several issues I haven\u0027t been able to attend as closely as I\u0027d like, due to a variety of factors.)",
      "parentUuid": "40310e9a_15d1f9f0",
      "revId": "8015100e89c25a5dafb154043f74626df9ad4111",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}