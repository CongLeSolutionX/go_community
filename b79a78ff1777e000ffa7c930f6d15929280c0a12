{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a49d80a3_6f58e5b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-06-02T19:59:22Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003db79a78ff",
      "tag": "autogenerated:trybots~beginning",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf1b2abe_609cadd5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-06-02T20:29:23Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "a49d80a3_6f58e5b6",
      "tag": "autogenerated:trybots~happy",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e884970e_746e5e46",
        "filename": "src/cmd/compile/internal/noder/decl.go",
        "patchSetId": 1
      },
      "lineNbr": 104,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-06-03T20:48:42Z",
      "side": 1,
      "message": "It\u0027s kind of unfortunate that we have to \"trick\" the export/import code to consider generic functions by pretending their cost is 1. Not to fix in this CL, but maybe export could have a \"generic || inlineable\" condition.",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6350bfd9_3e1183bd",
        "filename": "src/cmd/compile/internal/noder/decl.go",
        "patchSetId": 1
      },
      "lineNbr": 104,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-06-04T17:20:06Z",
      "side": 1,
      "message": "Acknowledged.  I definitely can add a flag in another CL.  We could also rename the Inl struct to something like \"SavedCopy\", since it is a saved or imported copy of a function (dcls and body) before we further process it (instantiate it or use for inlining).",
      "parentUuid": "e884970e_746e5e46",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d3ec8ef_19d895c3",
        "filename": "src/cmd/compile/internal/typecheck/expr.go",
        "patchSetId": 1
      },
      "lineNbr": 315,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-06-03T20:48:42Z",
      "side": 1,
      "message": "Is there a particular reason we\u0027re calling tcCompLit on instantiated functions? I would hope one day we don\u0027t call into the typechecker for instantiated code. Maybe someday...",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "421b1f51_7f5cf031",
        "filename": "src/cmd/compile/internal/typecheck/expr.go",
        "patchSetId": 1
      },
      "lineNbr": 315,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-06-04T17:20:06Z",
      "side": 1,
      "message": "Yes, explicitly setting all the types for the new closure complit (created during the walk phase) seemed to be a lot more invasive code change than adding this check.  But as you say, we do want to eventually get rid of the typechecks of the code/data created during later stages of the compilation.",
      "parentUuid": "4d3ec8ef_19d895c3",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "472177fd_acccb35e",
        "filename": "src/cmd/compile/internal/typecheck/func.go",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-06-03T20:48:42Z",
      "side": 1,
      "message": "Can it be the case that there are no closure variables? Or do we not build a closure at all if that is the case?",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d87133f_4b0e080b",
        "filename": "src/cmd/compile/internal/typecheck/func.go",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-06-04T17:20:06Z",
      "side": 1,
      "message": "Good point!  We do create closures with no closure vars if they are not called right away (e.g. passed to another function).  Added code to deal with no closure vars.  (For some weird reason, we allow a lookup on a nil package, so there was no error.)",
      "parentUuid": "472177fd_acccb35e",
      "revId": "b79a78ff1777e000ffa7c930f6d15929280c0a12",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}