{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4d5c5f3c_6916fa17",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 36863
      },
      "writtenOn": "2022-01-10T17:44:34Z",
      "side": 1,
      "message": "TRY\u003daix-ppc64,ppc64le",
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39ce9db7_c52fbc0a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-10T17:45:49Z",
      "side": 1,
      "message": "SlowBots beginning. Status page: https://farmer.golang.org/try?commit\u003d90671af1",
      "tag": "autogenerated:trybots~beginning",
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be84f60c_6e3f1d35",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-01-10T17:50:26Z",
      "side": 1,
      "message": "Thanks.\n\nThis may be useful to do on other weak memory model architectures. That can be done later.",
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e2d0ae7d_e1760958",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-10T18:15:30Z",
      "side": 1,
      "message": "SlowBots are happy.\n\nSlowBot builds that ran:\n* aix-ppc64\n* linux-ppc64le-buildlet\n",
      "parentUuid": "39ce9db7_c52fbc0a",
      "tag": "autogenerated:trybots~happy",
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aff4ab30_a4e7cef6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 36863
      },
      "writtenOn": "2022-01-10T23:40:27Z",
      "side": 1,
      "message": "@Cl√©ment Regarding aix specific behavior. Is the NULL page at address 0 always read-only? Briefly googling it did not result in a satisfactory answer.",
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba659e62_281d1a09",
        "filename": "test/fixedbugs/issue11656.dir/asm_ppc64.s",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-01-10T17:50:26Z",
      "side": 1,
      "message": "I think we can do this on all PPC64, BE and LE, without limiting to AIX.",
      "range": {
        "startLine": 1,
        "startChar": 11,
        "endLine": 1,
        "endChar": 23
      },
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12ae829c_9d5f2895",
        "filename": "test/fixedbugs/issue11656.dir/asm_ppc64.s",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 36863
      },
      "writtenOn": "2022-01-10T18:08:46Z",
      "side": 1,
      "message": "Yes, it should work for all. I only restricted as it seems aix specific. I\u0027ll open it to all ppc targets.",
      "parentUuid": "ba659e62_281d1a09",
      "range": {
        "startLine": 1,
        "startChar": 11,
        "endLine": 1,
        "endChar": 23
      },
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82e09195_9d1739b5",
        "filename": "test/fixedbugs/issue11656.dir/asm_ppc64.s",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-01-10T18:14:07Z",
      "side": 1,
      "message": "It is not really AIX specific. On Linux it is likely that the heap is not executable. But the test is written so that even if the heap is executable it can get the desired fault.",
      "parentUuid": "12ae829c_9d5f2895",
      "range": {
        "startLine": 1,
        "startChar": 11,
        "endLine": 1,
        "endChar": 23
      },
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5309428f_c31862bf",
        "filename": "test/fixedbugs/issue11656.dir/asm_ppc64.s",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 6320
      },
      "writtenOn": "2022-01-11T13:29:57Z",
      "side": 1,
      "message": "If I run this test on Linux after disabling the PanicOnFault, it gets the SEGV on the instruction that is in the heap. So the heap must be executable on Linux for ppc64 \u0026 ppc64le.\n\nI\u0027m not sure what is happening on AIX. If you look at the older logs, it gets a SIGILL at the instruction after the MOVD R0,0(R0) which is a bad instruction. To me implies that it ran the first instruction without getting the SEGV. However there were some AIX instructions after those first failures and the last 2 failures get the SIGILL on the MOVD R0,0(R0).",
      "parentUuid": "82e09195_9d1739b5",
      "range": {
        "startLine": 1,
        "startChar": 11,
        "endLine": 1,
        "endChar": 23
      },
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "215713e4_4b6f05b0",
        "filename": "test/fixedbugs/issue11656.dir/asm_ppc64.s",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 36863
      },
      "writtenOn": "2022-01-11T15:28:26Z",
      "side": 1,
      "message": "The split L1 cache implies it could be executing random data, not just opcode 0 or 62. The memory is zero\u0027ed out just prior to writing the std opcode and jumping to it. I suspect the instruction reported by the signal handler isn\u0027t what was executed.",
      "parentUuid": "5309428f_c31862bf",
      "range": {
        "startLine": 1,
        "startChar": 11,
        "endLine": 1,
        "endChar": 23
      },
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "57335dc4_70a3e8f6",
        "filename": "test/fixedbugs/issue11656.dir/asm_ppc64.s",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-01-11T15:46:48Z",
      "side": 1,
      "message": "The signal handler \"reads\" the faulting instruction from memory, which presumably will go through D-cache, not I-cache, if their contents could be different. So the printed bytes may not be what the CPU actually executed.",
      "parentUuid": "215713e4_4b6f05b0",
      "range": {
        "startLine": 1,
        "startChar": 11,
        "endLine": 1,
        "endChar": 23
      },
      "revId": "90671af1669ae7ac780a92e186a99e37871547bd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}