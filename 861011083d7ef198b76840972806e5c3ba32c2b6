{
  "comments": [
    {
      "key": {
        "uuid": "770e6d97_c432d4c7",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1439,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "(nit) \"in serial\" seems awkward.\n\nPerhaps \"Each interval is run [sequentially / in sequence / in series] and ‚Ä¶\"",
      "range": {
        "startLine": 1439,
        "startChar": 7,
        "endLine": 1439,
        "endChar": 30
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17c72d1a_0bfeb0e7",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1439,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "770e6d97_c432d4c7",
      "range": {
        "startLine": 1439,
        "startChar": 7,
        "endLine": 1439,
        "endChar": 30
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6cae74bc_214a7d55",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Em-dash (‚Äî) or double-dash (--)?\n\nOr avoid the issue altogether and use a colon?\n\n(https://golang.org/issue/21327#issuecomment-320529201)",
      "range": {
        "startLine": 1440,
        "startChar": 48,
        "endLine": 1440,
        "endChar": 49
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "739cadb4_948fe90f",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6cae74bc_214a7d55",
      "range": {
        "startLine": 1440,
        "startChar": 48,
        "endLine": 1440,
        "endChar": 49
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ec57beb_3ede23c7",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 177,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "What is the allowed range for the values in vals? (Do we need to consider overflow here?)",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb952cc5_95a475d3",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 177,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Ack. See response to int(d.Nanoseconds()) comment.",
      "parentUuid": "9ec57beb_3ede23c7",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9cf20924_f4306c94",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "2^31 nanoseconds is only 2+ùúÄ seconds. Is this robust on 32-bit platforms?",
      "range": {
        "startLine": 303,
        "startChar": 18,
        "endLine": 303,
        "endChar": 38
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db167eef_ee78ea28",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "I don\u0027t believe my change added that problem. I\u0027ve addressed it here by operating with int64 and then safely converting back to int just before n is used.",
      "parentUuid": "9cf20924_f4306c94",
      "range": {
        "startLine": 303,
        "startChar": 18,
        "endLine": 303,
        "endChar": 38
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a756893_2156cd9b",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Would it make sense to revise our estimate for n after each split, or to start over with a different n if we produce too few splits?\n\nIt seems like this will make it really easy to fall into cases where we request K splits but get far fewer even though the total N is quite large.",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62864085_98ba89c7",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Your concern is real. I\u0027ve changed the three knobs (2 growth factors, 1 rounding function) such that n increases more slowly in proportion to interval size. These changes respect the findings explained in a12cc719807 for the old case of one interval.\n\nAs an example:\n\nfunc BenchmarkFoo(b *testing.B) {\n\tfor i :\u003d 0; i \u003c b.N; i++ {\n\t\ttime.Sleep(25 * time.Microsecond)\n\t}\n}\n\nrequested_intervals interval_sat operations/interval duration\nn/a                 100          50000               2.1s      # benchsplit not used\n1                   100          50000               2.1s      # same code path as no benchsplit\n10                  100          3000                1.5s\n50                  96           600                 2.4s\n100                 94           300                 2.4s\n500                 93           60                  2.7s\n1000                95           30                  2.8s\n5000                93           6                   5.4s\n\nwhere interval_sat \u003d\u003d actual_intervals/requested_intervals * 100\n\nWould you like me to do something scientific that looks at how the 3 knobs affects various benchmarks (sleeps) and benchsplits over many iterations of each benchmark?",
      "parentUuid": "8a756893_2156cd9b",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93467e61_fe8e9c6b",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-29T19:59:44Z",
      "side": 1,
      "message": "One simple alternative might be to take the maximum of benchtime and benchsplit: for example, we could ensure that there are at least benchsplit intervals each representing a duration of at least [benchtime / benchsplit]. Then if we initially overestimate, we end up with one long interval and a bunch of normal-length ones, rather than one long interval and either a bunch of short intervals or a truncated split.",
      "parentUuid": "62864085_98ba89c7",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3339a607_67b9a78b",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-30T04:11:29Z",
      "side": 1,
      "message": "I normally wouldn\u0027t reply without new code, but I want to make sure I understand. Is this what you mean:\nRun the 1st interval just like the old code of one interval except d\u003d\u003dbenchtime/benchsplit instead of d\u003d\u003dbenchtime.\nFor the remaining benchsplit-1 intervals, run each for benchtime/benchsplit / first_interval.nsPerOp() iterations, regardless of how long it takes. If there does not need to be rounding on benchsplit-1 intervals\u0027s iteration count, I think we can expect to not go over benchtime by much.\n\n\"rather than one long interval and either a bunch of short intervals or a truncated split\"\nI assume this is referring to the code currently in this review, which favors uniform interval duration at the cost of overall runtime (slow growth) and truncated splits (\u003c benchsplit). So I see how that is \"one long interval and ... a truncated split\" But I don\u0027t see how it could lead to \"one long interval and ... a bunch of short intervals\". Maybe this is not referring to the code currently in this review.",
      "parentUuid": "93467e61_fe8e9c6b",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a8b9b03_f3150b77",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-31T18:34:47Z",
      "side": 1,
      "message": "\u003e Run the 1st interval just like the old code of one interval except d\u003d\u003dbenchtime/benchsplit instead of d\u003d\u003dbenchtime.\n\nYes.\n\n\u003e For the remaining benchsplit-1 intervals, run each for benchtime/benchsplit / first_interval.nsPerOp() iterations, regardless of how long it takes.\n\nMaybe, although we should update nsPerOp based on the subsequent splits as well, and if we undershoot d we should increase the iterations from that split onward.\n\n\u003e If there does not need to be rounding on benchsplit-1 intervals\u0027s iteration count, I think we can expect to not go over benchtime by much.\n\n\u003e \"rather than one long interval and either a bunch of short intervals or a truncated split\"\n\u003e I assume this is referring to the code currently in this review, which favors uniform interval duration at the cost of overall runtime (slow growth) and truncated splits (\u003c benchsplit). So I see how that is \"one long interval and ... a truncated split\" But I don\u0027t see how it could lead to \"one long interval and ... a bunch of short intervals\". Maybe this is not referring to the code currently in this review.\n\nThe current code is \"one long interval and ‚Ä¶ a truncated split\". Another alternative we could consider would be to target the ith split to [benchtime - ‚àë·µ¢(benchtime·µ¢)] / [n - i], which would result in \"one long interval and ‚Ä¶ a bunch of short intervals\", where the intervals would tend to converge toward even spacing but with a total time that approximates benchtime. (If the initial error is large, the individual split timings could converge to a timeout significantly shorter than [benchtime / n].)\n\nI am proposing a third alternative, in which the individual split timings *do* converge to [benchtime / n] but the overall sum time may significantly overshoot benchtime (if the initial error is large).",
      "parentUuid": "3339a607_67b9a78b",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab19e00f_9eb4a48d",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-09-17T00:56:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7a8b9b03_f3150b77",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4e7bc3d0_50e0ec3e",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "aveNsPerOp is [sum(prevNsPerOp) / intervals],\nso [n / aveNsPerOp] is [n * intervals / sum(prevNsPerOp)],\nand [n /\u003d intervals] here gives [n * intervals / (sum(prevNsPerOp) * intervals)]\n\nSeems like we could compute this with less rounding error by going straight to:\nn \u003d benchTimeNs / sum(prevNsPerOp)\n\nWhat am I missing?",
      "range": {
        "startLine": 328,
        "startChar": 0,
        "endLine": 331,
        "endChar": 15
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "831f97bf_164936ce",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4e7bc3d0_50e0ec3e",
      "range": {
        "startLine": 328,
        "startChar": 0,
        "endLine": 331,
        "endChar": 15
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4cf57358_80282ec3",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Why append here instead of writing directly to b.w?",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5617eed5_0608393e",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4cf57358_80282ec3",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "90597c37_b642f40d",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 579,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "I don\u0027t really understand this comment: why is it ok for subbenchmarks not to have a breakdown by interval?",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a04c9d8e_cd474fa6",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 579,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "The original patch does support benchsplit for subbenchmarks called from go test Bench* functions.\n\nThe add method here is used for the case of subbenchmarks called from the func Benchmark. In that case, just like the api doesn\u0027t work well supporting multiple b.Run subbenchmarks, so too it doesn\u0027t work well supporting the same benchmark broken down by interval. (BenchmarkResult only has room for one result.)\n\nI\u0027ve changed the comment to clarify this.",
      "parentUuid": "90597c37_b642f40d",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f260a232_5c158936",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 579,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-29T19:59:44Z",
      "side": 1,
      "message": "\u003e The add method here is used for the case of subbenchmarks called from the func Benchmark. In that case, just like the api doesn\u0027t work well supporting multiple b.Run subbenchmarks, so too it doesn\u0027t work well supporting the same benchmark broken down by interval. (BenchmarkResult only has room for one result.)\n\nI still don\u0027t really understand why that\u0027s a problem. We could always add fields to the BenchmarkResult struct in order to return multiple results: for example, we could extend it to something like:\n\ntype BenchmarkResult struct {\n\t‚Ä¶\n\tSubBenchmark map[string]BenchmarkResult  // b.Run argument ‚Üí result\n\tSplit []BenchmarkResult  // benchsplit iteration ‚Üí result\n}",
      "parentUuid": "a04c9d8e_cd474fa6",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb505ea3_08b343ac",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 579,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-09-17T00:56:39Z",
      "side": 1,
      "message": "I\u0027ve added `split []BenchmarkResult` to BenchmarkResult, but made it private - I forgot that func Benchmark can\u0027t actually specify benchsplit so there\u0027s no reason to make it public.\n\nI think adding \"SubBenchmark map[string]BenchmarkResult\" is a compelling idea and I even implemented a bunch of it locally (including a recursive implementation of BenchmarkResult\u0027s String()), but I am not including it in this review because it\u0027s an orthogonal change based on what I wrote above. (For backwards compatibility, it could keep the \"simulation\" in the top level fields and put the actual results in SubBenchmark.)",
      "parentUuid": "f260a232_5c158936",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6da21539_0b265360",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 383,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Should there be a new case here with intervals \u003e 1?",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "447fc363_8bc48f8e",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 383,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Considering what\u0027s discussed in https://go-review.googlesource.com/c/go/+/47411/2/src/testing/benchmark.go#579, I\u0027m going to avoid a new case here and remove intervals as a configurable field.",
      "parentUuid": "6da21539_0b265360",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a6b6a08_626ef46d",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 561,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "It\u0027s not obvious to me why this expectation follows from the benchmark setup. (It would be helpful to log a clearer description of what exactly the setup is: the test name is a bit ambiguous.)",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9db008fe_065b8be3",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 561,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9a6b6a08_626ef46d",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}