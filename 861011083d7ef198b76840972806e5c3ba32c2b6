{
  "comments": [
    {
      "key": {
        "uuid": "770e6d97_c432d4c7",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1439,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "(nit) \"in serial\" seems awkward.\n\nPerhaps \"Each interval is run [sequentially / in sequence / in series] and ‚Ä¶\"",
      "range": {
        "startLine": 1439,
        "startChar": 7,
        "endLine": 1439,
        "endChar": 30
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17c72d1a_0bfeb0e7",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1439,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "770e6d97_c432d4c7",
      "range": {
        "startLine": 1439,
        "startChar": 7,
        "endLine": 1439,
        "endChar": 30
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6cae74bc_214a7d55",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Em-dash (‚Äî) or double-dash (--)?\n\nOr avoid the issue altogether and use a colon?\n\n(https://golang.org/issue/21327#issuecomment-320529201)",
      "range": {
        "startLine": 1440,
        "startChar": 48,
        "endLine": 1440,
        "endChar": 49
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "739cadb4_948fe90f",
        "filename": "src/cmd/go/alldocs.go",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6cae74bc_214a7d55",
      "range": {
        "startLine": 1440,
        "startChar": 48,
        "endLine": 1440,
        "endChar": 49
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ec57beb_3ede23c7",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 177,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "What is the allowed range for the values in vals? (Do we need to consider overflow here?)",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb952cc5_95a475d3",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 177,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Ack. See response to int(d.Nanoseconds()) comment.",
      "parentUuid": "9ec57beb_3ede23c7",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9cf20924_f4306c94",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "2^31 nanoseconds is only 2+ùúÄ seconds. Is this robust on 32-bit platforms?",
      "range": {
        "startLine": 303,
        "startChar": 18,
        "endLine": 303,
        "endChar": 38
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db167eef_ee78ea28",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "I don\u0027t believe my change added that problem. I\u0027ve addressed it here by operating with int64 and then safely converting back to int just before n is used.",
      "parentUuid": "9cf20924_f4306c94",
      "range": {
        "startLine": 303,
        "startChar": 18,
        "endLine": 303,
        "endChar": 38
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a756893_2156cd9b",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Would it make sense to revise our estimate for n after each split, or to start over with a different n if we produce too few splits?\n\nIt seems like this will make it really easy to fall into cases where we request K splits but get far fewer even though the total N is quite large.",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62864085_98ba89c7",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Your concern is real. I\u0027ve changed the three knobs (2 growth factors, 1 rounding function) such that n increases more slowly in proportion to interval size. These changes respect the findings explained in a12cc719807 for the old case of one interval.\n\nAs an example:\n\nfunc BenchmarkFoo(b *testing.B) {\n\tfor i :\u003d 0; i \u003c b.N; i++ {\n\t\ttime.Sleep(25 * time.Microsecond)\n\t}\n}\n\nrequested_intervals interval_sat operations/interval duration\nn/a                 100          50000               2.1s      # benchsplit not used\n1                   100          50000               2.1s      # same code path as no benchsplit\n10                  100          3000                1.5s\n50                  96           600                 2.4s\n100                 94           300                 2.4s\n500                 93           60                  2.7s\n1000                95           30                  2.8s\n5000                93           6                   5.4s\n\nwhere interval_sat \u003d\u003d actual_intervals/requested_intervals * 100\n\nWould you like me to do something scientific that looks at how the 3 knobs affects various benchmarks (sleeps) and benchsplits over many iterations of each benchmark?",
      "parentUuid": "8a756893_2156cd9b",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93467e61_fe8e9c6b",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 317,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-29T19:59:44Z",
      "side": 1,
      "message": "One simple alternative might be to take the maximum of benchtime and benchsplit: for example, we could ensure that there are at least benchsplit intervals each representing a duration of at least [benchtime / benchsplit]. Then if we initially overestimate, we end up with one long interval and a bunch of normal-length ones, rather than one long interval and either a bunch of short intervals or a truncated split.",
      "parentUuid": "62864085_98ba89c7",
      "range": {
        "startLine": 313,
        "startChar": 0,
        "endLine": 317,
        "endChar": 4
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e7bc3d0_50e0ec3e",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "aveNsPerOp is [sum(prevNsPerOp) / intervals],\nso [n / aveNsPerOp] is [n * intervals / sum(prevNsPerOp)],\nand [n /\u003d intervals] here gives [n * intervals / (sum(prevNsPerOp) * intervals)]\n\nSeems like we could compute this with less rounding error by going straight to:\nn \u003d benchTimeNs / sum(prevNsPerOp)\n\nWhat am I missing?",
      "range": {
        "startLine": 328,
        "startChar": 0,
        "endLine": 331,
        "endChar": 15
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "831f97bf_164936ce",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4e7bc3d0_50e0ec3e",
      "range": {
        "startLine": 328,
        "startChar": 0,
        "endLine": 331,
        "endChar": 15
      },
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4cf57358_80282ec3",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Why append here instead of writing directly to b.w?",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5617eed5_0608393e",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4cf57358_80282ec3",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "90597c37_b642f40d",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 579,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "I don\u0027t really understand this comment: why is it ok for subbenchmarks not to have a breakdown by interval?",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a04c9d8e_cd474fa6",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 579,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "The original patch does support benchsplit for subbenchmarks called from go test Bench* functions.\n\nThe add method here is used for the case of subbenchmarks called from the func Benchmark. In that case, just like the api doesn\u0027t work well supporting multiple b.Run subbenchmarks, so too it doesn\u0027t work well supporting the same benchmark broken down by interval. (BenchmarkResult only has room for one result.)\n\nI\u0027ve changed the comment to clarify this.",
      "parentUuid": "90597c37_b642f40d",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f260a232_5c158936",
        "filename": "src/testing/benchmark.go",
        "patchSetId": 2
      },
      "lineNbr": 579,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-29T19:59:44Z",
      "side": 1,
      "message": "\u003e The add method here is used for the case of subbenchmarks called from the func Benchmark. In that case, just like the api doesn\u0027t work well supporting multiple b.Run subbenchmarks, so too it doesn\u0027t work well supporting the same benchmark broken down by interval. (BenchmarkResult only has room for one result.)\n\nI still don\u0027t really understand why that\u0027s a problem. We could always add fields to the BenchmarkResult struct in order to return multiple results: for example, we could extend it to something like:\n\ntype BenchmarkResult struct {\n\t‚Ä¶\n\tSubBenchmark map[string]BenchmarkResult  // b.Run argument ‚Üí result\n\tSplit []BenchmarkResult  // benchsplit iteration ‚Üí result\n}",
      "parentUuid": "a04c9d8e_cd474fa6",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6da21539_0b265360",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 383,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "Should there be a new case here with intervals \u003e 1?",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "447fc363_8bc48f8e",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 383,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Considering what\u0027s discussed in https://go-review.googlesource.com/c/go/+/47411/2/src/testing/benchmark.go#579, I\u0027m going to avoid a new case here and remove intervals as a configurable field.",
      "parentUuid": "6da21539_0b265360",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a6b6a08_626ef46d",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 561,
      "author": {
        "id": 6365
      },
      "writtenOn": "2017-08-16T21:13:33Z",
      "side": 1,
      "message": "It\u0027s not obvious to me why this expectation follows from the benchmark setup. (It would be helpful to log a clearer description of what exactly the setup is: the test name is a bit ambiguous.)",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9db008fe_065b8be3",
        "filename": "src/testing/sub_test.go",
        "patchSetId": 2
      },
      "lineNbr": 561,
      "author": {
        "id": 8955
      },
      "writtenOn": "2017-08-29T02:44:29Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9a6b6a08_626ef46d",
      "revId": "861011083d7ef198b76840972806e5c3ba32c2b6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}