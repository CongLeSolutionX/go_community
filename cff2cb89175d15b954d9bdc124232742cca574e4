{
  "comments": [
    {
      "key": {
        "uuid": "adcb7af7_10896465",
        "filename": "src/internal/bytealg/compare_wasm.s",
        "patchSetId": 6
      },
      "lineNbr": 51,
      "author": {
        "id": 5200
      },
      "writtenOn": "2018-04-09T19:58:00Z",
      "side": 1,
      "message": "It seems weird that Go treats webassembly as a 64-bit architecture, but then pointers are treated as 32 bits.\nIt\u0027s 64-bit because there are 64-bit native ops?\nWe just carry around the top 32 zero bits of all pointers to make our lives easier?\nDoes that mean all loads/stores generated by the compiler do a I32WrapI64 before the load/store?",
      "revId": "cff2cb89175d15b954d9bdc124232742cca574e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "962305e1_f7e1c261",
        "filename": "src/internal/bytealg/equal_wasm.s",
        "patchSetId": 6
      },
      "lineNbr": 60,
      "author": {
        "id": 5200
      },
      "writtenOn": "2018-04-09T19:58:00Z",
      "side": 1,
      "message": "How SP, FP, CTX, SB, etc work for webassembly is a bit of a mystery.  Is there a doc somewhere?",
      "revId": "cff2cb89175d15b954d9bdc124232742cca574e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2de537f_c8dcc300",
        "filename": "src/internal/bytealg/equal_wasm.s",
        "patchSetId": 6
      },
      "lineNbr": 112,
      "author": {
        "id": 5200
      },
      "writtenOn": "2018-04-09T19:58:00Z",
      "side": 1,
      "message": "So \"Br\" where the referenced control flow container is a loop, is a \"continue\".\n\"Br\" where the referenced control flow container is a Block, is a \"break\" of that block.\nWhy \"Br $0\" here?  Would the loop just loop without this instruction?  Or is falling out the end of a loop construct bad?",
      "revId": "cff2cb89175d15b954d9bdc124232742cca574e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "819a12f8_b6a87566",
        "filename": "src/internal/bytealg/equal_wasm.s",
        "patchSetId": 6
      },
      "lineNbr": 116,
      "author": {
        "id": 5200
      },
      "writtenOn": "2018-04-09T19:58:00Z",
      "side": 1,
      "message": "Is there more to this function?\nA RET, at least?",
      "revId": "cff2cb89175d15b954d9bdc124232742cca574e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d054b199_b0f47f86",
        "filename": "src/internal/bytealg/indexbyte_wasm.s",
        "patchSetId": 6
      },
      "lineNbr": 9,
      "author": {
        "id": 5200
      },
      "writtenOn": "2018-04-09T19:58:00Z",
      "side": 1,
      "message": "Some of the other code did a I64Load followed by a Wrap 64-\u003e32 instruction.  We\u0027re doing a different scheme here (assuming little endian, is that defined for webassmbly?).\nCan we be consistent across the implementations in this package?",
      "revId": "cff2cb89175d15b954d9bdc124232742cca574e4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}