{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d3969061_838a215c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-09-24T16:56:47Z",
      "side": 1,
      "message": "Replacement for https://go-review.googlesource.com/c/go/+/345097",
      "revId": "1f25f220299b52d6e35015c73e684b74738b6d5a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb1d9413_75256068",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-24T17:03:25Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d1f25f220",
      "tag": "autogenerated:trybots~beginning",
      "revId": "1f25f220299b52d6e35015c73e684b74738b6d5a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b33a459e_d12bdb7d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-24T17:15:07Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "bb1d9413_75256068",
      "tag": "autogenerated:trybots~happy",
      "revId": "1f25f220299b52d6e35015c73e684b74738b6d5a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ccc2324f_fe441f21",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-09-24T17:15:10Z",
      "side": 1,
      "message": "I\u0027m not sure I understand the benefit of having two fuzz tests in each file: an empty seed, and a good seed corpus. I don\u0027t think these need to be testing the fuzzing engine in any way. They just need to be as effective as possible at finding issues should someone choose to run them. And considering they are in the stdlib, they should act as good examples for what a target should look like (I assume a lot of people will use the stdlib as a point of reference when writing their first fuzz targets, especially at first). Could you clarify a bit?",
      "revId": "1f25f220299b52d6e35015c73e684b74738b6d5a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a33b36b_ff177ae0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-09-24T19:45:41Z",
      "side": 1,
      "message": "Quoting from a previous discussion of this on 345097\n\n\u003e There was either a paper, or a blog post, that I read (which I am now completely unable to find) which suggested that the selection of the input corpus could have a significant impact on what the fuzzer would find. This is because a well formed input strongly directs the initial direction of the fuzzer, since it already has a valid (likely somewhat deep) execution path, whereas when using an empty input the fuzzer is starting from scratch, building an execution graph which is likely to be significantly shallower, but likely somewhat wider (if that makes sense, I feel like I\u0027m not using the correct graph terminology).\n\u003e \n\u003e That said, it probably makes sense for all of these targets to just use a single, well-formed seed input, and leave more complex seeding approaches for more complex, targeted targets.\n\nI entirely forgot my suggestion at the time, and am happy to just go back to using a single input. That said, if we intend these to be examples of how best to write targets, selection of the initial corpus and how that will impact how the fuzzer operates is something that needs to be considered (perhaps not explicitly in the stdlib targets themselves, but at least somewhere in the documentation.)",
      "parentUuid": "ccc2324f_fe441f21",
      "revId": "1f25f220299b52d6e35015c73e684b74738b6d5a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "199da8c3_dbb0a9be",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-09-27T15:28:56Z",
      "side": 1,
      "message": "Gotcha. I hadn\u0027t seen that other discussion (or forgot). Maybe then you could add two f.Add lines in the same fuzz test. One for a good seed, and one for an empty seed? That way we have at least once branch that\u0027s starting from scratch while the other branch is starting farther down the code tree. Wdyt?\n\n\u003e if we intend these to be examples of how best to write targets, selection of the initial corpus and how that will impact how the fuzzer operates is something that needs to be considered \n\nI don\u0027t think we have to necessarily \"intend\" for these to be examples, for them to become examples. I just have a feeling people will treat them as such when they\u0027re trying to write their first fuzz tests since its in the stdlib.\n\nWe should definitely outline how to choose a good corpus in the documentation anyway though. That\u0027s included as something here: https://github.com/golang/go/issues/48255",
      "parentUuid": "0a33b36b_ff177ae0",
      "revId": "1f25f220299b52d6e35015c73e684b74738b6d5a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}