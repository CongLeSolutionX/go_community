{
  "comments": [
    {
      "key": {
        "uuid": "09c4462d_e87e67c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-29T10:11:09Z",
      "side": 1,
      "message": "Thanks very much for reviewing ðŸ˜Š. I updated the proof process of the algorithm to make it clearer and more reasonable. In addition, because getInvert becomes very simple and straightforward (just like the nlz function), I think the test function can be removed. ",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8a1b5cf1_e3766d34",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 252,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:26:57Z",
      "side": 1,
      "message": "That\u0027s only true if q0\u003c\u003dd. Do we know that?",
      "range": {
        "startLine": 252,
        "startChar": 6,
        "endLine": 252,
        "endChar": 69
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "149a088f_d01b9ccc",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 252,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "We don\u0027t know that. But we know real remainder 0 \u003c\u003d r \u003c d. And because r \u003dX-d*q, so rr \u003d r. So 0\u003c\u003d rr \u003c d and we won\u0027t enter branch2.",
      "parentUuid": "8a1b5cf1_e3766d34",
      "range": {
        "startLine": 252,
        "startChar": 6,
        "endLine": 252,
        "endChar": 69
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25890d66_ebc8b768",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 253,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:26:57Z",
      "side": 1,
      "message": "This doesn\u0027t follow to me. If we enter branch 1 and do rr +\u003d d, and that computation overflows, then we won\u0027t enter branch 2.",
      "range": {
        "startLine": 253,
        "startChar": 6,
        "endLine": 253,
        "endChar": 83
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb330bee_ce809ae6",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 253,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "Right. So we need to prove the compution doesn\u0027t overflow, which maens rr+d\u003cB. And that is what I do next.",
      "parentUuid": "25890d66_ebc8b768",
      "range": {
        "startLine": 253,
        "startChar": 6,
        "endLine": 253,
        "endChar": 83
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ceda2ef9_09fd2904",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 276,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-30T06:01:38Z",
      "side": 1,
      "message": "This case causes q++ to overflow:\nx1\u003d0xbfffffffffffffff x0\u003d0xffffffffffffffff y\u003d0xc000000000000000\nMiraculously, in the end it still gets the right answer (but my suggestion doesn\u0027t).",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b616545_52aa2a33",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 276,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "Because the next judgment does not require qq. Even qq overflows, qq-- in branch1 will return qq to its original value.",
      "parentUuid": "ceda2ef9_09fd2904",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c776a210_00201670",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 281,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:00:52Z",
      "side": 1,
      "message": "I don\u0027t understand how it could possibly work to decide which case we\u0027re in by just looking at rr. It needs to somehow encode both the remainder and whether we\u0027re in the q, q-1, or q+1 case. That means rr needs log(3B) bits, which is too many. Even if some of the q-1 or q+1 cases can\u0027t have a full range of remainders, it still looks more tight to me than is possible.\n\nHow about the following:\n\n\t// compute remainder x-dq.\n\tdq1, dq0 :\u003d bits.Mul64(d, q)\n\tr0, b :\u003d bits.Sub64(x0, dq0, 0)\n\tr1, b :\u003d bits.Sub64(x1, dq1, b)\n\tif b !\u003d 0 {\n\t\t// x - dq \u003c 0, which means q was too large.\n\t\treturn q - 1, (r0 + d) \u003e\u003e s\n\t}\n\tif r1 !\u003d 0 || r0 \u003e\u003d d {\n\t\t// x - dq \u003e\u003d d, which means q was too small.\n\t\treturn q + 1, (r0 - d) \u003e\u003e s\n\t}\n\treturn q, r0 \u003e\u003e s\n\nIt also means all the argument in cases 1-3 above are not neeeded.",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "366c8de3_ce630a62",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 281,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "It makes sense. But we need to do two multiplications in divWW. Unlike getInvert, divWW will have a great impact on performance.",
      "parentUuid": "c776a210_00201670",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1486ba2_0c675d95",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 313,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:00:52Z",
      "side": 1,
      "message": "U",
      "range": {
        "startLine": 313,
        "startChar": 57,
        "endLine": 313,
        "endChar": 58
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d0f5457_b72fd3e7",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 313,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a1486ba2_0c675d95",
      "range": {
        "startLine": 313,
        "startChar": 57,
        "endLine": 313,
        "endChar": 58
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}