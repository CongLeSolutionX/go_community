{
  "comments": [
    {
      "key": {
        "uuid": "09c4462d_e87e67c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-29T10:11:09Z",
      "side": 1,
      "message": "Thanks very much for reviewing üòä. I updated the proof process of the algorithm to make it clearer and more reasonable. In addition, because getInvert becomes very simple and straightforward (just like the nlz function), I think the test function can be removed. ",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8a1b5cf1_e3766d34",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 252,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:26:57Z",
      "side": 1,
      "message": "That\u0027s only true if q0\u003c\u003dd. Do we know that?",
      "range": {
        "startLine": 252,
        "startChar": 6,
        "endLine": 252,
        "endChar": 69
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "149a088f_d01b9ccc",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 252,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "We don\u0027t know that. But we know real remainder 0 \u003c\u003d r \u003c d. And because r \u003dX-d*q, so rr \u003d r. So 0\u003c\u003d rr \u003c d and we won\u0027t enter branch2.",
      "parentUuid": "8a1b5cf1_e3766d34",
      "range": {
        "startLine": 252,
        "startChar": 6,
        "endLine": 252,
        "endChar": 69
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25890d66_ebc8b768",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 253,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:26:57Z",
      "side": 1,
      "message": "This doesn\u0027t follow to me. If we enter branch 1 and do rr +\u003d d, and that computation overflows, then we won\u0027t enter branch 2.",
      "range": {
        "startLine": 253,
        "startChar": 6,
        "endLine": 253,
        "endChar": 83
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb330bee_ce809ae6",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 253,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "Right. So we need to prove the compution doesn\u0027t overflow, which maens rr+d\u003cB. And that is what I do next.",
      "parentUuid": "25890d66_ebc8b768",
      "range": {
        "startLine": 253,
        "startChar": 6,
        "endLine": 253,
        "endChar": 83
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ceda2ef9_09fd2904",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 276,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-30T06:01:38Z",
      "side": 1,
      "message": "This case causes q++ to overflow:\nx1\u003d0xbfffffffffffffff x0\u003d0xffffffffffffffff y\u003d0xc000000000000000\nMiraculously, in the end it still gets the right answer (but my suggestion doesn\u0027t).",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b616545_52aa2a33",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 276,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "Because the next judgment does not require qq. Even qq overflows, qq-- in branch1 will return qq to its original value.",
      "parentUuid": "ceda2ef9_09fd2904",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18e127a5_dedef7a4",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 276,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-30T16:56:02Z",
      "side": 1,
      "message": "How do you know, if qq overflows, that branch1 will be taken?\nThis will be case 2, but the math there looks like it doesn\u0027t take into account possible wraparound of gg.",
      "parentUuid": "4b616545_52aa2a33",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ed56c22_421be53a",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 276,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-31T07:54:38Z",
      "side": 1,
      "message": "You said when qq\u003dB-1, then qq+1 overflows. When qq\u003dB-1, because (B*x1+x0-r)/d\u003dqq, then r\u003d B*(x1-d)+x0-d. Because x1\u003cd, then r\u003c0. Then here\u0027s what I prove in prove2.",
      "parentUuid": "18e127a5_dedef7a4",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c776a210_00201670",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 281,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:00:52Z",
      "side": 1,
      "message": "I don\u0027t understand how it could possibly work to decide which case we\u0027re in by just looking at rr. It needs to somehow encode both the remainder and whether we\u0027re in the q, q-1, or q+1 case. That means rr needs log(3B) bits, which is too many. Even if some of the q-1 or q+1 cases can\u0027t have a full range of remainders, it still looks more tight to me than is possible.\n\nHow about the following:\n\n\t// compute remainder x-dq.\n\tdq1, dq0 :\u003d bits.Mul64(d, q)\n\tr0, b :\u003d bits.Sub64(x0, dq0, 0)\n\tr1, b :\u003d bits.Sub64(x1, dq1, b)\n\tif b !\u003d 0 {\n\t\t// x - dq \u003c 0, which means q was too large.\n\t\treturn q - 1, (r0 + d) \u003e\u003e s\n\t}\n\tif r1 !\u003d 0 || r0 \u003e\u003d d {\n\t\t// x - dq \u003e\u003d d, which means q was too small.\n\t\treturn q + 1, (r0 - d) \u003e\u003e s\n\t}\n\treturn q, r0 \u003e\u003e s\n\nIt also means all the argument in cases 1-3 above are not neeeded.",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "366c8de3_ce630a62",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 281,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "It makes sense. But we need to do two multiplications in divWW. Unlike getInvert, divWW will have a great impact on performance.",
      "parentUuid": "c776a210_00201670",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ebd1fc23_e71c6851",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 281,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:23:14Z",
      "side": 1,
      "message": "We allow rr to get is an negative overflow result,which means real remainder r\u003c0. And rr \u003d r mod B \u003d B + r.",
      "parentUuid": "366c8de3_ce630a62",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbbf629a_38e01fa6",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 281,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-30T16:56:02Z",
      "side": 1,
      "message": "Here\u0027s a fixed code for my version. Don\u0027t do q++, instead compute the remainder using the original q.\n\n\t// We know that\n\t//   m \u003d ‚é£(B^2-1)/d‚é¶-B\n\t//   ‚é£(B^2-1)/d‚é¶ \u003d m+B\n\t//   (B^2-1)/d \u003d m+B+delta1    0 \u003c\u003d delta1 \u003c\u003d (d-1)/d\n\t//   B^2/d \u003d m+B+delta2        0 \u003c\u003d delta2 \u003c\u003d 1\n\t// The quotient we\u0027re trying to compute is\n\t//   quotient \u003d ‚é£(x1*B+x0)/d‚é¶\n\t//            \u003d ‚é£(x1*B*(B^2/d)+x0*(B^2/d))/B^2‚é¶\n\t//            \u003d ‚é£(x1*B*(m+B+delta2)+x0*(m+B+delta2))/B^2‚é¶\n\t//            \u003d ‚é£(x1*m+x1*B+x0)/B + x0*m/B^2 + delta2*(x1*B+x0)/B^2‚é¶\n\t// The latter two terms of this three-term sum are between 0 and 1.\n\t// So we can compute just the first term, and we will be low by at most 2.\n\tt1, t0 :\u003d bits.Mul64(m, x1)\n\t_, c :\u003d bits.Add64(t0, x0, 0)\n\tt1, _ \u003d bits.Add64(t1, x1, c)\n\n\t// The quotient is either t1, t1+1, or t1+2.\n\t// We\u0027ll try t1 and adjust if needed.\n\tq :\u003d t1\n\n\t// compute remainder r\u003dx-d*q.\n\tdq1, dq0 :\u003d bits.Mul64(d, q)\n\tr0, b :\u003d bits.Sub64(x0, dq0, 0)\n\tr1, _ :\u003d bits.Sub64(x1, dq1, b)\n\n\t// The remainder we just computed is bounded above by B+d:\n\t// r \u003d x1*B + x0 - d*q.\n\t//   \u003d x1*B + x0 - d*‚é£(x1*m+x1*B+x0)/B‚é¶\n\t//   \u003d x1*B + x0 - d*((x1*m+x1*B+x0)/B-alpha)                                   0 \u003c\u003d alpha \u003c 1\n\t//   \u003d x1*B + x0 - x1*d/B*m                         - x1*d - x0*d/B + d*alpha\n\t//   \u003d x1*B + x0 - x1*d/B*‚é£(B^2-1)/d-B‚é¶             - x1*d - x0*d/B + d*alpha\n\t//   \u003d x1*B + x0 - x1*d/B*‚é£(B^2-1)/d-B‚é¶             - x1*d - x0*d/B + d*alpha\n\t//   \u003d x1*B + x0 - x1*d/B*((B^2-1)/d-B-beta)        - x1*d - x0*d/B + d*alpha   0 \u003c\u003d beta \u003c 1\n\t//   \u003d x1*B + x0 - x1*B + x1/B + x1*d + x1*d/B*beta - x1*d - x0*d/B + d*alpha\n\t//   \u003d        x0        + x1/B        + x1*d/B*beta        - x0*d/B + d*alpha\n\t//   \u003d x0*(1-d/B) + x1*(1+d*beta)/B + d*alpha\n\t//   \u003c  B*(1-d/B) +  d*B/B          + d          because x0\u003cB (and 1-d/B\u003e0), x1\u003cd, 1+d*beta\u003c\u003dB, alpha\u003c1\n\t//   \u003d  B - d     +  d              + d\n\t//   \u003d B+d\n\t// So r1 can only be 0 or 1. If r1 is 1, then we know q was too small.\n\t// Add 1 to q and subtract d from r. That guarantees that r is \u003cB, so\n\t// we no longer need to keep track of r1.\n\tif r1 !\u003d 0 {\n\t\tq++\n\t\tr0 -\u003d d\n\t}\n\t// If the remainder is still too large, increment q one more time.\n\tif r0 \u003e\u003d d {\n\t\tq++\n\t\tr0 -\u003d d\n\t}\n\treturn q, r0 \u003e\u003e s",
      "parentUuid": "ebd1fc23_e71c6851",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e083b9e5_59e8639a",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 281,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-31T07:54:38Z",
      "side": 1,
      "message": "All right. It does make sense. I change Mul64 to Mul because it may also be executed on 32-bit machines, Add and Sub are also, is it ok?",
      "parentUuid": "cbbf629a_38e01fa6",
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1486ba2_0c675d95",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 313,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-08-29T23:00:52Z",
      "side": 1,
      "message": "U",
      "range": {
        "startLine": 313,
        "startChar": 57,
        "endLine": 313,
        "endChar": 58
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d0f5457_b72fd3e7",
        "filename": "src/math/big/arith.go",
        "patchSetId": 13
      },
      "lineNbr": 313,
      "author": {
        "id": 37583
      },
      "writtenOn": "2020-08-30T12:12:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a1486ba2_0c675d95",
      "range": {
        "startLine": 313,
        "startChar": 57,
        "endLine": 313,
        "endChar": 58
      },
      "revId": "297e0a75254314ff4b3f45ac207b2d89a9be31a6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}