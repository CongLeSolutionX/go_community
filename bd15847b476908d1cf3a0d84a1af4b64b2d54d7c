{
  "comments": [
    {
      "key": {
        "uuid": "c3c55625_f1e94229",
        "filename": "src/runtime/proc1.go",
        "patchSetId": 1
      },
      "lineNbr": 2733,
      "author": {
        "id": 5400
      },
      "writtenOn": "2015-03-28T08:41:36Z",
      "side": 1,
      "message": "oh boy, more active spinning :(\nlook at stoptheworld for how to do it properly without active spinning, potential for various deadlocking and without increasing overall complexity of P states",
      "revId": "bd15847b476908d1cf3a0d84a1af4b64b2d54d7c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "43308612_1629ac7f",
        "filename": "src/runtime/proc1.go",
        "patchSetId": 1
      },
      "lineNbr": 2733,
      "author": {
        "id": 5167
      },
      "writtenOn": "2015-03-28T19:04:21Z",
      "side": 1,
      "message": "Yeah, I\u0027m not happy about the spinning either. Though it is rather unlikely to happen and very brief when it does.\n\nAre you suggesting I should use _Pgcstop to interrupt Ps in syscall/idle? I had thought about this, but it wasn\u0027t obvious I could bring them back from _Pgcstop without a race. forEachP was of course based on the stoptheworld, but I had introduced the new state because of this concern. If this is what you\u0027re suggesting, though, I\u0027ll look into that more carefully.",
      "parentUuid": "c3c55625_f1e94229",
      "revId": "bd15847b476908d1cf3a0d84a1af4b64b2d54d7c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c3c55625_5447e47f",
        "filename": "src/runtime/proc1.go",
        "patchSetId": 1
      },
      "lineNbr": 2733,
      "author": {
        "id": 5400
      },
      "writtenOn": "2015-03-29T09:57:35Z",
      "side": 1,
      "message": "I suggest to use the existing protocol which already contains all necessary pieces:\n- acquire worldsema (already done)\n- lock sched mutex\n- grab whatever is in the pidle list. these Ps are in Pidle and are unused. execute the function for them, put back into pidle list\n- cas all Ps in Psyscall to Pidle, execute the function for them, put onto pidle list\n- preemptall\n- wait while other Ps ack the request (w/o looking at pidle list and Psyscall procs)\n\nYou need to check for request everywhere sched.gcwaiting is checked (besides newstack). Otherwise you have races that are resolved only by passive spinning below. Passive spinning can have latency of up to 15ms on some OSes and/or VMs.\n\nDo you foresee any usage of foreachp other than global barrier? If not, then by removing the function call, the scheme can be significantly simplified:\n- just subtract npidle from stopwait, and do nothing with pidle list\n- it\u0027s enough to just observe a P in Psyscall status, no need to do anything with it",
      "parentUuid": "43308612_1629ac7f",
      "revId": "bd15847b476908d1cf3a0d84a1af4b64b2d54d7c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c3c55625_14415c68",
        "filename": "src/runtime/proc1.go",
        "patchSetId": 1
      },
      "lineNbr": 2733,
      "author": {
        "id": 5400
      },
      "writtenOn": "2015-03-29T10:08:01Z",
      "side": 1,
      "message": "Something along the lines of:\n\nfunc globalbarrier() {\n\tlock(\u0026sched.lock)\n\tfor i :\u003d 0; i \u003c int(gomaxprocs); i++ {\n\t\tp :\u003d allp[i]\n\t\tif p \u003d\u003d getg().m.p || atomicload(\u0026p.status) \u003d\u003d _Psyscall {\n\t\t\tcontinue\n\t\t}\n\t\tp.ackBarrier \u003d true\n\t\tsched.stopwait++\n\t}\n\tfor p :\u003d sched.pidle; p !\u003d nil; p \u003d p.link {\n\t\tp.ackBarrier \u003d false\n\t\tsched.stopwait--\n\t}\n\twait :\u003d sched.stopwait \u003e 0\n\tunlock(\u0026sched.lock)\n\tfor wait {\n\t\tpreemptall()\n\t\tif notetsleep(\u0026sched.stopnote, 100*1000) {\n\t\t\tnoteclear(\u0026sched.stopnote)\n\t\t\tbreak\n\t\t}\n\t}\n}",
      "parentUuid": "c3c55625_5447e47f",
      "revId": "bd15847b476908d1cf3a0d84a1af4b64b2d54d7c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}