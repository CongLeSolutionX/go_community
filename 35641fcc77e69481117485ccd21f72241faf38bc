{
  "comments": [
    {
      "key": {
        "uuid": "81b56446_700d25e2",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 5206
      },
      "writtenOn": "2016-10-28T03:54:28Z",
      "side": 1,
      "message": "This will be unreliable when calling a signal handler that simply returns, because if the new ANDQ instruction changes the stack pointer then the RET will read the wrong address from the stack.  For example, look at the same function in sys_darwin_amd64.s, which does it right.\n\nThere is nothing GNU/Linux-specific about this, we should change this for every sys_GOOS_amd64.s.\n\nAnd, for that matter, the same issue arises for 386, so we should also change this for sys_GOOS_386.s.",
      "revId": "35641fcc77e69481117485ccd21f72241faf38bc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "61ba3039_0c1926ed",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 6365
      },
      "writtenOn": "2016-10-28T04:40:20Z",
      "side": 1,
      "message": "\u003e For example, look at the same function in sys_darwin_amd64.s, which does it right.\n\nI don\u0027t really understand how the darwin version works:\nWhy doesn\u0027t it need to push and pop BP like a normal function prologue would?\nWhy does it subtract an extra 64 bytes from SP before making the forwarded call?\n\nI\u0027m happy to copy it once I have a better idea of what it\u0027s doing...",
      "parentUuid": "81b56446_700d25e2",
      "revId": "35641fcc77e69481117485ccd21f72241faf38bc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e19380d8_b8d040df",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 6365
      },
      "writtenOn": "2016-10-28T15:49:08Z",
      "side": 1,
      "message": "In particular, I was under the impression (from the PDF linked in https://github.com/golang/go/issues/16922#issuecomment-243748180 and the frame pointer change mentioned in #15840) that BP, as the amd64 frame pointer, is now callee-save.",
      "parentUuid": "61ba3039_0c1926ed",
      "revId": "35641fcc77e69481117485ccd21f72241faf38bc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a6eefe70_3e90c064",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 5206
      },
      "writtenOn": "2016-10-28T17:18:46Z",
      "side": 1,
      "message": "sigfwd is calling a function that is assumed to be written in C, so C ABI rules apply.  In the amd64 C ABI BP is callee saved,  meaning that the callee will not change it.  So it\u0027s fine for sigfwd to store a value in BP across a call to a C ABI function.\n\nI think the subtraction of $64 is unnecessary.  I think I accidentally copied that from asm_amd64.s, where it is there because the Windows C ABI requires it in some cases.  But of course Darwin does not.",
      "parentUuid": "e19380d8_b8d040df",
      "revId": "35641fcc77e69481117485ccd21f72241faf38bc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6655e638_d7d0dcdc",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 6365
      },
      "writtenOn": "2016-10-28T17:29:14Z",
      "side": 1,
      "message": "\u003e sigfwd is calling a function that is assumed to be written in C, so\n \u003e C ABI rules apply.  In the amd64 C ABI BP is callee saved,  meaning\n \u003e that the callee will not change it.  So it\u0027s fine for sigfwd to\n \u003e store a value in BP across a call to a C ABI function.\n \nSorry, I guess I was unclear.  I understand why it\u0027s safe to save SP in BP across the call *from* sigfwd.  I do not understand why it\u0027s safe to clobber the BP value that was passed *to* sigfwd without saving it, given that that call (and sigfwd itself) may then return.\n\nMy understanding is that in the Go calling convention, BP is callee-saved when frame pointers are enabled, and they are enabled by default as of 1.7.  Am I mistaken?",
      "parentUuid": "a6eefe70_3e90c064",
      "revId": "35641fcc77e69481117485ccd21f72241faf38bc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "61ba3039_a13900ef",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 5206
      },
      "writtenOn": "2016-10-28T20:41:14Z",
      "side": 1,
      "message": "Ah, my apologies.  This is theoretically a problem for all C ABI callee-saved registers, since the signal handler runs Go code and Go can trample pretty much any register.  In fact, it seems to me that BP is the only register is not a problem for, since the Go signal handling function will save BP and then restore it on the way out.\n\nThat is, the potential problem here is that the kernel calls the signal handler, expecting it to be a properly behaved C ABI function that preserves all callee-saved registers.  The Go signal handler, written in assembly, immediately jumps into Go code, that does not follow the C ABI, and promptly trashes all the registers.  Eventually, in some cases, the Go code returns to the kernel, at which point the registers are trashed.  Except for BP, since BP is a callee-saved register for Go, so it will retain the same value it had when the kernel called the signal handler.\n\nIn practice, this has never been a problem.  I expect that the kernel doesn\u0027t want to risk that misbehaving userspace code will mess up its registers.  If there ever were a problem, the fix would be to change runtime.sigtramp to save all callee-saved register before calling runtime.sigtrampgo.\n\nI hope I understood you correctly this time.",
      "parentUuid": "6655e638_d7d0dcdc",
      "revId": "35641fcc77e69481117485ccd21f72241faf38bc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6655e638_fd5e9f58",
        "filename": "src/runtime/sys_linux_amd64.s",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 6365
      },
      "writtenOn": "2016-10-28T21:05:50Z",
      "side": 1,
      "message": "I think I\u0027m starting to understand, but I\u0027m not quite there yet.\n\n\u003e That is, the potential problem here is that the kernel calls the signal handler, expecting it to be a properly behaved C ABI function that preserves all callee-saved registers.\n\nIt\u0027s not just the kernel; other signal handlers registered later may forward signals (as the Go runtime does) and expect that the forwarded-to function also follows C calling conventions.  But I\u0027d rather leave that as a separate issue for now, as I do not currently have an example of such a handler.\n\n----\n\nMy more immediate concern is that the C handler function might return, in which case sigfwd will return and we will execute the (Go) function epilogues for sigfwdgo and sigtrampgo without having restored the BP value they expect to be callee-saved, potentially leading to an unexpected segfault within one of those two functions.\n\n(I can be confident that sigtramp and cgoSigtramp don\u0027t care about the previous value of BP because they\u0027re written in assembly.  I\u0027m less confident about the functions written in Go.)",
      "parentUuid": "61ba3039_a13900ef",
      "revId": "35641fcc77e69481117485ccd21f72241faf38bc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}