{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5a1e7c78_3176f5ae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-15T18:32:54Z",
      "side": 1,
      "message": "Bryan, Rob, is this the kind of fix either of you were thinking about?\n\nI think the logic is correct. I know it\u0027s rough; the dot check is a bit lazy, I don\u0027t use filepath, and there are no tests.\n\nBut hey, all my tests now pass for all edge cases :) So at least that\u0027s a signal that it\u0027s close enough to the right solution.",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ae9178e_c9bf0987",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-15T18:33:46Z",
      "side": 1,
      "message": "I should also note that this is far simpler than what FindPkg does with its \"walk vendor directories\" logic. Maybe we want to reuse that instead?",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "675b3f7f_f708acda",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-15T18:38:52Z",
      "side": 1,
      "message": "Err, I forgot that FindPkg goes through go/build.Import, which is a pretty big hammer. So probably not.",
      "parentUuid": "9ae9178e_c9bf0987",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3c9428b0_a06ea625",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-15T19:20:52Z",
      "side": 1,
      "message": "I\u0027ll take it that you agree this is roughly the right fix? I\u0027ll add tests and polish it up tomorrow.",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e415646e_91dfb83b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-04-15T20:21:45Z",
      "side": 1,
      "message": "I honestly don\u0027t know gcimporter well enough to say.\n\nI had a quick look through the code, but there is a weird discontinuity: the caller in go/importer¬π has a comment that says `\"\" /* no vendoring */`, implying that that caller expects the path to resolve vendoring using the path, but then nothing in go/internal/gcimporter actually seems to take GOPATH-mode vendoring into account anyway. And, to top it all off, I don\u0027t see anything in gcimporter.FindPkg that would know anything about standard-library vendoring either. So I don\u0027t see how ImportFrom could even work at all. ü§∑\n\nSo probably gcimporter is also broken for vendoring in GOPATH mode, and for standard-library vendoring when the lookup function is nil. And then it seems inconsistent to un-break it only for the case of a non-nil lookup function, but I dunno, maybe that\u0027s ok..?\n\n\nI do notice that the comment on `go/importer.ForCompiler` says ‚ÄúA lookup function must be provided for correct module-aware operation.‚Äù That comes from CL 74354, and the commit message on that CL seems to imply that Russ thinks that the caller ought to have already canonicalized the import map (and applied vendoring transformations) by the time this function is called either way.\n\nSo I\u0027m left to conclude that the ImportFrom method on the gcimporter is incoherent, in that it expects the caller to have canonicalized paths (which seems reasonable), but *also* canonicalizes certain paths (relative imports and absolute paths) on behalf of the caller.\n\nI don\u0027t actually know who the caller is or what the caller is doing, so I don\u0027t know how to resolve that incoherence. I suspect that the doc comment on importer.ForCompiler needs to be updated either way.\n\n\n¬πhttps://github.com/golang/go/blob/7ed6d1f2fb2e092f59ec56e0d16b1f9da33992a4/src/go/importer/importer.go#L95",
      "parentUuid": "3c9428b0_a06ea625",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08080ac1_6848ca63",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-16T08:52:45Z",
      "side": 1,
      "message": "Alan\u0027s google account seems to be dead, so I tried CCing his personal email.",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b9b2db9_41aca479",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-16T08:52:45Z",
      "side": 1,
      "message": "For clarity, the non-lookup-func path uses go/build.Import, which *does* know how to use vendor folders, as far as I can tell: https://golang.org/src/go/build/build.go#L631\n\nSo I do think it\u0027s at least more consistent to make the lookup func path also treat vendored packages properly. And I think we had agreed earlier that go/types didn\u0027t seem to have a bug, as it provided ImportFrom with all the information necessary to figure out what to do.\n\nRobert and Alan are listed as owners of go/importer. Perhaps one of them can provide some brief guidance? :)",
      "parentUuid": "e415646e_91dfb83b",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31e032ff_1b8ff8fd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 31647
      },
      "writtenOn": "2021-04-16T15:03:12Z",
      "side": 1,
      "message": "Sorry, it\u0027s taken me an hour or so to wrap my head around this, as I\u0027m not that familiar with the full historing of vanity imports, vendoring, std vendoring, etc.\n\nI think the comment in gcimporter that import paths should have already been canonicalized is misleading / erroneous. AFAICT, there is no canonicalization going on in go/types.  Also, if the path were already canonical in ImporterFrom, we wouldn\u0027t need the srcDir, right? (that\u0027s not a rhetorical question: I\u0027m checking my understanding).\n\nBTW, per my searching \"canonical import path\" or \"package id\" is not actually fully defined anywhere, and in fact may mean different things in different contexts: I think the gcimporter code simply means that e.g. \"unsafe/\" has already been cleaned up. Elsewhere, it means that vendoring has been resolved. Elsewhere, it refers to go1.4 custom import path...\n\nSo while I think this logic is approximately correct, per my understanding of std vendoring (modulo edge cases mentioned in other comments), I feel like things are, as Bryan put it, incoherent.\n\nWe need to answer the following questions:\n - What *precisely* is the definition of canonical import path. (certainly it must be *normalized* (i.e. not unsafe//), but what about vendoring? What about vanity imports?\n - What state must the import path be in when ImportFrom is called?\n - Is it possible to canonicalize the import path *before* calling Lookup? (I\u0027m a bit confused by that: canonicalization involves scanning vendor directories, which seems contrary to the purpose of a lookup function).\n\nI don\u0027t feel qualified to answer these questions.",
      "parentUuid": "2b9b2db9_41aca479",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddeb2b6e_5177b6ee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-04-16T15:39:15Z",
      "side": 1,
      "message": "\u003e For clarity, the non-lookup-func path uses go/build.Import, which *does* know how to use vendor folders, as far as I can tell:\n\nAh, I see what you mean. Yes, I agree that that probably does already take various kinds of vendoring into account. So this at least seems to make things more consistent.\n\n\n\u003e if the path were already canonical in ImporterFrom, we wouldn\u0027t need the srcDir, right?\n\nCorrect! But it\u0027s possible that this is some weird degenerate case, where something requires ImporterFrom to be present but doesn\u0027t actually rely on the parts of it that are semantically different from plain old Import.\n\n\n\u003e - What *precisely* is the definition of canonical import path?\n\nFor the purpose here, I believe it is: ‚Äúwhat is the unique path to the package that will actually be imported by an import statement with the given string?‚Äù\n\n\nI don\u0027t know the answers to the other questions.",
      "parentUuid": "31e032ff_1b8ff8fd",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35c031c7_c3ef5d62",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-16T21:01:15Z",
      "side": 1,
      "message": "I apologize, but I think I\u0027m changing my mind again. The docs say:\n\n\u003e The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer. \n\nThis is consistent with how gcimporter\u0027s ImportFrom works today. When lookup\u003d\u003dnil, paths are canonicalized by go/build.Import. Otherwise, it\u0027s the caller\u0027s responsibility to canonicalize, including differentiating between an external golang.org/x/foo and a special std-vendored vendor/golang.x/foo.\n\nYou\u0027re right that srcDir is useless when lookup!\u003dnil, but it needs to be there when lookup\u003d\u003dnil. I guess one could have split the method in two, but here we are.\n\nMy earlier point about ImportFrom being more consistent to always canonicalize doesn\u0027t really hold water by itself, if it goes against what the docs have said for years.\n\nThe only bit that troubles me is that ImportFrom is a hard API to call from go/types. It receives a types.Importer, so it can\u0027t even tell if lookup was used. It can\u0027t know if it should be in charge of canonicalizing paths or not.\n\nSo it almost seems like it should be on me, the end user setting lookup, to deal with this. I made a terrible hack that just so happens to work:\n\ntype importerWithMap func(path, dir string, mode types.ImportMode) (*types.Package, error)\n                \nfunc (fn importerWithMap) Import(path string) (*types.Package, error) {     \n        panic(\"should never be called\")\n}\n                                        \nfunc (fn importerWithMap) ImportFrom(path, dir string, mode types.ImportMode) (*types.Package, error) {                                                                                             \n        if path2 :\u003d curPkg.ImportMap[path]; path2 !\u003d \"\" {\n                path \u003d path2                                                                      \n        }                                    \n        return fn(path, dir, mode)                                                 \n}                                                                                     \n\ncurPkg.ImportMap is the same ImportMap that \"go list -json\" gives. This importer wraps go/importer.ForCompiler with a lookup func, so in between go/types and gcimporter, I am able to sneakily canonicalize the path.\n\nI\u0027m not even sure if this is the right solution, but it passes all tests for the nasty edge cases. I\u0027m not even bothered about relative or absolute package paths, to be honest.\n\nBut I think this solution might actually be better than completely changing the API contract for ImportFrom.",
      "parentUuid": "ddeb2b6e_5177b6ee",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70c954a6_a4a6053f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 31647
      },
      "writtenOn": "2021-04-16T21:18:23Z",
      "side": 1,
      "message": "The one thing I\u0027m convinced of is that go/types is not (and should not be) able to resolve this.\n\nIt seems reasonable to wrap the importer to canonicalize the path before delegating to the gcimporter.",
      "parentUuid": "35c031c7_c3ef5d62",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c243fdeb_55ce28b1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-16T21:26:51Z",
      "side": 1,
      "message": "\u003e The one thing I\u0027m convinced of is that go/types is not (and should not be) able to resolve this.\n\nI know little about go/types in this area, so I\u0027ll defer to you :) But it does seem, at best, difficult for it to do the right thing with no help.\n\nHere\u0027s the horrible hack to wrap the importer: https://github.com/burrowers/garble/pull/316\n\nThe question then is... Is this really how go/importer is meant to be used with a lookup func? If so, I\u0027m impressed at the inherent complexity of the API. At least we could provide more guidance or examples.",
      "parentUuid": "70c954a6_a4a6053f",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81764820_7593a367",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-04-28T14:23:06Z",
      "side": 1,
      "message": "I honestly don\u0027t know how go/importer is meant to be used. I agree that the API seems much more complex than necessary, but I\u0027m not sure to what extent we can salvage it in a backward-compatible way (vs. creating a new, simpler entry-point).",
      "parentUuid": "c243fdeb_55ce28b1",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30201c57_d94af808",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-28T14:32:06Z",
      "side": 1,
      "message": "Do you want to leave that comment on the original issue? I think it\u0027s clear we don\u0027t know what the right fix is, so I\u0027m going to abandon this CL for now. The discussion and/or design is easier on github.",
      "parentUuid": "81764820_7593a367",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a91851f6_61c1f289",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-04-28T14:40:30Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "30201c57_d94af808",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a05adf45_9e1465ed",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-04-15T19:03:30Z",
      "side": 1,
      "message": "FWIW, the condition that the \u0027go\u0027 command currently uses is here:\nhttps://github.com/golang/go/blob/ddd8d7c0a6859114f1f9bfbb3c56fb63f870badc/src/cmd/go/internal/search/search.go#L554-L561\n\nand the call site is here:\nhttps://github.com/golang/go/blob/ddd8d7c0a6859114f1f9bfbb3c56fb63f870badc/src/cmd/go/internal/modload/load.go#L1296-L1331\n\nAFAICT the main difference is that search.IsStandardImportPath only searches the first element for the dot.",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc967da1_d4eeb5e8",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-04-15T19:03:30Z",
      "side": 1,
      "message": "To be pedantic, I think you may need to check for GOROOT/src as a prefix, not just GOROOT.\n\n(Otherwise you could theoretically get erroneous results for the module in `GOROOT/misc`, depending on whether that ever ends up depending on external modules and, if so, whether it ends up vendoring them. The vendored dependencies of the `misc` repo would presumably not be special in the way that the standard-library ones are.)",
      "range": {
        "startLine": 100,
        "startChar": 34,
        "endLine": 100,
        "endChar": 67
      },
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8e915df_198f2dfc",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-15T19:20:52Z",
      "side": 1,
      "message": "Good point.",
      "parentUuid": "dc967da1_d4eeb5e8",
      "range": {
        "startLine": 100,
        "startChar": 34,
        "endLine": 100,
        "endChar": 67
      },
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7e0b676_2dc515eb",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-15T19:20:52Z",
      "side": 1,
      "message": "Yeah, that\u0027s what I meant earlier about this dot check being lazy.",
      "parentUuid": "a05adf45_9e1465ed",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6280838d_825c96ac",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 31647
      },
      "writtenOn": "2021-04-16T15:03:12Z",
      "side": 1,
      "message": "To be extra pedantic, you should check\n\nstrings.HasPrefix(srcDir + \"/\", runtime.GOROOT() + \"/src/\")\n\nElse you\u0027d match $GOROOT/srcbutnot.",
      "parentUuid": "a8e915df_198f2dfc",
      "range": {
        "startLine": 100,
        "startChar": 34,
        "endLine": 100,
        "endChar": 67
      },
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c37fa28_5a9a02c9",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-04-16T15:39:15Z",
      "side": 1,
      "message": "I think the laziness  is actually important here, because if the passed-in path is _already_ `cmd/vendor/golang.org/‚Ä¶` we don\u0027t want to double-escape it.",
      "parentUuid": "d7e0b676_2dc515eb",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddb4114f_2d2fc00c",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-16T21:01:15Z",
      "side": 1,
      "message": "Indeed, I didn\u0027t mean to say it\u0027s not important - just that I was taking a shortcut for the sake of the proof of concept.",
      "parentUuid": "7c37fa28_5a9a02c9",
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "443158ef_3482d039",
        "filename": "src/go/internal/gcimporter/gcimporter.go",
        "patchSetId": 1
      },
      "lineNbr": 100,
      "author": {
        "id": 13550
      },
      "writtenOn": "2021-04-16T21:01:15Z",
      "side": 1,
      "message": "Good point.",
      "parentUuid": "6280838d_825c96ac",
      "range": {
        "startLine": 100,
        "startChar": 34,
        "endLine": 100,
        "endChar": 67
      },
      "revId": "c8d8c13c3245603fbb8b60d676ecc9ec877002e6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}