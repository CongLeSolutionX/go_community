{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "33cf495a_94e1f10a",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 158,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "Let\u0027s rename this to rfd, since it\u0027s clearly referring to a pipe in this context.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24614189_6a9b2a4b",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 158,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:08:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "33cf495a_94e1f10a",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e17810d_687f440a",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 159,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "Likewise here, let\u0027s rename to wfd.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19a13913_fb10906b",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 159,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:08:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7e17810d_687f440a",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa7646a5_a0bd6b0c",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 161,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "Since we are using sync.Pool, and not a linked list of pipes, drop this field.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9faa335_0f2fb941",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 161,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:08:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fa7646a5_a0bd6b0c",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "132a1ad5_82d94af6",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "It doesn\u0027t look like this is initialized anywhere. The New field of the pool must be initialized. Use newPipe in the New function.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5ae9882_2b100d63",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:08:23Z",
      "side": 1,
      "message": "The reason why I didn\u0027t assign newPipe to the New function is that I don\u0027t want to swallow the err inside the New.",
      "parentUuid": "132a1ad5_82d94af6",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab2d0b32_e7b02ca0",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T05:53:07Z",
      "side": 1,
      "message": "But we swallow this error in the net package anyway, see net.(*TCPConn).readFrom in src/net/tcpsock_posix.go. I don\u0027t see what else we could possibly do with it.\n\nMore generally, it seems to me like we never return an error from pipe2 to any place that matters, because when we fail to create a pipe (for any reason at all), we have handled \u003d\u003d false, and the net package uses the genericReadFrom code path. Given that this is the case, I think we could do away with the sc return value from poll.Splice as well. I believe that for all code which cares about the error (namely when handled \u003d\u003d true), sc \u003d\u003d \"splice\" always holds.\n\nUnless I am missing something, I think using the New function and removing this additional error return path (along with the sc return value) significantly simplifies the code.",
      "parentUuid": "f5ae9882_2b100d63",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "995964b9_cccf5fda",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T06:15:25Z",
      "side": 1,
      "message": "Sorry, but I\u0027ve seen this error is being returned all the way back to the user, such as bufio.(*Reader).WriteTo(), instead of being discarded.",
      "parentUuid": "ab2d0b32_e7b02ca0",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69a86cba_c5ae50e5",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T06:27:21Z",
      "side": 1,
      "message": "On a pipe error of any kind, poll.Splice unconditionally returns handled \u003d\u003d false: https://github.com/golang/go/blob/66c02645062561ac29d00297e8d8c49698b2e4da/src/internal/poll/splice_linux.go#L33\n\nwhich net.splice also returns up the stack: https://github.com/golang/go/blob/66c02645062561ac29d00297e8d8c49698b2e4da/src/net/splice_linux.go#L43\n\nwhich finally reaches net.(*TCPConn).readFrom, here: https://github.com/golang/go/blob/66c02645062561ac29d00297e8d8c49698b2e4da/src/net/tcpsock_posix.go#L48\n\nWhen handled \u003d\u003d false, readFrom unconditionally discards err and returns genericReadFrom(c, r) instead.",
      "parentUuid": "995964b9_cccf5fda",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f896673a_4292ee44",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T06:37:38Z",
      "side": 1,
      "message": "Oh, now I get your point, it\u0027s all controlled by the `handled` variable.\n\nBut I\u0027m a little bit confused though, why would we set `handled` false to discard the pipe error? And why can\u0027t we just return this error to the users?",
      "parentUuid": "69a86cba_c5ae50e5",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "845a9571_8bb24f7c",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T06:40:57Z",
      "side": 1,
      "message": "Because when we fail to create a pipe, we can still do a read + write based (rather than splice based) transfer of the data from src to dst, which is what the genericReadFrom function in the net package does.\n\nFor example, if the process has reached a file descriptor limit, we want to do the read + write pairs anyway, and not fail with a pipe error, because using splice is only an optimization.",
      "parentUuid": "f896673a_4292ee44",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "707a2652_2d127d4b",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T06:43:09Z",
      "side": 1,
      "message": "Got it, I am on my way to refactor the current code of Pool.New.",
      "parentUuid": "845a9571_8bb24f7c",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82ad023d_832e0cba",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 164,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T07:16:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "707a2652_2d127d4b",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "841bd525_8faf928a",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 170,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "This doesn\u0027t seem right. If fetching a pipe from the pool failed, it means we cannot create pipes, so I don\u0027t think we should try again. Return an error instead, and let the code return out of poll.Splice altogether. syscall.EINVAL is a good candidate, like the disableSplice code uses.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f4c0bac_ae78c27f",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 170,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:08:23Z",
      "side": 1,
      "message": "Since the New function is not set, so failing to fetch a pipe here is not because the newPipe() failed, but the pool has run out of cached pipes, so the logic here is proper.",
      "parentUuid": "841bd525_8faf928a",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66c49882_46a367f7",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 170,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T07:16:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1f4c0bac_ae78c27f",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6fa09c3_27c7b539",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "I don\u0027t think doing this here is right, since newPipe can return an error. I think the finalizer should be set by newPipe itself, immediately before returning successfully.\n\nAlso, I think this call can be simplified into runtime.SetFinalizer(p, destroyPipe).",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3e6fe4c_1929bcdd",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:08:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c6fa09c3_27c7b539",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fc4980b2_bf029f05",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:15:47Z",
      "side": 1,
      "message": "I disagree your point about newPipe setting Finalizer for pipe respectfully, from the point of my view, the duties of newPipe() and destroyPipe() ought to be clear: they is only in chagre of creating and destorying pipes, the caching and releasing stuff should be taked care by the pool, so I prefer to set up and unset the Finalizer by the pool.",
      "parentUuid": "b3e6fe4c_1929bcdd",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d43e48db_067bb5c1",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:16:33Z",
      "side": 1,
      "message": "they is --\u003e they are",
      "parentUuid": "fc4980b2_bf029f05",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f750ef1_113931b1",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:19:39Z",
      "side": 1,
      "message": "taked care --\u003e taken care of",
      "parentUuid": "d43e48db_067bb5c1",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e319287_c6c61cdf",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "Can we salvage the pipe somehow, even if it has outstanding data?\n\nIf p.data \u003d\u003d n, then a read of size n from the pipe should empty it, and make it re-usable. I wonder if it would be cheaper to allocate a buffer in order to read from the pipe and empty it, instead of discarding the pipe altogether.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ababaf6_00cf1567",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T06:31:32Z",
      "side": 1,
      "message": "Discard the pipe would be the simplest way to do that, I just went referring to the pipe pool in HAProxy, it also did it this way, https://github.com/haproxy/haproxy/blob/v2.3.0/src/pipe.c#L110-L113.",
      "parentUuid": "6e319287_c6c61cdf",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b54f0def_961b4531",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 178,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T06:36:21Z",
      "side": 1,
      "message": "OK, that seems fine.",
      "parentUuid": "4ababaf6_00cf1567",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4e737c3_9ae5e05c",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 224,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "It seems like we never use the error returned by this function anywhere. Maybe we should drop it altogether.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16128647_ef2e60d1",
        "filename": "src/internal/poll/splice_linux.go",
        "patchSetId": 4
      },
      "lineNbr": 224,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:08:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a4e737c3_9ae5e05c",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75ec5893_87529588",
        "filename": "src/internal/poll/splice_linux_test.go",
        "patchSetId": 4
      },
      "lineNbr": 1,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-11-20T04:27:10Z",
      "side": 1,
      "message": "Note that package testing imports package os, and package os imports package internal/poll, which means that the tests for the poll package must live outside of it. For tests that exercise the Splice code path, see splice_test.go in package net.",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc7d8a3d_e1bd3003",
        "filename": "src/internal/poll/splice_linux_test.go",
        "patchSetId": 4
      },
      "lineNbr": 1,
      "author": {
        "id": 34725
      },
      "writtenOn": "2020-11-20T05:09:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "75ec5893_87529588",
      "revId": "f2926fe3bb7f78e1f3e3b22bf09769b2a23c2d9f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}