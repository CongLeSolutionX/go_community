{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9eb400bc_6af87f08",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-01-15T23:42:50Z",
      "side": 1,
      "message": "goos: darwin\ngoarch: arm64\nname                     old time/op    new time/op    delta\nConcat2-24                 10.6ns Â± 1%    10.0ns Â± 2%  -5.51%  (p\u003d0.000 n\u003d10+10)\nConcat3-24                 13.2ns Â± 2%    12.3ns Â± 1%  -6.91%  (p\u003d0.000 n\u003d10+10)\nConcat4-24                 17.2ns Â± 1%    16.6ns Â± 0%  -3.25%  (p\u003d0.000 n\u003d10+8)\nConcat5-24                 19.9ns Â± 1%    19.5ns Â± 0%  -2.35%  (p\u003d0.000 n\u003d10+10)\nConcat6-24                 34.8ns Â± 1%    34.4ns Â± 2%  -1.17%  (p\u003d0.007 n\u003d10+10)\n\nSo similar results to yours.\n\nIf anyone has bench results on other archs, please post them.\n\nOne minor difference, concat6 is large enough to trigger a heap allocation, so maybe it is a bit different than the one you reported in the issue? (Run with -test.benchmem.)\n\nMy go binary is 0.5% bigger.\n\nUnfortunately I think this falls squarely in the \"not sure if it is worth it\" category. The speed gains aren\u0027t huge, and the space usage is not all that much worse. This makes deciding hard ðŸ˜ž\n\nI would lean toward not doing it, though. Places which concatenate strings a lot are probably not doing string addition. They are doing []byte appends, bytes.Buffer operations, or something else with more control over allocation. But even cold string addition could well pollute the icache.",
      "revId": "806d86b0dbca8e31fcc3324d6ea8a9a0c7a409ef",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}