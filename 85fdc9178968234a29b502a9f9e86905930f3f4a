{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8b4517d4_bf466e62",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 25391
      },
      "writtenOn": "2021-05-10T11:51:44Z",
      "side": 1,
      "message": "unfortunately, I believe this change is too late to make it for Go 1.17. see: https://groups.google.com/g/golang-dev/c/HzfjCwV_k5E",
      "revId": "85fdc9178968234a29b502a9f9e86905930f3f4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00cb24cc_28a23382",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-05-19T19:59:09Z",
      "side": 1,
      "message": "This is \"fixed\" by CL 393402, which makes persistentalloc require a non-nil stat, but also switches this allocation to no longer use persistentalloc since we don\u0027t want to count it.",
      "revId": "85fdc9178968234a29b502a9f9e86905930f3f4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e11c79e_a41e072b",
        "filename": "src/runtime/malloc.go",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 25391
      },
      "writtenOn": "2021-05-10T11:51:44Z",
      "side": 1,
      "message": "if I understand correctly, the reason why we don\u0027t do this is because we rely, to some degree, on this map being lazily committed on modern operating systems as we use more address space. in most cases, this will dramatically overcount gcMiscSys for small processes, though as you point out, today we undercount large processes as a result.\n\nit\u0027s worth noting this memory does count against things like overcommit, so maybe it\u0027s still worth counting this way.",
      "range": {
        "startLine": 737,
        "startChar": 89,
        "endLine": 737,
        "endChar": 108
      },
      "revId": "85fdc9178968234a29b502a9f9e86905930f3f4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "806b215a_bdc40f55",
        "filename": "src/runtime/malloc.go",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 25391
      },
      "writtenOn": "2021-05-10T11:57:47Z",
      "side": 1,
      "message": "more specifically, on linux/amd64, this is: 2^48 / 2^26 * 2^3 \u003d 32 MiB. for a small Go process using ~5 MiB of RAM, that\u0027s a pretty significant overcount.\n\nI think one thing we could do here to make this more accurate is to do what mpagealloc_64bit.go does for its large memory reservation, but that seems overkill for an array like this.\n\nanother idea is to account for it in a separate metric that scales according to the peak heap address space size (HeapSys + StackInuse + a bunch of other stats that cause a subtraction from HeapSys). it won\u0027t be 100% accurate, but it will be quite close. this is probably what I would\u0027ve done for mpagealloc_64bit.go if not for overcommit issues that forced precise accounting.",
      "parentUuid": "0e11c79e_a41e072b",
      "range": {
        "startLine": 737,
        "startChar": 89,
        "endLine": 737,
        "endChar": 108
      },
      "revId": "85fdc9178968234a29b502a9f9e86905930f3f4a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}