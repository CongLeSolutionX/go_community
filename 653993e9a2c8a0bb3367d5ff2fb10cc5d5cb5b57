{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0e812635_2889eb9f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-15T01:43:59Z",
      "side": 1,
      "message": "Thanks.  The problem with this approach is that calling make with a very large but valid value will cause the program to fail to allocate memory and crash.  I think it would be fine to return an error if s.Size is negative when treated as a signed integer.  But if the value is in range, then we can\u0027t just return make; we still should go through saferio.ReadData or something similar, to keep us from crashing due to an out of memory error.",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb61380a_25e51c32",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-15T05:14:33Z",
      "side": 1,
      "message": "I just had a checked, the type of `s.Size` is `uint64`, so we don\u0027t have to worry about the negative value.\n\nI think the problem here is that it\u0027s hard to decide whether the size is valid. Looking back, I think Dan Kortschak\u0027s approach (return `nil, nil`) is better. I can not think of a use case that a caller wants the byte slice from a SHT_NOBITS section. How about let\u0027s just document it and returns `nil, nil`?\n\n\n```\n// ...\n//\n// It returns \"nil, nil\" when the content type is SHT_NOBITS.\nfunc (s *Section) Data() ([]byte, error) {\n\tif s.Type \u003d\u003d SHT_NOBITS {\n\t\treturn nil, nil\n\t}\n\treturn saferio.ReadData(s.Open(), s.Size)\n}\n\n// ...\n//\n// The ReadSeeker can be used to read bytes with zero value from\n// an SHT_NOBITS section.\nfunc (s *Section) Open() io.ReadSeeker {\n```",
      "parentUuid": "0e812635_2889eb9f",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cf16b21_991d79a8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-16T02:20:21Z",
      "side": 1,
      "message": "Changing to return nil, nil would not be backward compatible, and I think it would be hard to justify that change at this point.  I agree that it would have been the right choice earlier.",
      "parentUuid": "fb61380a_25e51c32",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa144de6_09ad6d3e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-16T04:05:47Z",
      "side": 1,
      "message": "How about let\u0027s set a soft limit for the size? When the size is larger than the limit, it returns `nil, err`. Otherwise, it returns `make([]byte, s.Size), nil`. It still breaks the compatibility, but just for most likely invalid input. And the user can workaround it by checking `s.Type` before calling this function.\n\nI checked Chrome on my computer, the size of the `.bss` section is 0X236a50 (around 2.2M). The chunk size of `saferio` is 10M. I think it\u0027s safe to set the soft limit to 10M.",
      "parentUuid": "7cf16b21_991d79a8",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eeb17587_66a468cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-16T20:11:33Z",
      "side": 1,
      "message": "I don\u0027t yet see the argument for returning an error when we can return a valid value.  We want our code to behave correctly.\n\nIt\u0027s not like we are telling people to call the Data method for .bss.  It\u0027s easy enough for them to not do so.  But if they do it, we should give them the correct results.",
      "parentUuid": "fa144de6_09ad6d3e",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76521ff7_bdb23389",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T01:08:28Z",
      "side": 1,
      "message": "Understood. I think the ideal solution is to have a fake byte slice that doesn\u0027t have any item but can be read from (something like the `zeroReader`). As far as I know, there is not way to create a fake byte slice like this. Even we can, I think the fake byte slice can not be modified, the caller still can not use this fake slice like a real slice.\n\nI don\u0027t know how to improve the situation any more. Do you have any suggestion?",
      "parentUuid": "eeb17587_66a468cb",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74c461d1_a02d594f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 6480
      },
      "writtenOn": "2022-09-17T01:30:02Z",
      "side": 1,
      "message": "If it were arguable that allocation of the slice in this case is a security issue then you could do the `nil, nil` return under the Go1 promise caveats. I think this is the case, but I am probably alone here. (I\u0027ll be maintaining an internal fork with the `nil, nil` behaviour for safety).\n\nThe alternative is to ensure that this is not called indirectly within the stdlib and to document that if the type of the section is NOBITS, `Data` should not be called and that `Size` can be used to determine the size of the section instead.",
      "parentUuid": "76521ff7_bdb23389",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f35db703_97a8a487",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-17T01:35:44Z",
      "side": 1,
      "message": "My suggestion is what I wrote above: use saferio to read from zeroReader.  That will build a slice of the appropriate size without crashing the program.",
      "parentUuid": "74c461d1_a02d594f",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24c42d7b_65021886",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 6480
      },
      "writtenOn": "2022-09-17T01:42:16Z",
      "side": 1,
      "message": "That\u0027s the current behaviour; when `Section.Open` is called and the `Section.Type` is `SHT_NOBITS`, the `zeroReader` is used to populate the `io.SectionReader`. What this means is that if the size of the section is larger than is allocatable, you end up with the behaviour that is described in the CL description.",
      "parentUuid": "f35db703_97a8a487",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28e145cd_63f42bb5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T02:05:25Z",
      "side": 1,
      "message": "\u003e The alternative is to ensure that this is not called indirectly within the stdlib\n\nFYI, CL The alternative is to ensure that this is not called indirectly within the stdlib",
      "parentUuid": "24c42d7b_65021886",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25d72fdc_57873444",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T02:05:25Z",
      "side": 1,
      "message": "\u003e The alternative is to ensure that this is not called indirectly within the stdlib\n\nFYI, CL 430155 is for that.",
      "parentUuid": "24c42d7b_65021886",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "573d3690_de1cfb4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T02:06:32Z",
      "side": 1,
      "message": "Sorry, the last comment is sent unintentionally. Please ignore it.",
      "parentUuid": "28e145cd_63f42bb5",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "144753c8_9cb09938",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-17T21:57:01Z",
      "side": 1,
      "message": "Thanks, sorry for completely and persistently misunderstanding the problem.\n\nLooking at the history, it looks like before CL 375216 (January 14, 2022) we returned incorrect results.  And even after that CL it looks like we can\u0027t return good results for a corrupt file.\n\nThis suggests to me that we should return an error for a call to Data of a NOBITS section.  I\u0027m not sure \"return nil, nil\" is quite right, as that might lead a program to simply do the wrong thing, thinking that the section is empty.  I think it may be better to return an error, to force the caller to check for a NOBITS section and make a choice.\n\nWhat do you think?",
      "parentUuid": "573d3690_de1cfb4c",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22995477_6be7d325",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 6480
      },
      "writtenOn": "2022-09-17T22:10:52Z",
      "side": 1,
      "message": "I think that is a sensible approach, in conjunction with additional documentation indicating the behaviour. Thanks.",
      "parentUuid": "144753c8_9cb09938",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a482e73_ad7289af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T22:44:49Z",
      "side": 1,
      "message": "\u003e I think it may be better to return an error, to force the caller to check for a NOBITS section and make a choice.\n\nTotally agree.\n\nWhat should we do with the `io.ReadSeeker` returned by the `Open` method? Should we return the same error when `ReadAt` is called? Or just leave it as what it it now?",
      "parentUuid": "22995477_6be7d325",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f864aacf_c7041448",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 6480
      },
      "writtenOn": "2022-09-17T22:55:37Z",
      "side": 1,
      "message": "One approach would be to change `zeroReader` to be an `invalidReader`-like thing that always returns `0, someMeaningFulError{}` for its `ReadAt` method. This would leave the `Data` method unaltered for all types and make the `File.Open` safe to use. Alternatively, the `invalidReader` could be an `io.ReadSeeker`, though this requires implementing both methods.",
      "parentUuid": "5a482e73_ad7289af",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac91cdd2_d18faf3a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-18T02:08:45Z",
      "side": 1,
      "message": "Since Alessandro is the author of CL 375216, I think we should weight his input. I will try to ping him.",
      "parentUuid": "f864aacf_c7041448",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be43da77_946b7b96",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2022-09-18T06:04:35Z",
      "side": 1,
      "message": "Returning an error unconditionally would break delve for on some real executable files. I don\u0027t remember the exact circumstances but some tool uses SHT_NOBITS for eh_frame, because an all 0 section is a valid eh_frame with no entries.\n\nI changed the reader but I was really interested in changing the behavior of Data(), since that\u0027s what delve calls.\n\nI\u0027m tempted to say that no change should be made: you are trading a crash on invalid input for a rare edge case that needs to be handled for valid inputs. Either way users will have to be aware of something to have a correct program.\n\nAlso, I\u0027m worried this no-panics project might have taken a wrong turn somewhere. Here we have a API that allocates that must not panic but the only way go has to communicate an allocation problem is through panics and fatal errors... what does saferio.ReadData do if you try to read a 10MB section on a 5MB ulimit?",
      "parentUuid": "ac91cdd2_d18faf3a",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d63113cd_faef4544",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-18T12:02:51Z",
      "side": 1,
      "message": "I don\u0027t think that the suggestion is to crash on invalid input.  That would be bad.  The suggestion is to return an error on certain inputs.\n\nYes, with a 5MB ulimit the program will crash.  The goal is not to avoid every crash.  It\u0027s to return an error, rather than crash, on corrupt input.\n\nWhile compatibility is a concern, if starting over it\u0027s not really obvious to me what Data means for a NOBITS section.  There is no data there.",
      "parentUuid": "be43da77_946b7b96",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1340d24_18c3bb24",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2022-09-20T09:21:40Z",
      "side": 1,
      "message": "I don\u0027t think I have anything else to say besides that I think this is a backwards incompatible change that doesn\u0027t really help anyone since calls to Data can crash due to allocation failures in a number of ways, regardless of input validity. Looks like box checking work to me (fuzzer says bad).",
      "parentUuid": "d63113cd_faef4544",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00e75a8e_57054b8c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2022-09-20T09:26:42Z",
      "side": 1,
      "message": "PS. changing at least make and append to panic instead of fatal error when they can\u0027t allocate wouldn\u0027t be the worst idea.",
      "parentUuid": "f1340d24_18c3bb24",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b1c1f7a_cb68f8fa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2022-09-20T09:56:04Z",
      "side": 1,
      "message": "PPS. I think SHF_COMPRESSED has the same problem, it should be possible to craft a compressed section that is reasonably small but expands to a very large size when uncompressed.",
      "parentUuid": "00e75a8e_57054b8c",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}