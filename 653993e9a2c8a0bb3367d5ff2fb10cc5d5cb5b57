{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0e812635_2889eb9f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-15T01:43:59Z",
      "side": 1,
      "message": "Thanks.  The problem with this approach is that calling make with a very large but valid value will cause the program to fail to allocate memory and crash.  I think it would be fine to return an error if s.Size is negative when treated as a signed integer.  But if the value is in range, then we can\u0027t just return make; we still should go through saferio.ReadData or something similar, to keep us from crashing due to an out of memory error.",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb61380a_25e51c32",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-15T05:14:33Z",
      "side": 1,
      "message": "I just had a checked, the type of `s.Size` is `uint64`, so we don\u0027t have to worry about the negative value.\n\nI think the problem here is that it\u0027s hard to decide whether the size is valid. Looking back, I think Dan Kortschak\u0027s approach (return `nil, nil`) is better. I can not think of a use case that a caller wants the byte slice from a SHT_NOBITS section. How about let\u0027s just document it and returns `nil, nil`?\n\n\n```\n// ...\n//\n// It returns \"nil, nil\" when the content type is SHT_NOBITS.\nfunc (s *Section) Data() ([]byte, error) {\n\tif s.Type \u003d\u003d SHT_NOBITS {\n\t\treturn nil, nil\n\t}\n\treturn saferio.ReadData(s.Open(), s.Size)\n}\n\n// ...\n//\n// The ReadSeeker can be used to read bytes with zero value from\n// an SHT_NOBITS section.\nfunc (s *Section) Open() io.ReadSeeker {\n```",
      "parentUuid": "0e812635_2889eb9f",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cf16b21_991d79a8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-16T02:20:21Z",
      "side": 1,
      "message": "Changing to return nil, nil would not be backward compatible, and I think it would be hard to justify that change at this point.  I agree that it would have been the right choice earlier.",
      "parentUuid": "fb61380a_25e51c32",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa144de6_09ad6d3e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-16T04:05:47Z",
      "side": 1,
      "message": "How about let\u0027s set a soft limit for the size? When the size is larger than the limit, it returns `nil, err`. Otherwise, it returns `make([]byte, s.Size), nil`. It still breaks the compatibility, but just for most likely invalid input. And the user can workaround it by checking `s.Type` before calling this function.\n\nI checked Chrome on my computer, the size of the `.bss` section is 0X236a50 (around 2.2M). The chunk size of `saferio` is 10M. I think it\u0027s safe to set the soft limit to 10M.",
      "parentUuid": "7cf16b21_991d79a8",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eeb17587_66a468cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-16T20:11:33Z",
      "side": 1,
      "message": "I don\u0027t yet see the argument for returning an error when we can return a valid value.  We want our code to behave correctly.\n\nIt\u0027s not like we are telling people to call the Data method for .bss.  It\u0027s easy enough for them to not do so.  But if they do it, we should give them the correct results.",
      "parentUuid": "fa144de6_09ad6d3e",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76521ff7_bdb23389",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T01:08:28Z",
      "side": 1,
      "message": "Understood. I think the ideal solution is to have a fake byte slice that doesn\u0027t have any item but can be read from (something like the `zeroReader`). As far as I know, there is not way to create a fake byte slice like this. Even we can, I think the fake byte slice can not be modified, the caller still can not use this fake slice like a real slice.\n\nI don\u0027t know how to improve the situation any more. Do you have any suggestion?",
      "parentUuid": "eeb17587_66a468cb",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74c461d1_a02d594f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 6480
      },
      "writtenOn": "2022-09-17T01:30:02Z",
      "side": 1,
      "message": "If it were arguable that allocation of the slice in this case is a security issue then you could do the `nil, nil` return under the Go1 promise caveats. I think this is the case, but I am probably alone here. (I\u0027ll be maintaining an internal fork with the `nil, nil` behaviour for safety).\n\nThe alternative is to ensure that this is not called indirectly within the stdlib and to document that if the type of the section is NOBITS, `Data` should not be called and that `Size` can be used to determine the size of the section instead.",
      "parentUuid": "76521ff7_bdb23389",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f35db703_97a8a487",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-17T01:35:44Z",
      "side": 1,
      "message": "My suggestion is what I wrote above: use saferio to read from zeroReader.  That will build a slice of the appropriate size without crashing the program.",
      "parentUuid": "74c461d1_a02d594f",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24c42d7b_65021886",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 6480
      },
      "writtenOn": "2022-09-17T01:42:16Z",
      "side": 1,
      "message": "That\u0027s the current behaviour; when `Section.Open` is called and the `Section.Type` is `SHT_NOBITS`, the `zeroReader` is used to populate the `io.SectionReader`. What this means is that if the size of the section is larger than is allocatable, you end up with the behaviour that is described in the CL description.",
      "parentUuid": "f35db703_97a8a487",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28e145cd_63f42bb5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T02:05:25Z",
      "side": 1,
      "message": "\u003e The alternative is to ensure that this is not called indirectly within the stdlib\n\nFYI, CL The alternative is to ensure that this is not called indirectly within the stdlib",
      "parentUuid": "24c42d7b_65021886",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25d72fdc_57873444",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T02:05:25Z",
      "side": 1,
      "message": "\u003e The alternative is to ensure that this is not called indirectly within the stdlib\n\nFYI, CL 430155 is for that.",
      "parentUuid": "24c42d7b_65021886",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "573d3690_de1cfb4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-17T02:06:32Z",
      "side": 1,
      "message": "Sorry, the last comment is sent unintentionally. Please ignore it.",
      "parentUuid": "28e145cd_63f42bb5",
      "revId": "653993e9a2c8a0bb3367d5ff2fb10cc5d5cb5b57",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}