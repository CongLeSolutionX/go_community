{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2e21c33e_25b2839b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-06-29T00:10:01Z",
      "side": 1,
      "message": "Using the access system call is also going to change the behavior if called by a setuid program.  I\u0027m not sure this is the right approach.  Does the shell actually use access, rather than stat, when deciding which program to choose from PATH?",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a24177c2_c0b2ddea",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 26451
      },
      "writtenOn": "2022-06-29T16:24:52Z",
      "side": 1,
      "message": "As a naive approach, I tried\n\nstrace -f bash -c \u0027type -p cc\u0027\nstrace bash cc\n\nand both invocations shows that both stat(2) and access(2) (with R_OK and X_OK) are used.",
      "parentUuid": "2e21c33e_25b2839b",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "494972ed_9e31c563",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 26451
      },
      "writtenOn": "2022-06-29T16:45:03Z",
      "side": 1,
      "message": "Apparently at least bash and which are using eaccess(3). What it does it uses access(2) in case getuid() \u003d\u003d geteuid() \u0026\u0026 getgid \u003d\u003d getegid() (IOW the current process is not setuid/setgid), and falls back to checking the mode bit from stat(2) for a setuid/setgid process.\n\nPerhaps we should do the same thing.",
      "parentUuid": "a24177c2_c0b2ddea",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c01a293f_53b71f35",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 26451
      },
      "writtenOn": "2022-06-29T19:30:43Z",
      "side": 1,
      "message": "OK,\n - newer Linux (v5.8) has `faccessat2(2)` with `AT_EACCESS` flag support;\n - FreeBSD and Dragonfly has `eaccess(2)`;\n - AIX, Solaris, Darwin, Free/Net/OpenBSD and Dragonfly has `faccessat(2)` with `AT_EACCESS` flag support (except that `AT_EACCESS` is not defined for AIX or Darwin but this can be fixed);\n - not sure about hurd or the remaining platforms covered by the `unix` build constraint.\n\nAll in all, it seems we can reuse `os.Faccessat` with `AT_EACCESS` flag right in os/exec/lp_unix.go (first making sure that `AT_EACCESS` is defined for all unix platforms.",
      "parentUuid": "494972ed_9e31c563",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e2ee5c6_23d4fda7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 26451
      },
      "writtenOn": "2022-06-29T22:29:40Z",
      "side": 1,
      "message": "Alas, since neither `AT_FDCWD` nor `AT_EACCESS` are exported by syscall, it seems that the best way to implement it would be add `syscall.Eaccess` function.",
      "parentUuid": "c01a293f_53b71f35",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "841b7dc8_fe8f8a63",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-06-29T22:46:51Z",
      "side": 1,
      "message": "As the syscall package is frozen, we prefer to add new requirements of this sort to internal/syscall/unix.",
      "parentUuid": "4e2ee5c6_23d4fda7",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b390ae2a_5d3d9fc0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 26451
      },
      "writtenOn": "2022-06-30T16:43:46Z",
      "side": 1,
      "message": "\u003e As the syscall package is frozen, we prefer to add new requirements of this sort to internal/syscall/unix.\n\nAck, Eaccess goes to internal/syscall/unix.\n\nCan I still implement something similar to https://go-review.googlesource.com/c/sys/+/246537 in syscall or not?",
      "parentUuid": "841b7dc8_fe8f8a63",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2254d16_e5e1085f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-06-30T18:10:45Z",
      "side": 1,
      "message": "We don\u0027t want to introduce new API in the syscall package if we can reasonably avoid it.\n\nIt\u0027s fine to change syscall.Faccessat to call the faccessat2 system call if that seems useful.",
      "parentUuid": "b390ae2a_5d3d9fc0",
      "revId": "86937d424d39d74032f65b7cd7e27969bf7588d3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}