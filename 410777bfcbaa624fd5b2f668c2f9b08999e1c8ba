{
  "comments": [
    {
      "key": {
        "uuid": "54d45b65_70b4d885",
        "filename": "src/cmd/go/internal/modcmd/mod.go",
        "patchSetId": 4
      },
      "lineNbr": 296,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-07-19T17:26:39Z",
      "side": 1,
      "message": "modfetch.TrimGoSum doesn\u0027t write the updated file itself. A comment somewhere in here explaining when that happens would be helpful.",
      "revId": "410777bfcbaa624fd5b2f668c2f9b08999e1c8ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05ebd392_5dfba0b4",
        "filename": "src/cmd/go/internal/modcmd/mod.go",
        "patchSetId": 4
      },
      "lineNbr": 541,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-07-19T17:26:39Z",
      "side": 1,
      "message": "Unless I\u0027m missing an order-dependence, an explicit map here is more concise than the comment explaining the par.Work usage:\n\n\treqs :\u003d modload.Reqs()\n\tkeep :\u003d []module.Version{modload.Target}\n\tkept :\u003d map[module.Version]bool{ modload.Target: true }\n\tfor i :\u003d 0; i \u003c len(keep); i++ {\n\t\tlist, _ :\u003d reqs.Required(keep[i])\n\t\tfor _, r :\u003d range list {\n\t\t\tif !kept[r] {\n\t\t\t\tkeep \u003d append(keep, r)\n\t\t\t\tkept[r] \u003d true\n\t\t\t}\n\t\t}\n\t})\n\n\t// Assuming go.sum already has at least enough from the successful load,\n\t// we only have to tell modfetch what needs keeping.\n\tmodfetch.TrimGoSum(keep[1:])",
      "range": {
        "startLine": 540,
        "startChar": 0,
        "endLine": 541,
        "endChar": 39
      },
      "revId": "410777bfcbaa624fd5b2f668c2f9b08999e1c8ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73212f8a_47c32b0d",
        "filename": "src/cmd/go/internal/modfetch/fetch.go",
        "patchSetId": 4
      },
      "lineNbr": 326,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-07-19T17:26:39Z",
      "side": 1,
      "message": "This ties into the comment in the previous file. If we construct using a map instead of a slice, it seems we can throw away the slice rather than the map and avoid some redundant work.",
      "revId": "410777bfcbaa624fd5b2f668c2f9b08999e1c8ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}