{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ceb4493c_750baab8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 32637
      },
      "writtenOn": "2024-04-22T15:03:56Z",
      "side": 1,
      "message": "Would it be possible to provide benchmark numbers?",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d25d3d77_2f45b34d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 63983
      },
      "writtenOn": "2024-04-22T16:59:44Z",
      "side": 1,
      "message": "Came here to commment the same, it should be possible to use golang.org/x/perf/cmd/benchstat to compare and show the results at the end of the commit message.",
      "parentUuid": "ceb4493c_750baab8",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ed587480_5027548a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 3406889
      },
      "writtenOn": "2024-05-30T01:53:47Z",
      "side": 1,
      "message": "Yes, I have provided the benchmark numbers in latest commit message. Thank you!",
      "parentUuid": "d25d3d77_2f45b34d",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94d7f3f0_b6ee73dc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2024-04-22T09:20:59Z",
      "side": 1,
      "message": "I spotted some possible problems.\n\nThese findings are based on simple heuristics. If a finding appears wrong, briefly reply here saying so. Otherwise, please address any problems and update the GitHub PR. When complete, mark this comment as \u0027Done\u0027 and click the [blue \u0027Reply\u0027 button](https://go.dev/wiki/GerritBot#i-left-a-reply-to-a-comment-in-gerrit-but-no-one-but-me-can-see-it) above.\n\nPossible problems detected:\n  1. The first word in the commit title after the package should be a lowercase English word (usually a verb).\n  2. Lines in the commit message should be wrapped at ~76 characters unless needed for things like URLs or tables. You have a 211 character line.\n\nThe commit title and commit message body come from the GitHub PR title and description, and must be edited in the GitHub web interface (not via git). For instructions, see [here](https://go.dev/wiki/GerritBot/#how-does-gerritbot-determine-the-final-commit-message). For guidelines on commit messages for the Go project, see [here](https://go.dev/doc/contribute#commit_messages).\n\n\n(In general for Gerrit code reviews, the change author is expected to [log in to Gerrit](https://go-review.googlesource.com/login/) with a Gmail or other Google account and then close out each piece of feedback by marking it as \u0027Done\u0027 if implemented as suggested or otherwise reply to each review comment. See the [Review](https://go.dev/doc/contribute#review) section of the Contributing Guide for details.)",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "246172f6_6b43955f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 3406889
      },
      "writtenOn": "2024-05-30T01:53:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "94d7f3f0_b6ee73dc",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04569f73_94b65cbc",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-04-22T14:39:47Z",
      "side": 1,
      "message": "Maybe this needs a different name now, as it includes non-Bridge processors?",
      "range": {
        "startLine": 17,
        "startChar": 1,
        "endLine": 17,
        "endChar": 20
      },
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12862565_2d87f98e",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 3406889
      },
      "writtenOn": "2024-05-30T01:53:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "04569f73_94b65cbc",
      "range": {
        "startLine": 17,
        "startChar": 1,
        "endLine": 17,
        "endChar": 20
      },
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea8fd34a_9ddc61e7",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-04-22T14:39:47Z",
      "side": 1,
      "message": "How do we do this without having to update this list every time a new processor comes out? Is there a CPUID feature or something we could use?",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23e3ffa0_efe41c7b",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 16006
      },
      "writtenOn": "2024-04-22T14:49:30Z",
      "side": 1,
      "message": "That was my thought too. Can we instead check for FSRM:\"Fast Short REP MOVSB\" (if thats a good proxy for new cpus with fast rep mov) and prefer REP MOV for those newer CPUs that have FSRM set instead of letting this list grow into future?\n\nActually I would lean more towards removing this special casing altogether. Sandy and Ivy Bridge are quiet old and we should not care much to optimize their performance anymore. So as an option before adding more complexity: just remove this list altogether and remove the special casing for isIntelBridgeFamily.",
      "parentUuid": "ea8fd34a_9ddc61e7",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98b0f550_f5a6ae98",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 16006
      },
      "writtenOn": "2024-04-22T14:52:52Z",
      "side": 1,
      "message": "Actually two cleanup options:\n1) useAVXmemmove \u003d cpu.X86.HasAVX \u0026\u0026 !cpu.X86.HasFSRM (later needs a tiny bit of new internal/cpu code)\n2) remove useAVXmemmove altogether and always use rep mov for large copies.",
      "parentUuid": "23e3ffa0_efe41c7b",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "858a0b20_1df82a1d",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 5200
      },
      "writtenOn": "2024-04-22T15:28:30Z",
      "side": 1,
      "message": "I\u0027m also curious what the state of amd processors is.",
      "parentUuid": "98b0f550_f5a6ae98",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93b7252d_a8f2d437",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 16006
      },
      "writtenOn": "2024-04-22T15:49:46Z",
      "side": 1,
      "message": "Good point about amd. Given that newer AMDs also support AVX-512 actually not depending on AVX but instead letting the CPU microcode pick the fastest options might be better there too. I dont know if ERMS FSRM is a good proxy for newer AMD rep move either. The niceness of not having useAVXmemmove anymore would be too just give it into the hands of CPU implementors to optimize and not benchmark around them continously as we rarely have done recently.\n\nI think the linux kernel also mostly just uses rep move and not special cases for large copies these days:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id\u003dca96b162bfd21a5d55e3cd6099e4ee357a0eeb68\n\nThat could be a hint it should also be good enough for Go and we avoid manually tuning this by generations and AMD vs Intel.",
      "parentUuid": "858a0b20_1df82a1d",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08bc42d8_2576f79a",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 5400
      },
      "writtenOn": "2024-04-22T17:06:26Z",
      "side": 1,
      "message": "\u003e Can we instead check for FSRM:\"Fast Short REP MOVSB\" \n\nI believe looking at specific CPUID bits like this one is the right way to detect support.\n\n\u003e I think the linux kernel also mostly just uses rep move and not special cases for large copies these days:\n\nNote this is only for copies of data from userspace. Kernel is not generally doing lots of copies, and it\u0027s not doing lots of copies from userspace in particular. User copies are not expected to be large as well. Go program workloads may be very different in this respect.\nAnd note that kernel still uses other ways to copy in other cases:\nhttps://elixir.bootlin.com/linux/v6.9-rc5/source/arch/x86/lib/copy_page_64.S\nhttps://elixir.bootlin.com/linux/v6.9-rc5/source/arch/x86/lib/memcpy_64.S",
      "parentUuid": "93b7252d_a8f2d437",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e5b54c5_f54cc35d",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 16006
      },
      "writtenOn": "2024-04-22T17:33:48Z",
      "side": 1,
      "message": "Thanks for the pointers. I would assume kernel also wants to avoid globbering larger registers and thereby resorts to lots of movq instead of SSE or AVX. That said it seems to dispatch to rep mov also if FSRM set in https://elixir.bootlin.com/linux/v6.9-rc5/source/arch/x86/lib/memcpy_64.S#L33",
      "parentUuid": "08bc42d8_2576f79a",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a0000f26_1924b237",
        "filename": "src/runtime/cpuflags_amd64.go",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 3406889
      },
      "writtenOn": "2024-05-30T01:53:47Z",
      "side": 1,
      "message": "The FSRM (Fast Short REP MOVSB) enhancement applies to string lengths between 1 and 128 bytes long. A CPU supporting FSRM or ERMS does not always mean better performance with rep movsb.",
      "parentUuid": "6e5b54c5_f54cc35d",
      "revId": "d49514407921eb0754bda55d3aae8e71336c9fa2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}