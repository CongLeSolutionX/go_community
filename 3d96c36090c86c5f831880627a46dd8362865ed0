{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "21434f83_372373b1",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1608,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-09T17:16:51Z",
      "side": 1,
      "message": "This rule needs a size restriction also, right?",
      "range": {
        "startLine": 1608,
        "startChar": 45,
        "endLine": 1608,
        "endChar": 47
      },
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "784e415f_4ff71454",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1608,
      "author": {
        "id": 53189
      },
      "writtenOn": "2021-10-11T06:58:20Z",
      "side": 1,
      "message": "I\u0027m not sure whether it\u0027s necessary because the rules about RORW and RORWconst already check the size of y.\n\nYou can check the rules about RORW and RORWconst.\n\nIf it\u0027s necessary I will add it in the next patch, thank you~",
      "parentUuid": "21434f83_372373b1",
      "range": {
        "startLine": 1608,
        "startChar": 45,
        "endLine": 1608,
        "endChar": 47
      },
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "350e2209_032fe7a4",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1673,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-09T17:16:51Z",
      "side": 1,
      "message": "I\u0027ma bit worried about these rules. They don\u0027t generate the right top 32 bits.\n\nNormally, we expect that users of these ops will not use the top 32 bits. But I can imagine situations where they would.\n\nFor instance, can we have this rule?\n\n(MOVDstore ptr (MOVWUreg x:(ORWshiftRO ...)) mem) -\u003e (MOVDstore ptr x mem)\n\nIt seems to be ok, because ORW zeroes the top 32 bits already, so the MOVWUreg is unnecessary. But then we\u0027re depending on the top bits of ORWshiftRO.\n\nSo I think we need to decide how we interpret *W operations. One way is to say *W operations always zero the top 32 bits (which they do, right?), in which case the rule I just described works, and some of the rules in this CL don\u0027t. The other way is to say *W operations leave the top 32 bits undefined, in which case the rule I described doesn\u0027t work, and the rules in this CL do.\n\nWe do assert that when 4-byte types are stored in a register, the top bytes are junk. So we at least need a type size restriction in these rules.\n\nMy rule would really have to be:\n\n(MOVDstore ptr (MOVWUreg x:(ORWshiftRO \u003ct\u003e ...)) mem) \u0026\u0026 t.Size() \u003d\u003d 8 -\u003e (MOVDstore ptr x mem)\n\nor just perhaps:\n\n(MOVWUreg (ORWshiftRO ...)) -\u003e (ORWshiftRO \u003cuint64\u003e ...)\n\nTo ensure that the ORWshiftRO was generating all 8 bytes. But I worry that might be error-prone.\n\n(I think this is a general problem across architectures for sub-word operations, not just arm64 and not just this CL.)",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96133a34_5d6a49e2",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1673,
      "author": {
        "id": 53189
      },
      "writtenOn": "2021-10-11T06:58:20Z",
      "side": 1,
      "message": "At first, the ORRW will do the operation between two 32-bit values(by using 32-bit form registers w*, which is a half of x*) with the top 32-bit cleared and generate a 32-bit value in the arm64. For example, if we have an assemble code like:\n\n\u0027orr     w0, w1, w2\u0027\n\nIn this case, the top 32-bit of x0,x1,x2 will be cleared.\n\nSo I think the question here is the size of \u0027x\u0027 and the const.\n\nI notice that MOVDconst will be always a 64-bit value, so the rules will be wrong if c has values in the top 32-bit.\n\nIf we can have some ops like MOVWconst(32-bit const), it can be solved by replacing MOVDconst with MOVWconst and adding a value check of x.\nOr I can just remove these rules for now until we really need it.",
      "parentUuid": "350e2209_032fe7a4",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1241da3_5aa58407",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1673,
      "author": {
        "id": 24534
      },
      "writtenOn": "2021-10-12T04:46:55Z",
      "side": 1,
      "message": "\u003e So I think we need to decide how we interpret *W operations. One way is to say *W \u003e operations always zero the top 32 bits (which they do, right?)\n\u003e\nI am inclined to this interpretation. Because it is consistent with the instruction behavior of the arm architecture, we can simply translate the *W operations into the 32-bit format arm instruction (this\u0027s what we\u0027re doing now). If we use the second interpretation, the *W operation can also be code generated into 64-bit arm instruction. Then when generating a 32-bit return value, we have to deal with the upper 32 bits of the return value properly.",
      "parentUuid": "96133a34_5d6a49e2",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff2ddf5f_4e8606d5",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1689,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-09T17:16:51Z",
      "side": 1,
      "message": "This should be TSTW?",
      "range": {
        "startLine": 1689,
        "startChar": 40,
        "endLine": 1689,
        "endChar": 43
      },
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0faf46b6_aa62bdfb",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1689,
      "author": {
        "id": 53189
      },
      "writtenOn": "2021-10-11T06:58:20Z",
      "side": 1,
      "message": "Yes, I will update in the next patch.\n\nThank you~",
      "parentUuid": "ff2ddf5f_4e8606d5",
      "range": {
        "startLine": 1689,
        "startChar": 40,
        "endLine": 1689,
        "endChar": 43
      },
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39152a38_541321e2",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1746,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-09T17:16:51Z",
      "side": 1,
      "message": "TSTW",
      "range": {
        "startLine": 1746,
        "startChar": 40,
        "endLine": 1746,
        "endChar": 43
      },
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60e3cea1_30fabb39",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64.rules",
        "patchSetId": 2
      },
      "lineNbr": 1756,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-09T17:16:51Z",
      "side": 1,
      "message": "This is the kind of difficulty you get into with making the semantics of the operations dependent on the types. If we said that *W ops with 32-bit type leave the upper 32 bits undefined, but *W ops with 64-bit type zero the upper 32 bits, then this rule doesn\u0027t work. If the outer ANDW is 64-bit, but the inner RORW is 32-bit, then we can\u0027t just have y as a result, we need (MOVWUreg y).",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "908f4787_1a07cca8",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64Ops.go",
        "patchSetId": 2
      },
      "lineNbr": 304,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-09T17:16:51Z",
      "side": 1,
      "message": "It seems weird to me that we have W versions of RO, but no W versions of LL/RL/RA.\n(There doesn\u0027t really need to be a W version of LL, because the non-W version of LL computes the same low 32 bits, but that\u0027s not the case for RL and RA.)\n\nIs there a specific application that these rules would speed up? If so, then maybe we can go forward with this CL. But I\u0027d rather not unless we decide that speeding up uint32 operations on a 64-bit machine is worth it. In that case, we should do all of them, and figure out the right way to think about the upper 32 bits.",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15a9ca32_3103307e",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64Ops.go",
        "patchSetId": 2
      },
      "lineNbr": 304,
      "author": {
        "id": 53189
      },
      "writtenOn": "2021-10-11T14:56:15Z",
      "side": 1,
      "message": "For RL and RA, we can zero extend or sign extend the value to make sure they do the same behavior for 32/64 bit value. But for ROR and RORW, we can not achieve this consistency between 64-bit and 32-bit forms. So we need RORW here.\n\nI think maybe the code I motioned in the commit message is a good case for \u0027the application that these rules can speed up\u0027, right? 😂",
      "parentUuid": "908f4787_1a07cca8",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "187247f2_162abdd8",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64Ops.go",
        "patchSetId": 2
      },
      "lineNbr": 304,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-11T18:48:59Z",
      "side": 1,
      "message": "I guess my question is - did this performance issue come up in a program someone was writing for some other task, or did it only come up because you wrote a piece of code to deliberately demonstrate the problem?",
      "parentUuid": "15a9ca32_3103307e",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d9f5185_64cc8e89",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64Ops.go",
        "patchSetId": 2
      },
      "lineNbr": 304,
      "author": {
        "id": 53189
      },
      "writtenOn": "2021-10-12T01:27:23Z",
      "side": 1,
      "message": "I haven\u0027t found a specific program that can speed up yet, I find this issue when I try to fix the #48002.",
      "parentUuid": "187247f2_162abdd8",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e82cf0d_58062e55",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64Ops.go",
        "patchSetId": 2
      },
      "lineNbr": 304,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-10-12T16:36:38Z",
      "side": 1,
      "message": "I propose we drop this then. I don\u0027t think it is worth the complexity if we don\u0027t have an actual program that it helps.\nI would imagine most people using things like bits.RotateLeft* that care about performance are going to want to do things at native word size.",
      "parentUuid": "7d9f5185_64cc8e89",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8031ea4_c6bd63d9",
        "filename": "src/cmd/compile/internal/ssa/gen/ARM64Ops.go",
        "patchSetId": 2
      },
      "lineNbr": 304,
      "author": {
        "id": 53189
      },
      "writtenOn": "2021-10-19T01:29:12Z",
      "side": 1,
      "message": "Ok, I decide to abandon this patch.\n\nThanks for your comments.",
      "parentUuid": "6e82cf0d_58062e55",
      "revId": "3d96c36090c86c5f831880627a46dd8362865ed0",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}