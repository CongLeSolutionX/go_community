{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f4101f1f_02282200",
        "filename": "src/unicode/utf8/utf8.go",
        "patchSetId": 8
      },
      "lineNbr": 357,
      "author": {
        "id": 36654
      },
      "writtenOn": "2024-06-26T01:49:12Z",
      "side": 1,
      "message": "This version reduces the time for valid 3 byte runes by ~12%, but increases the time for 4 byte runes by ~3%. This is persistently observed. I tried my best to understand why is this happening but can\u0027t give a sensible answer.\n\nIMO, the 3% penalty seems very small, but I want to highlight that I tried another alternative which also inlines the ASCII path and has no visible impact on the valid 4 byte runes case, but has a considerably smaller improvement on the byte runes case. Adding the results of the other case here as a comment, please let me know if it would be better to use the more conservative alternative.\n\n```\ngoos: linux\ngoarch: amd64\npkg: unicode/utf8\ncpu: 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\n                              │ baseline.test-encode.txt │   encode-rune-two-invalid.test.txt   │\n                              │          sec/op          │    sec/op     vs base                │\nEncodeASCIIRune-8                           1.0950n ± 1%   0.2140n ± 0%  -80.46% (p\u003d0.000 n\u003d20)\nEncodeSpanishRune-8                          1.499n ± 0%    1.435n ± 2%   -4.27% (p\u003d0.000 n\u003d20)\nEncodeJapaneseRune-8                         1.960n ± 2%    1.904n ± 1%   -2.81% (p\u003d0.000 n\u003d20)\nEncodeMaxRune-8                              2.145n ± 2%    2.150n ± 2%        ~ (p\u003d0.064 n\u003d20)\nEncodeInvalidRuneMaxPlusOne-8                1.955n ± 2%    1.781n ± 2%   -8.93% (p\u003d0.000 n\u003d20)\nEncodeInvalidRuneSurrogate-8                 1.946n ± 3%    1.419n ± 1%  -27.06% (p\u003d0.000 n\u003d20)\nEncodeInvalidRuneNegative-8                  1.968n ± 2%    1.782n ± 1%   -9.48% (p\u003d0.000 n\u003d20)\ngeomean                                      1.757n         1.281n       -27.08%\n```",
      "revId": "d617874562a0a732721f03f4cd3f88787cdb9273",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1dfaa47e_8e34a9ad",
        "filename": "src/unicode/utf8/utf8.go",
        "patchSetId": 8
      },
      "lineNbr": 357,
      "author": {
        "id": 36654
      },
      "writtenOn": "2024-06-26T01:53:48Z",
      "side": 1,
      "message": "Sorry, I think my last comment is not very clear. The above results are for an alternative I tried with no penalty to the 4 bytes cases but much lower improvement to the 3 bytes case.\n\nThat alternative is using two invalid branch cases, one before the 3 bytes case only for the surrogate range, and another as a default after the 4 bytes case.",
      "parentUuid": "f4101f1f_02282200",
      "revId": "d617874562a0a732721f03f4cd3f88787cdb9273",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71ec9cae_9753d106",
        "filename": "src/unicode/utf8/utf8.go",
        "patchSetId": 8
      },
      "lineNbr": 357,
      "author": {
        "id": 36654
      },
      "writtenOn": "2024-06-26T02:34:45Z",
      "side": 1,
      "message": "Ok, I know why it is actually: apparently when the compiler sees an OR in a switch case it generates a few more jumps, what I didn\u0027t know is how to circumvent that. What I have just tried is using the silly `a OR b \u003d !(a AND b)`, and it works better. The 3 bytes case gets an ~8% improvement instead of ~12%, and the 4 bytes case receives no penalty (unchanged from the original).\n\nThe bad thing is that it looks much uglier, diff:\n```\n-       case i \u003c surrogateMin, surrogateMax \u003c i \u0026\u0026 i \u003c\u003d rune3Max:\n+       case !(surrogateMin \u003c\u003d i \u0026\u0026 (i \u003c\u003d surrogateMax || rune3Max \u003c i)):\n```\n\nThis prevents the compiler from adding those extra jumps for the 4 bytes case, but it adds an odd and redundant jump for the 3 bytes case:\n\n\n```\n        CMPL    DI, $55296\n        JCS     command-line-arguments_encodeRuneNonASCII_pc199 \u003c- one of the 3 byte cases\n        LEAL    -57344(DI), DX\n        CMPL    DX, $8191\n        JLS     command-line-arguments_encodeRuneNonASCII_pc199 \u003c- the other the 3 byte case\n        LEAL    -65536(DI), DX\n        NOP\n        CMPL    DX, $1048575\n        JHI     command-line-arguments_encodeRuneNonASCII_pc173 \u003c- the default case\n        ... the 4 bytes branch code\n        ... the default case\n        ... the 3 bytes branch code ¯\\_(ツ)_/¯\n        \n```\n\nAnyway, that\u0027s my best shot.",
      "parentUuid": "1dfaa47e_8e34a9ad",
      "revId": "d617874562a0a732721f03f4cd3f88787cdb9273",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "531f7e55_d3540cae",
        "filename": "src/unicode/utf8/utf8.go",
        "patchSetId": 8
      },
      "lineNbr": 357,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-06-26T03:52:13Z",
      "side": 1,
      "message": "We should not complicate the code for the compiler.  The compiler will change.  And the measurements here are tiny.  Readability and maintainability are more important.  If you think the compiler is generating clearly bad code, open an issue against the compiler.",
      "parentUuid": "71ec9cae_9753d106",
      "revId": "d617874562a0a732721f03f4cd3f88787cdb9273",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}