{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "51678518_0ceea008",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-15T02:04:05Z",
      "side": 1,
      "message": "Adding Cherry for the cmd/link change.  I\u0027m not clear on why we have a condition that checks beforehand whether a relocation is unhandled, and then assumes that we do in fact handle the relocation.  Why not report an error if the relocation really is unhandled?  I\u0027m sure it\u0027s fine but would appreciate a look.  Thanks.",
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e196e34_9117bc90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-09-17T15:34:35Z",
      "side": 1,
      "message": "I think that code is to catch unhandled SDYNIMPORT relocations which should have been rewritten in an early stage (dynrelocsym). The ones allowed here should be handled in the switch statement below, or the architecture-specific code called from it.\n\nI agree that this looks confusing. It may be better to just remove this and check for the unhandled SDYNIMPORT relocations in the cases below. For now, the change here is okay (assuming we actually want to do it this way).",
      "parentUuid": "51678518_0ceea008",
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2847e64_6645f916",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 3617945
      },
      "writtenOn": "2024-09-20T02:36:17Z",
      "side": 1,
      "message": "Abandoned\n\nAbandoning in favor of CL 614277.",
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f9dae37_ae4d2cb0",
        "filename": "src/internal/syscall/unix/version_android.go",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-09-17T15:34:35Z",
      "side": 1,
      "message": "I\u0027m concerned with calling libc functions this way. If libc is used one place in the program, it essentially requires using libc in a variety of places. The pure Go implementation may not work reliably anymore. (It might happen to work in some cases, but I don\u0027t think that\u0027s a good approach.)\n\nUsually Go binaries on Android are cgo binaries anyway, so it should be fine. But that is probably not the case for all binaries, e.g. some bootstrap binaries may be pure Go.\n\nCan we may this just a regular cgo call, which will be used when the binary is indeed a cgo binary? That should cover the majority of cases. For pure Go binaries we could just assume pidfd doesn\u0027t work.",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 49,
        "endChar": 82
      },
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00b7f0e6_6d1002fd",
        "filename": "src/internal/syscall/unix/version_android.go",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 3617945
      },
      "writtenOn": "2024-09-18T10:50:54Z",
      "side": 1,
      "message": "I chose this approach because I want it to work even if cgo is disabled, and it seems that the cgo-based approach doesn\u0027t work for the Go toolchain itself.\n\nI understand that this adds a dependency on libc.so, but since Android mandates PIE, we depend on the dynamic linker anyway. So depending also on libc.so is not a big problem, I think.",
      "parentUuid": "2f9dae37_ae4d2cb0",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 49,
        "endChar": 82
      },
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f37c1da6_53e8d7e8",
        "filename": "src/internal/syscall/unix/version_android.go",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-09-18T15:56:30Z",
      "side": 1,
      "message": "It\u0027s not just the dependency of libc.so. Once libc is involved, it may affect things like thread-local storage, thread creation, signals, etc. On other platforms, e.g. Darwin, we use libc for not just syscalls, but also thread creation, managing TLS, etc.. I don\u0027t say this couldn\u0027t work, but it is certainly an unexplored territory.\n\nI think it is okay to say for pure-Go binaries like the toolchain, just don\u0027t use pidfd. And we only consider this for the cgo case.\n\nOr, is there any other way to check the version? Like, parsing auxv or some sysctl?\n\nAlso, does CL 592078 or something along the line help? We can test if pidfd actually works before using it.",
      "parentUuid": "00b7f0e6_6d1002fd",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 49,
        "endChar": 82
      },
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fd90722_8d7e70c2",
        "filename": "src/internal/syscall/unix/version_android.go",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-09-18T16:13:31Z",
      "side": 1,
      "message": "Testing pidfd is annoying, because on old versions Android calling the pidfd system call causes the process to get a SIGSYS signal.  That said, perhaps we could find out what happens if we explicitly ignore SIGSYS and then call pidfd.  Would it return ENOSYS in that case?  That might be a simpler fix, and wouldn\u0027t require knowing the android version.",
      "parentUuid": "f37c1da6_53e8d7e8",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 49,
        "endChar": 82
      },
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "655c5f26_b85d6f3c",
        "filename": "src/internal/syscall/unix/version_android.go",
        "patchSetId": 7
      },
      "lineNbr": 49,
      "author": {
        "id": 3617945
      },
      "writtenOn": "2024-09-20T02:36:17Z",
      "side": 1,
      "message": "I thought ignoring signal would need more effort as Go has no functionality to ignore signals temporarily.\nAfter reading your comment, I found that it can be implemented easily by modifying sighandler. Thanks.",
      "parentUuid": "5fd90722_8d7e70c2",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 49,
        "endChar": 82
      },
      "revId": "d771f8e26735c4eb13f68ea8fa8c0294ca3a84ba",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}