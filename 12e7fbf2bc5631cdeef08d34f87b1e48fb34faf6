{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "21089a6e_b8115dac",
        "filename": "src/runtime/defs_linux_amd64.go",
        "patchSetId": 3
      },
      "lineNbr": 145,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-09T14:50:17Z",
      "side": 1,
      "message": "Is this the correct field ordering? Looking at the man pages it seems like the value and notify fields need to be swapped?\n\nhttps://man7.org/linux/man-pages/man7/sigevent.7.html",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "61ed14f8_1c227cca",
        "filename": "src/runtime/defs_linux_amd64.go",
        "patchSetId": 3
      },
      "lineNbr": 145,
      "author": {
        "id": 9210
      },
      "writtenOn": "2021-06-09T16:20:38Z",
      "side": 1,
      "message": "I think the ordering is correct. The kernel source shows an order of sigev_value, sigev_signo, sigev_notify, followed by a union (where one option is \"int _tid\") https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/siginfo.h#L323 , and \"go tool cgo -godefs defs_linux.go\" (with CPATH set to the Linux kernel\u0027s ./arch/x86/include/uapi, ./include/uapi, ./include) writes out the following struct for 64-bit architectures:\n\n  type Sigevent struct {\n  \tValue\t\t[8]byte\n  \tSigno\t\tint32\n  \tNotify\t\tint32\n  \tX_sigev_un\t[48]byte\n  }\n\nOn 32-bit architectures, Value is [4]byte and X_sigev_un is [52]byte, so I turned Value into a uintptr.",
      "parentUuid": "21089a6e_b8115dac",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a53fb484_031be6ec",
        "filename": "src/runtime/defs_linux_amd64.go",
        "patchSetId": 3
      },
      "lineNbr": 145,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-15T09:44:05Z",
      "side": 1,
      "message": "You\u0027re right. I didn\u0027t expect the man pages to use different field ordering.",
      "parentUuid": "61ed14f8_1c227cca",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0605a05b_083bfe23",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-09T14:50:17Z",
      "side": 1,
      "message": "What\u0027s the idea behind incrementing/decrementing the id?",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "686aa120_18794985",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 9210
      },
      "writtenOn": "2021-06-09T16:20:38Z",
      "side": 1,
      "message": "The first timer the process creates has an id of 0, so we need a way to tell whether this value is set. I changed the mechanism in PS4, so it uses an int64 now with a couple of explicit flags.",
      "parentUuid": "0605a05b_083bfe23",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f20f8558_a94dc13a",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-15T09:44:05Z",
      "side": 1,
      "message": "Thanks for explaining.",
      "parentUuid": "686aa120_18794985",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f21d9a1c_ad94372f",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1423,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-09T14:50:17Z",
      "side": 1,
      "message": "Why is setcpuprofilerate(0) needed here? Shouldn\u0027t this be a fresh thread by definition?",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "527d695c_4b0f47bb",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1423,
      "author": {
        "id": 9210
      },
      "writtenOn": "2021-06-09T16:20:38Z",
      "side": 1,
      "message": "This is another thing that changed between PS3 and PS4. This call turns per-thread profiling off for every thread in the process so the next line can turn it on for every thread (including this new one).\n\nPS4 includes significant changes to how that works: it\u0027s structured as a per-thread profiler rather than a process-wide profiler, and the work to enable/disable happens during runtime·execute.",
      "parentUuid": "f21d9a1c_ad94372f",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f40e4bf2_7bccf4c1",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1423,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-15T09:44:05Z",
      "side": 1,
      "message": "Got it, thanks for explaining!",
      "parentUuid": "527d695c_4b0f47bb",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07d326ae_ee7762ef",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-09T14:50:17Z",
      "side": 1,
      "message": "Is this supposed to ignore setitimer() signals if timer_create() is used? If yes, why would this currently happen? My understanding of the patch is that setitimer() and timer_create() are implemented in mutually exclusive ways in the current iteration?",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac75f6f1_9d1ead8f",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 9210
      },
      "writtenOn": "2021-06-09T16:20:38Z",
      "side": 1,
      "message": "Yes, I intend this to ignore setitimer signals if the M has its own timer via timer_create.\n\nIn the context of PS4, I believe I know one way it would happen and I suspect another.\n\nFirst, per-thread profiling starts (in PS4) inside runtime·execute. An M can run a G for several milliseconds at a time, and so may be in the middle of running a G when another goroutine asks to enable profiling. (There may be dozens of Ms like this, using tens of milliseconds of CPU in total.) Until the M stops running that goroutine, it won\u0027t have a per-thread timer because it hasn\u0027t yet called runtime·execute (in PS4). Until then, the only timer tracking its CPU spend is the process-wide setitimer, and I think it\u0027s right for the profiler to record any SIGPROF delivered to that thread that arrives before the thread calls timer_create.\n\nThe other is cgo, or threads that are in the process but not completely known to the Go runtime. I\u0027m not sure what the details of this one look like. Do threads in the process that aren\u0027t-quite-known to the Go runtime run this same signal handler code? I suppose this must be only for somewhat-known-to-Go threads, since getg().m doesn\u0027t panic/fault. But again, what\u0027s on my mind is threads that are busy for a while and miss the cue to call timer_create.\n\nAnd, if there is to be a way to control whether the program uses timer_create (I set up a new GODEBUG flag for my own convenience, but maybe it stays?), then this is a way to allow either mechanism to work.\n\nWhat do you think about those cases and how to address them?",
      "parentUuid": "07d326ae_ee7762ef",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a90df8e_0715028e",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 50449
      },
      "writtenOn": "2021-06-15T09:44:05Z",
      "side": 1,
      "message": "\u003e and I think it\u0027s right for the profiler to record any SIGPROF delivered to that thread that arrives before the thread calls timer_create.\n\nThat could work, but I don\u0027t like mixing samples from two different sources into a single profile if one source is known to be bad/biased.\n\nDid you consider to just force-preempt all goroutines in order to setup their `timer_create()` timers?\n\n\u003e Do threads in the process that aren\u0027t-quite-known to the Go runtime run this same signal handler code?\n\nNo. I think we only end up in `sighandler()` via `sigtrampgo()` if `g !\u003d nil`.\n\nThat being said, for cgo calls we could end up in `sigprofNonGo()` which probably needs the same `ignoreItimerSIGPROF` checks as implemented here. The problem is that the `siginfo` context isn\u0027t propagated to `sigprofNonGo()` right now.\n\nPerhaps the most useful thing I can provide for this round of review is some visualization of the relevant control flows for this patch: https://gist.github.com/felixge/4ab9f56097ea99d2edd72b6d31b450f7\n\nAt least it\u0027s been very helpful for my own understanding.",
      "parentUuid": "ac75f6f1_9d1ead8f",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fecf0c19_5f0d7c8b",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 9210
      },
      "writtenOn": "2021-07-17T23:09:11Z",
      "side": 1,
      "message": "\u003e Did you consider to just force-preempt all goroutines in order to setup their `timer_create()` timers?\nI didn\u0027t consider that. It could work for threads running Go code; any threads in C code would do the setup when they\u0027re ready. It would be disruptive in a way that profiling isn\u0027t currently disruptive ... is there a sufficiently light-weight option for that? The runtime overhead and the implementation complexity are unknown to me, and I estimated the benefit it would provide as relatively low.\n\n\u003e for cgo calls ... probably needs the same ... checks\nI added the checks to some of the cgo call paths. What\u0027s missing are platforms that provide runtime.SetCgoTraceback, when that feature is in use (for `sigprofNonGo`). That needs assembly.\n\n\u003e Perhaps the most useful thing I can provide for this round of review is some visualization of the relevant control flows for this patch.\nThis has been very helpful. Thank you!",
      "parentUuid": "1a90df8e_0715028e",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f1e4ae2_8dddd77e",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 12120
      },
      "writtenOn": "2021-09-20T18:33:06Z",
      "side": 1,
      "message": "I believe this is resolved.",
      "parentUuid": "fecf0c19_5f0d7c8b",
      "revId": "12e7fbf2bc5631cdeef08d34f87b1e48fb34faf6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}