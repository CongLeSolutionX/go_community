{
  "comments": [
    {
      "key": {
        "uuid": "49fc33c5_9e586d72",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5206
      },
      "writtenOn": "2015-09-22T03:15:42Z",
      "side": 1,
      "message": "I don\u0027t really like tests like this.  The spec doesn\u0027t say that the compiler must implement an exponent of exactly 32 bits.  It says that it must implement an exponent of at least 32 bits.  When you write a test like this ERROR \"constant too large\" in the testsuite gccgo has to either change to implement the exact floating point format as gc, or it has to skip this test.  Neither is desirable.",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c9ef43fe_b31ec29c",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5400
      },
      "writtenOn": "2015-09-22T05:34:05Z",
      "side": 1,
      "message": "Why is not changing gccgo desirable?\nIf the compilers match in such implementation details:\n- we can have tests like this\n- users have less surprises when switching compilers\n- we can do more randomized testing\nIs there a single reason to have different implementation details in our compilers?",
      "parentUuid": "49fc33c5_9e586d72",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "49fc33c5_2b101a85",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5210
      },
      "writtenOn": "2015-09-22T16:39:50Z",
      "side": 1,
      "message": "I tend to agree with @iant.\n\nThe spec sets minimal criteria for the implementation. It\u0027s unfortunate for testing, but it doesn\u0027t make sense to de-facto hardwire implementation restrictions via tests.\n\nSee: https://go-review.googlesource.com/14837",
      "parentUuid": "c9ef43fe_b31ec29c",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c98bc36e_ea6a2bb6",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5206
      },
      "writtenOn": "2015-09-22T17:48:00Z",
      "side": 1,
      "message": "The Go language is defined by a spec, not by an implementation.  Multiple compilers are not simply copies of each other; they each implement the spec.  Where we want the compilers to behave exactly the same, we should write the spec to say so.  Where it is OK for the compilers to differ, the spec should permit that.\n\nIf you want a test of this sort to pass for all compilers, you should propose a change to the spec.  We can discuss it in that context.",
      "parentUuid": "c9ef43fe_b31ec29c",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a9612fbd_d7b79c0d",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5400
      },
      "writtenOn": "2015-09-23T07:18:56Z",
      "side": 1,
      "message": "I don\u0027t question that both compilers are correct as per spec. What I am saying is that I see more value in keeping implementation behaving the same way unless there are serious reasons to diverge (e.g. 32-bit and 64-bit compilers probably want different size of int).\nIf there are reasons to choose a particular implementation restriction in one compiler, why do not they apply to the other?\nOf it if the restrictions were chosen by a fair dice roll and are not particularly important, why not align them and be able to have tests that can detect changes in behavior? (and be able to run randomized tests)\nOr if we absolutely don\u0027t want users to depend on a particular implementation detail (like map iteration order), differences in various compilers are not enough for that (most people use only one), and we need to take measures within a single compiler.\n\nOr put it another way, assuming that all compilers behave the same today, would there be any reasons to make them behave differently?",
      "parentUuid": "c98bc36e_ea6a2bb6",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e90b27d5_f9d0f734",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5400
      },
      "writtenOn": "2015-09-23T07:36:42Z",
      "side": 1,
      "message": "Well, I guess that what I am saying implies that we should change the spec. I just don\u0027t know whether it is feasible at this point or not.",
      "parentUuid": "a9612fbd_d7b79c0d",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a9ba0f35_12fe6ad7",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5210
      },
      "writtenOn": "2015-09-23T16:14:37Z",
      "side": 1,
      "message": "It\u0027s going to be difficult to justify that all implementations should essentially implement their constant arithmetic the same way. It would also make the spec unnecessarily complex for something that rarely matters in practice.\n\nThe whole point of how Go constants work is that as a programmer one doesn\u0027t have to worry about them (bounds, ranges, precision, etc.). And I claim that is indeed true for 99.999% of all realistic code.",
      "parentUuid": "e90b27d5_f9d0f734",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a9ba0f35_d5f4cc93",
        "filename": "test/fixedbugs/issue11326.go",
        "patchSetId": 6
      },
      "lineNbr": 13,
      "author": {
        "id": 5206
      },
      "writtenOn": "2015-09-23T17:15:48Z",
      "side": 1,
      "message": "The implementations of untyped floating point constants are completely different in gc and gccgo.  There is no shared code whatsoever; there isn\u0027t even a shared approach to the problem.  Requiring these two different code bases to work precisely identically is something that belongs in the spec, if it belongs anywhere.",
      "parentUuid": "a9612fbd_d7b79c0d",
      "revId": "c396c047c68ce59c67d1ee6d1f6756642b223bae",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}