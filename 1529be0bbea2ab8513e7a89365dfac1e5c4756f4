{
  "comments": [
    {
      "key": {
        "uuid": "0efc1c7c_0cd9b7a2",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 748,
      "author": {
        "id": 5186
      },
      "writtenOn": "2016-04-04T17:29:25Z",
      "side": 1,
      "message": "I don\u0027t understand why procyield takes a spin count and how/why we use 10. I would have expected that the spin loop would call PAUSE once each time around a loop that checks if the target of the CAS has changed.\n\nfor !atomic.Cas(\u0026gp.atomicstatus, oldval, newval) {\n    for i:\u003d0; i\u003cloopCount; i++ {\n         PAUSE\n         if gp.atomicstatus \u003d\u003d oldval {\n              break;\n         }\n     }\n}",
      "revId": "1529be0bbea2ab8513e7a89365dfac1e5c4756f4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2eaac053_45596a0a",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 748,
      "author": {
        "id": 5400
      },
      "writtenOn": "2016-04-04T17:38:02Z",
      "side": 1,
      "message": "Procyield takes count to provide more relaxation.\nIf we execute a single PAUSE instruction per loop iteration, it will be a single PAUSE instruction per 2 function calls and several dozens of real instructions. I.e. no relaxation for the HT sibling.\nSince we are talking about tens of microseconds, 10 PAUSE instructions don\u0027t visibly affect latency.\n10 is chosen by a fair dice roll.",
      "parentUuid": "0efc1c7c_0cd9b7a2",
      "revId": "1529be0bbea2ab8513e7a89365dfac1e5c4756f4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0efc1c7c_acca2388",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 748,
      "author": {
        "id": 5186
      },
      "writtenOn": "2016-04-04T20:40:29Z",
      "side": 1,
      "message": "What I am proposing is that instead of a procyield(10) which is\nfor i:\u003d0; i\u003c10; i++ {\n     PAUSE\n}\nwe do the following:\nfor i:\u003d0; i\u003c10; i++ {\n     PAUSE\n     if gp.atomicstatus \u003d\u003d oldval {\n          break;\n     }\n}\n\nThe later seems to be the use case that Intel uses when it talks about PAUSE so I suspect that is what their HW is optimized for.",
      "parentUuid": "2eaac053_45596a0a",
      "revId": "1529be0bbea2ab8513e7a89365dfac1e5c4756f4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ec48060_78663df6",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 748,
      "author": {
        "id": 5400
      },
      "writtenOn": "2016-04-05T07:55:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0efc1c7c_acca2388",
      "revId": "1529be0bbea2ab8513e7a89365dfac1e5c4756f4",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}