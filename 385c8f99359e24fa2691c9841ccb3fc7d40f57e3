{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ef1b45f3_a9f4c6af",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-21T17:35:10Z",
      "side": 1,
      "message": "I think there isn\u0027t an order that is more \"correct\" than the other. Does \"BGT X1, X2\" mean taking the jump when X1\u003eX2, or when X2\u003eX1? I can see both are reasonable. As long as we stick to one convention consistently, I think that is fine.\n\nI don\u0027t think this CL would work without changing the compiler and all assembly code.",
      "range": {
        "startLine": 10,
        "startChar": 5,
        "endLine": 10,
        "endChar": 38
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee8f636e_930f3230",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 35100
      },
      "writtenOn": "2020-11-22T01:13:31Z",
      "side": 1,
      "message": "Thanks for your review.  Maybe both directions are reasonable, but what about the consistency?\n\nJust for instance, using the current implementation of the mentioned 4 types of pseudo branches, BLE X5, X6 generates \"if X6 is less or equal to X5\" while BLT X5, X6 generates \"if X5 is less than X6.\"  It is obviously not consistent.  \n\nThe tests in  CL 226397 are like\n```\n{\"BLE\", 1, 0, testBLE, false},\n{\"BLE\", -1, 0, testBLE, true},\n```\nGiven the former operand being a and the later operand being b, these examines if b is less or equal to a. Isn\u0027t it counter-intuitive?  \n\nSo my patch revert the order of a and b in the obj tests, and p.Reg ad p.From.Reg in the assembler.",
      "parentUuid": "ef1b45f3_a9f4c6af",
      "range": {
        "startLine": 10,
        "startChar": 5,
        "endLine": 10,
        "endChar": 38
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2941ada2_89f8c008",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-22T01:31:39Z",
      "side": 1,
      "message": "Thanks for the explanation. If it is not consistent, it is bad and I agree we should fix that. The CL description could be made clearer, pointing out the inconsistency.\n\nIs there anything that needs to be fixed in the assembly code and in the compiler?",
      "parentUuid": "ee8f636e_930f3230",
      "range": {
        "startLine": 10,
        "startChar": 5,
        "endLine": 10,
        "endChar": 38
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1348fcf3_5e0dc99c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 35100
      },
      "writtenOn": "2020-11-22T01:48:28Z",
      "side": 1,
      "message": "\u003e could be made clearer, pointing out the inconsistency.\n\nWhat about\n```\nPseudo branch instructions BGT, BGTU, BLT, and BLTU implemented In CL 226397 were translated inconsistently compared to other ones due to the inversion of registers.  This CL fixes the translation in the assembler and the tests.\n```\n\n\u003e Is there anything that needs to be fixed in the assembly code and in the compiler?\n\n`find src/runtime -name \u0027*riscv*.s\u0027 | xargs egrep \"BGT|BGTU|BLE|BLEU\"` returns nothing.  This is the reason why this bug has not been reported.  Also, this is purely an assembler issue.",
      "parentUuid": "2941ada2_89f8c008",
      "range": {
        "startLine": 10,
        "startChar": 5,
        "endLine": 10,
        "endChar": 38
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b20a58c1_7f0366c5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-22T02:06:15Z",
      "side": 1,
      "message": "I think it would be good to include an example of, say, BLT vs. BLE.\n\nThanks for checking. I see that the compiler doesn\u0027t generate those instructions either. Okay.",
      "parentUuid": "1348fcf3_5e0dc99c",
      "range": {
        "startLine": 10,
        "startChar": 5,
        "endLine": 10,
        "endChar": 38
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "80199018_c070a886",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 35100
      },
      "writtenOn": "2020-11-22T02:15:02Z",
      "side": 1,
      "message": "OK. I also corrected BLT* -\u003e BLE*.\n```\nPseudo branch instructions BGT, BGTU, BLE, and BLEU implemented In CL 226397 were translated inconsistently compared to other ones due to the inversion of registers. For instance, while \"BLT a, b\" generates \"jump if a \u003c b\", \"BLE a, b\" generates \"jump if b \u003c\u003d a.\" \n\nThis CL fixes the translation in the assembler and the tests.\n```",
      "parentUuid": "b20a58c1_7f0366c5",
      "range": {
        "startLine": 10,
        "startChar": 5,
        "endLine": 10,
        "endChar": 38
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52dfc6a6_2b49e0da",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-22T02:20:32Z",
      "side": 1,
      "message": "This LGTM. Thanks",
      "parentUuid": "80199018_c070a886",
      "range": {
        "startLine": 10,
        "startChar": 5,
        "endLine": 10,
        "endChar": 38
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a75cf6c3_f9c301b2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 35100
      },
      "writtenOn": "2020-11-22T01:13:31Z",
      "side": 1,
      "message": "Thanks for your review.  Maybe both directions are reasonable, but what about the consistency?\n\nJust for instance, using the current implementation of the mentioned 4 types of pseudo branches, BLE X5, X6 generates \"if X6 is less or equal to X5\" while BLT X5, X6 generates \"if X5 is less than X6.\"  It is obviously not consistent.  \n\nThe tests in  CL 226397 are like\n```\n{\"BLE\", 1, 0, testBLE, false},\n{\"BLE\", -1, 0, testBLE, true},\n```\nGiven the former operand being a and the later operand being b, these examines if b is less or equal to a. Isn\u0027t it counter-intuitive?  \n\nSo my patch revert the order of a and b in the obj tests, and p.Reg ad p.From.Reg in the assembler.",
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2392604f_46bffefd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-22T01:31:39Z",
      "side": 1,
      "message": "TRY\u003driscv64\n",
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08a1d497_14832ecd",
        "filename": "src/cmd/asm/internal/asm/testdata/riscvenc.s",
        "patchSetId": 1
      },
      "lineNbr": 351,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-22T01:31:39Z",
      "side": 1,
      "message": "Could we move this block next to BLT etc., so it is easier to compare them?",
      "range": {
        "startLine": 340,
        "startChar": 0,
        "endLine": 351,
        "endChar": 0
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8114bb99_415adbbc",
        "filename": "src/cmd/asm/internal/asm/testdata/riscvenc.s",
        "patchSetId": 1
      },
      "lineNbr": 351,
      "author": {
        "id": 35100
      },
      "writtenOn": "2020-11-22T01:58:46Z",
      "side": 1,
      "message": "Here are pseudo branch instructions, but BLT or BGE are real. I believe moving this block next to control instructions would violate the author\u0027s intention.",
      "parentUuid": "08a1d497_14832ecd",
      "range": {
        "startLine": 340,
        "startChar": 0,
        "endLine": 351,
        "endChar": 0
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5eb787d1_90642271",
        "filename": "src/cmd/asm/internal/asm/testdata/riscvenc.s",
        "patchSetId": 1
      },
      "lineNbr": 351,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-22T02:06:15Z",
      "side": 1,
      "message": "Most of the Go toolchain doesn\u0027t care about pseudo vs. real. I\u0027m not sure why we want to distinguish them.\n\nJoel, what do you think? Thanks.",
      "parentUuid": "8114bb99_415adbbc",
      "range": {
        "startLine": 340,
        "startChar": 0,
        "endLine": 351,
        "endChar": 0
      },
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a3a112a_97f78283",
        "filename": "src/cmd/internal/obj/riscv/testdata/testbranch/branch_test.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 13315
      },
      "writtenOn": "2020-11-22T01:31:39Z",
      "side": 1,
      "message": "Could you add BLT, etc. to here as well? So it would be easier to compare and spot the inconsistency.",
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8befa54a_78c42c64",
        "filename": "src/cmd/internal/obj/riscv/testdata/testbranch/branch_test.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 35100
      },
      "writtenOn": "2020-11-22T02:08:02Z",
      "side": 1,
      "message": "Sorry, but I think semantically, you don\u0027t have to have anything to compare with to spot that that `{BLE, a, b, ...}` stands for `b is less or equal to a` is weird.  Actually it is how I find this problem at the first place.\n\nIf this block needs any improvement other than my patch, I would spot one minor inconsistency here: Why are there 5 cases for each of BGT/BLE/BLEU, but only 4 for BGTU?",
      "parentUuid": "0a3a112a_97f78283",
      "revId": "385c8f99359e24fa2691c9841ccb3fc7d40f57e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}