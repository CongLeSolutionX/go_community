{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8d8d3d17_0ba10d8e",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-04-14T00:18:46Z",
      "side": 1,
      "message": "I think it\u0027s probably worth working a little harder to avoid what I think is an unnecessary allocation here.  I think we can use\n\n    type nopCloserWriterTo struct {\n        Reader\n    }\n    \n    func (nopCloserWriterTo) Close() error { return nil }\n    func (c nopCloserWriterTo) WriteTo(w Writer) (n int64, err error) {\n        return c.Reader.(WriterTo).WriteTo(w)\n    }\n    \n    func NopCloser(r Reader) ReadCloser {\n        if _, ok :\u003d r.(WriterTo); ok {\n            return nopCloserWriterTo{r}\n        }\n        return nopCloser{r}\n    }",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "041e9949_6cbae87a",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 55763
      },
      "writtenOn": "2022-04-14T00:35:30Z",
      "side": 1,
      "message": "Which allocations ?\n\n  func BenchmarkNotWriterTo(b *testing.B) {\n    b.ReportAllocs()\n    for i :\u003d 0; i \u003c b.N; i++ {\n      runtime.KeepAlive(io.NopCloser(struct{io.Reader}{}))\n    }\n  }\n\n  func BenchmarkWriterTo(b *testing.B) {\n    b.ReportAllocs()\n    for i :\u003d 0; i \u003c b.N; i++ {\n      runtime.KeepAlive(io.NopCloser(struct{io.Reader; io.WriterTo}{}))\n    }\n  }\n\n  goos: linux\n  goarch: amd64\n  cpu: AMD Ryzen 5 3600 6-Core Processor              \n  BenchmarkNotWriterTo-12    \t191579270\t         6.385 ns/op\t       0 B/op\t       0 allocs/op\n  BenchmarkWriterTo-12       \t220612800\t         5.531 ns/op\t       0 B/op\t       0 allocs/op\n  PASS\n  ok  \tcommand-line-arguments\t3.634s",
      "parentUuid": "8d8d3d17_0ba10d8e",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36222d38_d6562b57",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-04-14T00:54:44Z",
      "side": 1,
      "message": "That\u0027s not a realistic benchmark, though, because nobody actually uses the type \"struct{io.Reader; io.WriterTo}\".  The benchmark to test is a comparison of calling NopCloser with a type that only implements io.Reader and calling NopCloser with a type that implements both io.Reader and io.WriterTo.",
      "parentUuid": "041e9949_6cbae87a",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49719ea7_1c23ddac",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 55763
      },
      "writtenOn": "2022-04-14T01:06:32Z",
      "side": 1,
      "message": "With incomplete knowlege of golang\u0027s virtual types system, I don\u0027t see why that would have an impact, AFAIK a more complex type would only change which types pointers are shuffled arround.\n\nHere is a test using a *bytes.Reader instead that have 0 allocations:\n  goos: linux\n  goarch: amd64\n  cpu: AMD Ryzen 5 3600 6-Core Processor              \n  BenchmarkNotWriterTo-12    \t181507446\t         6.651 ns/op\t       0 B/op\t       0 allocs/op\n  BenchmarkWriterTo-12       \t175321104\t         7.157 ns/op\t       0 B/op\t       0 allocs/op\n \n  type onlyReader struct {\n    io.Reader\n  }\n\n  var data \u003d []byte{1, 2, 3}\n\n  func BenchmarkNotWriterTo(b *testing.B) {\n    b.ReportAllocs()\n    for i :\u003d 0; i \u003c b.N; i++ {\n      runtime.KeepAlive(io.NopCloser(onlyReader{bytes.NewReader(data)}))\n    }\n  }\n\n  func BenchmarkWriterTo(b *testing.B) {\n    b.ReportAllocs()\n    for i :\u003d 0; i \u003c b.N; i++ {\n      r :\u003d bytes.NewReader(data)\n      runtime.KeepAlive(onlyReader{r}) // Do to match NotWriterTo in case the onlyReader{r} cast allocates (this is at 0 anyway so doesn\u0027t matter)\n      runtime.KeepAlive(io.NopCloser(r))\n    }\n  }",
      "parentUuid": "36222d38_d6562b57",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b395805f_a512fddd",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 55763
      },
      "writtenOn": "2022-04-14T01:17:03Z",
      "side": 1,
      "message": "NVM it turns out that even tho I runtime.KeepAlive it this code got eliminated. MB",
      "parentUuid": "49719ea7_1c23ddac",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48d5203b_48361357",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 55763
      },
      "writtenOn": "2022-04-14T01:25:37Z",
      "side": 1,
      "message": "So with a fixed benchmark, I have data that makes sense, it seems like the compiler coalles the two types allocations into one:\n  BenchmarkNotWriterTo-12    \t24693268\t        49.69 ns/op\t      16 B/op\t       1 allocs/op\n  BenchmarkWriterTo-12       \t19768785\t        61.31 ns/op\t      32 B/op\t       1 allocs/op\n\n  type onlyReader struct {\n    io.Reader\n  }\n\n  var data \u003d []byte{1, 2, 3}\n\n  var reader io.Reader \u003d onlyReader{buff}\n  var buff io.Reader \u003d bytes.NewReader(data)\n\n  //go:noinline\n  func nopCloser(r io.Reader) io.Reader {\n    return io.NopCloser(r)\n  }\n\n  func BenchmarkNotWriterTo(b *testing.B) {\n    b.ReportAllocs()\n    for i :\u003d 0; i \u003c b.N; i++ {\n      nopCloser(reader)\n    }\n  }\n\n  func BenchmarkWriterTo(b *testing.B) {\n    b.ReportAllocs()\n    for i :\u003d 0; i \u003c b.N; i++ {\n      nopCloser(buff)\n    }\n  }\n\nI doubt there would be much impact saving 16 bytes on an allocation.",
      "parentUuid": "b395805f_a512fddd",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b17a83e_3418a25f",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 55763
      },
      "writtenOn": "2022-04-15T06:46:19Z",
      "side": 1,
      "message": "Done\n\nHowever:\nI failed to find any case where my original solution (embeding io.WriterTo) would do multiple allocations. All I can find is it allocates 2 uintptr more bytes in the single allocation.\n\nAs far as I know the question here is:\n  Does saving 2 uintptr on all NopCloser worth one more call and WriterTo cast in nopCloserWriterTo.WriteTo function ?\n\nOn my machine that overhead is ~5ns.",
      "parentUuid": "48d5203b_48361357",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66de3274_ae0f8faa",
        "filename": "src/io/io.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-04-15T17:13:12Z",
      "side": 1,
      "message": "For the standard library I think it\u0027s worth doing the smaller allocation.  Thanks.",
      "parentUuid": "3b17a83e_3418a25f",
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9508920_7942bf10",
        "filename": "src/io/io_test.go",
        "patchSetId": 1
      },
      "lineNbr": 491,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-04-14T00:18:46Z",
      "side": 1,
      "message": "We usually write \"got %t want %t\", as above.",
      "range": {
        "startLine": 491,
        "startChar": 61,
        "endLine": 491,
        "endChar": 82
      },
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "248b5fd9_3293bf08",
        "filename": "src/io/io_test.go",
        "patchSetId": 1
      },
      "lineNbr": 491,
      "author": {
        "id": 55763
      },
      "writtenOn": "2022-04-14T00:51:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c9508920_7942bf10",
      "range": {
        "startLine": 491,
        "startChar": 61,
        "endLine": 491,
        "endChar": 82
      },
      "revId": "c8a619930001fd8dccc3bbe1293ac6144e30c738",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}