{
  "comments": [
    {
      "key": {
        "uuid": "2b69225b_cd26bfbd",
        "filename": "src/runtime/mallocbits.go",
        "patchSetId": 24
      },
      "lineNbr": 135,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-10-25T21:19:33Z",
      "side": 1,
      "message": "n is a bit of an abstraction leakage, since currently mallocBits knows nothing about chunks.\n\nIf you shrink mallocBits to cover exactly one chunk, then n goes away, which is nice.",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d177f328_93967f1a",
        "filename": "src/runtime/mallocbits.go",
        "patchSetId": 24
      },
      "lineNbr": 135,
      "author": {
        "id": 25391
      },
      "writtenOn": "2019-10-28T15:56:35Z",
      "side": 1,
      "message": "this is now gone, mallocBits represents 1 chunk.",
      "parentUuid": "2b69225b_cd26bfbd",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a5e0ca5_0cab1c97",
        "filename": "src/runtime/mallocbits_test.go",
        "patchSetId": 24
      },
      "lineNbr": 126,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-10-25T21:19:33Z",
      "side": 1,
      "message": "Consider doing randomized testing, too.",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c383ed6_6fc183b9",
        "filename": "src/runtime/mallocbits_test.go",
        "patchSetId": 24
      },
      "lineNbr": 126,
      "author": {
        "id": 25391
      },
      "writtenOn": "2019-10-28T15:56:35Z",
      "side": 1,
      "message": "I started doing this, but writing a reference implementation for computing \"max\" turned out to be more complicated than the existing implementation, since it computes all three simultaneously.\n\nIf you think this is still worth it let me know (or maybe there\u0027s something I missed) and I can come back to it.",
      "parentUuid": "7a5e0ca5_0cab1c97",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20f2c16f_33a574d3",
        "filename": "src/runtime/mallocbits_test.go",
        "patchSetId": 24
      },
      "lineNbr": 126,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-10-29T03:16:15Z",
      "side": 1,
      "message": "func (b *mallocBits) get(i int) uint {\n\treturn uint((b[i/64] \u003e\u003e (uint(i) % 64)) \u0026 1)\n}\n\nfunc summarizeSlow(b mallocBits) (start, max, end int) {\n\tconst N \u003d len(b) * 64\n\tfor start \u003c N \u0026\u0026 b.get(start) \u003d\u003d 0 {\n\t\tstart++\n\t}\n\tfor end \u003c N \u0026\u0026 b.get(N - end - 1) \u003d\u003d 0 {\n\t\tend++\n\t}\n\trun :\u003d 0\n\tfor i :\u003d 0; i \u003c N; i++ {\n\t\tif b.get(i) \u003d\u003d 0 {\n\t\t\trun++\n\t\t} else {\n\t\t\trun \u003d 0\n\t\t}\n\t\tif run \u003e max {\n\t\t\tmax \u003d run\n\t\t}\n\t}\n\treturn\n}",
      "parentUuid": "9c383ed6_6fc183b9",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e1a4090_3f2affac",
        "filename": "src/runtime/mallocbits_test.go",
        "patchSetId": 24
      },
      "lineNbr": 126,
      "author": {
        "id": 25391
      },
      "writtenOn": "2019-10-29T18:55:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "20f2c16f_33a574d3",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e318ae32_c7a5620f",
        "filename": "src/runtime/mallocbits_test.go",
        "patchSetId": 24
      },
      "lineNbr": 137,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-10-25T21:19:33Z",
      "side": 1,
      "message": "Making mallocBits exactly one chunk also simplifies this test a lot.",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a274ddc3_0691d869",
        "filename": "src/runtime/mallocbits_test.go",
        "patchSetId": 24
      },
      "lineNbr": 137,
      "author": {
        "id": 25391
      },
      "writtenOn": "2019-10-28T15:56:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e318ae32_c7a5620f",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d310d5a_cbdc97aa",
        "filename": "src/runtime/mpagealloc.go",
        "patchSetId": 24
      },
      "lineNbr": 74,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-10-25T21:19:33Z",
      "side": 1,
      "message": "unsafe.Sizeof(mallocSum)\n\nThough, do we actually use this constant anywhere?",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4dd27424_56c33511",
        "filename": "src/runtime/mpagealloc.go",
        "patchSetId": 24
      },
      "lineNbr": 74,
      "author": {
        "id": 25391
      },
      "writtenOn": "2019-10-28T15:56:35Z",
      "side": 1,
      "message": "in the next CL. I\u0027ll move it there.",
      "parentUuid": "6d310d5a_cbdc97aa",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c23588df_c3b4b99a",
        "filename": "src/runtime/mpagealloc.go",
        "patchSetId": 24
      },
      "lineNbr": 76,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-10-25T21:19:33Z",
      "side": 1,
      "message": "Doc comment.\n\nConsider moving logMaxPackedValue after maxPackedValue.",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cb5621b_d4754516",
        "filename": "src/runtime/mpagealloc.go",
        "patchSetId": 24
      },
      "lineNbr": 76,
      "author": {
        "id": 25391
      },
      "writtenOn": "2019-10-28T15:56:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c23588df_c3b4b99a",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "23f2855a_80d6dbe8",
        "filename": "src/runtime/mpagealloc.go",
        "patchSetId": 24
      },
      "lineNbr": 82,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-10-25T21:19:33Z",
      "side": 1,
      "message": "It\u0027s not clear what \"this value\" is referring to.\n\nMaybe \"... each of which may have a maximum value of 2^21-1, or all three may be equal to 2^21. The latter case is represented by setting just the 64th bit.\"?",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b0a6ecc_97bf1b5a",
        "filename": "src/runtime/mpagealloc.go",
        "patchSetId": 24
      },
      "lineNbr": 82,
      "author": {
        "id": 25391
      },
      "writtenOn": "2019-10-28T15:56:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "23f2855a_80d6dbe8",
      "revId": "12e8a3e02c1fec25773217b6acd25c7058fdcc50",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}