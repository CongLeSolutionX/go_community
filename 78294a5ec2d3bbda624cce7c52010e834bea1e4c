{
  "comments": [
    {
      "key": {
        "uuid": "814ef0fc_d9ef7d87",
        "filename": "src/math/unsafe.go",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 5295
      },
      "writtenOn": "2018-10-28T17:58:55Z",
      "side": 1,
      "message": "This just repeats what IEEE 754 defines[0], but the documentation already says `IEEE 754 binary representation`\n\n  [0]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32",
      "revId": "78294a5ec2d3bbda624cce7c52010e834bea1e4c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "842811ac_7fade394",
        "filename": "src/math/unsafe.go",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 5210
      },
      "writtenOn": "2018-10-28T18:25:40Z",
      "side": 1,
      "message": "I\u0027d agree with Jan here. Anybody using these functions will need to understand the IEEE 754 representation in detail - there\u0027s no point in trying to repeat some of those details here. It only provides a wrong sense of security (understanding the format requires more than just the few sentences here, and we don\u0027t want document the entire format).\n\nThe only thing that _perhaps_ needs to be done here, is to say the the sign bit of f matches up with the sign bit of the result. That should imply the rest.\n\nE.g.,\n\n// Float32bits returns the IEEE 754 binary representation of f,\n// such that the sign bit of f lines up with the sign bit of the result.",
      "parentUuid": "814ef0fc_d9ef7d87",
      "revId": "78294a5ec2d3bbda624cce7c52010e834bea1e4c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8356ce89_10fedd18",
        "filename": "src/math/unsafe.go",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 29777
      },
      "writtenOn": "2018-10-28T19:46:44Z",
      "side": 1,
      "message": "That seems a little difficult to unpack. What if we just mention that the sign bit is the most significant, and leave it at that?",
      "parentUuid": "842811ac_7fade394",
      "revId": "78294a5ec2d3bbda624cce7c52010e834bea1e4c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd0c7923_424639cc",
        "filename": "src/math/unsafe.go",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 5210
      },
      "writtenOn": "2018-10-28T22:24:10Z",
      "side": 1,
      "message": "The point I am trying to make is that we want the sign bits to match up - that\u0027s the property that will allow us to use the resulting bit pattern as expected (because it implies the same bit ordering in the result as in the float).\n\nBut I\u0027m fine as long as what we specify here permits the expected use of the result w/o implying a particular endianness of implementation.\n\nWhat would be useful to mention is that\n\nFloat32frombits(Float32bits(f)) \u003d\u003d f.\n\nAnd vice versa.",
      "parentUuid": "8356ce89_10fedd18",
      "revId": "78294a5ec2d3bbda624cce7c52010e834bea1e4c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}