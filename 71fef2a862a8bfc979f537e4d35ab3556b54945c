{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4b14c2ea_6316885e",
        "filename": "src/internal/cpu/cpu.go",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-12-14T17:35:57Z",
      "side": 1,
      "message": "No need to have padding in the middle here.",
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "facbbbde_d71f59a5",
        "filename": "src/internal/cpu/cpu.go",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-12-14T17:35:57Z",
      "side": 1,
      "message": "This field needs a comment describing what it is.",
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a359b72_1caa7c8c",
        "filename": "src/internal/cpu/cpu_x86.go",
        "patchSetId": 1
      },
      "lineNbr": 125,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-12-14T17:35:57Z",
      "side": 1,
      "message": "I suspect this doesn\u0027t work for amd cpus.",
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8add7299_523e593e",
        "filename": "src/internal/cpu/cpu_x86.go",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-12-14T17:35:57Z",
      "side": 1,
      "message": "You don\u0027t need to declare this here. Just use cacheType :\u003d below.",
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "496b461b_0a4ae229",
        "filename": "src/runtime/memclr_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 73,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-12-14T17:35:57Z",
      "side": 1,
      "message": "This should be MOVL (or MOVLQZX, to be pedantic). Otherwise you\u0027re loading 4 bytes of junk into the upper bits.",
      "range": {
        "startLine": 73,
        "startChar": 1,
        "endLine": 73,
        "endChar": 5
      },
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b90c5d58_fe4b65d3",
        "filename": "src/runtime/memclr_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 73,
      "author": {
        "id": 52588
      },
      "writtenOn": "2021-12-14T18:03:22Z",
      "side": 1,
      "message": "Before we start our own explicit fine tuning here I would suggest we benchmark this against rep stosb and/or rep stosq on modern CPUs that are microcoded and also also internally consider cache sizes and even larger registers as far as I read. So instead of coding all that explicitly we could just check for ERMS/FSRM bits and use rep stos accordingly to get the microcoded optimized implementations. We do this to some degree with moves in memmove too. rep stos startup costs might still be a hindrance to adoption but we if we using it only for large area zeroing this should be mitigated.",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 53
      },
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "496a4821_989cb1bf",
        "filename": "src/runtime/memclr_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 73,
      "author": {
        "id": 52933
      },
      "writtenOn": "2021-12-19T09:45:10Z",
      "side": 1,
      "message": "Run several benchmarks on REP STOSQ. Implementation which are compared:\n1) AVX2_small (loop_avx2 in memclr_amd64.s): uses VMOVDQU\n2) AVX2_huge (loop_avx2_huge in memclr_amd64.s): uses VMOVNTDQ\n3) REP STOSQ: implemented as simple as:\n      MOVQ\tBX, CX\n      SHRQ\t$3, CX\n      ANDQ\t$7, BX\n      REP;\tSTOSQ\n      JMP\ttail\n      \nSumups: \n*   REP STOS has startup cost and it shows worse performance comparing to AVX2_small running on\n    small sizes. But it has better perofrmance at ~1-2MB mark based on benchmarks.\n*   Non-temporal stores show better performance running on sizes which increase size of L3 cache.\n\nFull test data: https://gist.github.com/nimelehin/6e8e9765e7a8e9ce833ad7864528ae01\n\nMaybe it\u0027s worth to implement logic of memclr in the following way:\n1) The standard implementation for size which are less than L3 cache size is AVX2_small\n2) Based on if ERMS supported use REP STOSQ for sizes \u003e\u003d2MB and less than L3 cache size.\n3) For all sizes bigger than L3 cache size use non-temporal stores.",
      "parentUuid": "b90c5d58_fe4b65d3",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 53
      },
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e190fb9_ccc61a99",
        "filename": "src/runtime/memclr_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 73,
      "author": {
        "id": 52588
      },
      "writtenOn": "2021-12-19T19:05:24Z",
      "side": 1,
      "message": "Thanks for running the benchmarks!\n\nI thought REP STOS also bypasses cache for larger sizes. Maybe it was only REP MOV which definitely does. Maybe it depends on the cpu.\n\nOne interesting case that could benefit from rep stos more than explicit avx2 is also machines with larger registers (avx512 which might not even need to be supported externally e.g. pentium variants). Or machines with no avx2 but internally better processing (pentiums variants of core architectures).\n\nI see if I can run some benchmarks myself in the coming weeks. There definitely is room for improvement here.\n\nIf we can get improvements without needing to depend on LLC (can be L2,L3,L4...) that would seem to only works on Intel I would prefer to merge those first. It will also get more complex with inclusive vs non-inclusive caches and multi cpu machines.",
      "parentUuid": "496a4821_989cb1bf",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 53
      },
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3c22c68_d0592ca9",
        "filename": "src/runtime/memclr_amd64.s",
        "patchSetId": 1
      },
      "lineNbr": 73,
      "author": {
        "id": 52933
      },
      "writtenOn": "2021-12-20T10:43:22Z",
      "side": 1,
      "message": "REP STOS DOES bypasses cache for larger sizes. I measured cache-references and it\u0027s ~200x less than VMOVDQU, while almost at the same level with NT MOVs.\n\nAVX2 small:\n    13,732,741,034      cache-references\n     3,614,721,625      cache-misses              #   26.322 % of all cache refs\nAVX2 huge:\n       488,527,576      cache-references\n        94,434,053      cache-misses              #   19.330 % of all cache refs\nREP STOS:\n        76,390,554      cache-references\n        13,121,460      cache-misses              #   17.177 % of all cache refs\n\nI remeasured performance and it still worse for REP STOS(B|Q) comparing to Non-Temporal moves. I tested one more Intel i7-8700, the results are the same. I used benchmark from memmove_test.go, but since it runs several memclr with the same size, AVX2 could show better results because of a trained branch-predictor. Intel mentioned that in Optimization Guide Section 15.16.3.3.\n\nIt is also interesting what\u0027s going on with AMD CPUs. Unfortunately, I don\u0027t have any of them. Maybe you can test this on them.",
      "parentUuid": "5e190fb9_ccc61a99",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 53
      },
      "revId": "71fef2a862a8bfc979f537e4d35ab3556b54945c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}