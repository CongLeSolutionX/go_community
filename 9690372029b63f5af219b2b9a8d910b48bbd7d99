{
  "comments": [
    {
      "key": {
        "uuid": "4d8582c8_3b2f3edb",
        "filename": "src/cmd/go/internal/work/exec.go",
        "patchSetId": 2
      },
      "lineNbr": 746,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-05-21T19:52:06Z",
      "side": 1,
      "message": "A bit more documentation would be helpful here: what is the relationship between the keys of Standard and ImportMap?\n\nThe block at 822–829 (`if vcfg.ImportMap[\"fmt\"] \u003d\u003d \"\"`) suggests that the keys of Standard are a subset of the keys of ImportMap, but the loop at 779–798 only adds the ImportMap entry if the package was built. Is that difference intentional?",
      "revId": "9690372029b63f5af219b2b9a8d910b48bbd7d99",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b01c6992_7393d3ba",
        "filename": "src/cmd/go/internal/work/exec.go",
        "patchSetId": 2
      },
      "lineNbr": 746,
      "author": {
        "id": 5206
      },
      "writtenOn": "2018-05-24T17:24:38Z",
      "side": 1,
      "message": "Well, none of this stuff is documented.\n\nAs I understand it (I didn\u0027t write any of this code), ImportMap maps from package paths that appear in the program to package paths as seen by the compiler and vet.  Normally ImportMap[x] \u003d\u003d x, but this is not true for vendored packages and is not necessarily true for local imports.  This is basically capturing the way that LoadImport (in cmd/go/internal/load/pkg.go) changes its path argument to the ImportPath field of the package that it returns.  LoadImport\u0027s path argument is the key of ImportMap.  The returned ImportPath field is the value of ImportMap.\n\nIn general this import mapping only matters for package files that actually exist, which is why the loop at 779-798 skips packages for which a1.built \u003d\u003d \"\".  I don\u0027t actually know all the cases when that will be true.  But I do know one of those cases: when using gccgo/GoLLVM, it will be true for all packages in the standard library.  That is because standard library packages are not built as separate package files, but are simply compiled into libgo.  So that is why we need to set Standard even when a1.built \u003d\u003d \"\".\n\nThe block at 822 to 829 is assuming that \"fmt\" always exists.  It is ensuring that we always pass \"fmt\" to cmd/vet, for vet\u0027s printf checks.  If ImportMap[\"fmt\"] \u003d\u003d \"\", that means that the package does not import \"fmt\".  So we are forcing it into the configuration.\n\nSo in general the keys of Standard are exactly the keys of ImportMap.  This is different when using gccgo/GoLLVM, for which Standard will include packages in the standard library that will not appear in ImportMap.  For the gc toolchain, it will only be different if there are standard library packages for which a1.built \u003d\u003d \"\", which I assume is the empty set.\n\nAny suggestions for where and whether I should add any of this in comments?",
      "parentUuid": "4d8582c8_3b2f3edb",
      "revId": "9690372029b63f5af219b2b9a8d910b48bbd7d99",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f3bfa4c_49b37bb1",
        "filename": "src/cmd/go/internal/work/exec.go",
        "patchSetId": 2
      },
      "lineNbr": 746,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-05-24T18:40:01Z",
      "side": 1,
      "message": "The thing I\u0027m confused about in this change is the postcondition on ImportMap after buildVetConfig.\n\nIf I\u0027m following correctly, in the baseline revision the postcondition of buildVetConfig is, more or less, “ImportMap contains entries for all dependencies that are built”.\n\nThe equivalent postcondition after this change would be, “ImportMap contains entries for all dependencies that can be imported”. However, that postcondition does *not* hold. Instead we have something more like, “the union of the keys of Standard and ImportMap contains all dependencies that can be imported”.\n\nThat\u0027s a fairly subtle invariant, and made more subtle by the fact that it crosses process boundaries. (In writing this comment, I only now understood why the special-case in cmd/vet/main.go needed to be so complex.)\n\n\nIf we instead preserve the invariant that everything to be imported is in ImportMap, then the conditions for the special case in `vet` become simpler.\n\nIn the current snapshot you have:\n\n\tp :\u003d v.ImportMap[path]\n\t// gccgo doesn\u0027t have sources for standard library packages,\n\t// but the importer will do the right thing.\n\tif v.Compiler \u003d\u003d \"gccgo\" \u0026\u0026 v.Standard[path] \u0026\u0026 (p \u003d\u003d \"\" || v.PackageFile[p] \u003d\u003d \"\") {\n\t\treturn v.imp.Import(path)\n\t}\n\tif p \u003d\u003d \"\" {\n\t\treturn nil, fmt.Errorf(\"unknown import path %q\", path)\n\t}\n\tif v.PackageFile[p] \u003d\u003d \"\" {\n\t\treturn nil, fmt.Errorf(\"unknown package file for import %q\", path)\n\t}\n\treturn v.imp.Import(p)\n\nbut with the stronger invariant that could be written:\n\n\tp :\u003d v.ImportMap[path]\n\tif p \u003d\u003d \"\" {\n\t\treturn nil, fmt.Errorf(\"unknown import path %q\", path)\n\t}\n\tif v.PackageFile[p] \u003d\u003d \"\" {\n\t\tif v.Compiler \u003d\u003d \"gccgo\" \u0026\u0026 v.Standard[path] {\n\t\t\t// gccgo doesn\u0027t have sources for standard library packages,\n\t\t\t// but its importer knows how to handle them.\n\t\t\treturn v.imp.Import(path)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"unknown package file for import %q\", path)\n\t}\n\treturn v.imp.Import(p)\n\n\nI think the code change here to accomplish that is fairly straightfoward too:\n\n\t\tif p1 \u003d\u003d nil || p1.ImportPath \u003d\u003d \"\" {\n\t\t\tcontinue\n\t\t}\n\t\t// Add import mapping if needed\n\t\t// (for imports like \"runtime/cgo\" that appear only in generated code).\n\t\tif !vcfgMapped[p1.ImportPath] {\n\t\t\tvcfg.ImportMap[p1.ImportPath] \u003d p1.ImportPath\n\t\t}\n\t\tif a1.built {\n\t\t\tvcfg.PackageFile[p1.ImportPath] \u003d a1.built\n\t\t}\n\t\tif p1.Standard {\n\t\t\tvcfg.Standard[p1.ImportPath] \u003d true\n\t\t}\n\nThat makes the loop body exactly parallel to the `fmt` special-case: first update ImportMap, then PackageFile, then Standard.",
      "parentUuid": "b01c6992_7393d3ba",
      "revId": "9690372029b63f5af219b2b9a8d910b48bbd7d99",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12003989_8144b47f",
        "filename": "src/cmd/vet/main.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-05-21T19:52:06Z",
      "side": 1,
      "message": "https://tip.golang.org/pkg/go/importer/#Lookup says:\n“A Lookup function returns a reader to access package data for a given import path, or an error if no matching package is found.”\nThat does not seem to allow a return of `nil, nil`.\n\nDoes this change need a corresponding documentation update in `go/importer`, or is this exclusively an internal hook that we do not intend for outside users to replicate?\n\n----\n\nMore generally, this seems to point to a layering issue in the `go/importer` API: the actual constraints on the passed-in `Lookup` function increasingly depend on the value passed for the `compiler` argument. When compiler \u003d\u003d \"gccgo\", the constraints are both more permissive and more stringent: the function is allowed to return `nil, nil`, but required to return an `io.ReadSeeker` (not just an `io.ReadCloser`).\n\nThat suggests that `importer.For` is not a particularly useful abstraction, since callers increasingly cannot use the same function across compilers. Should we consider deprecating `importer.For` and splitting it up into separate, more targeted functions?",
      "revId": "9690372029b63f5af219b2b9a8d910b48bbd7d99",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ae833cc9_ea9b7ab4",
        "filename": "src/cmd/vet/main.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 5206
      },
      "writtenOn": "2018-05-24T17:24:38Z",
      "side": 1,
      "message": "I don\u0027t really have any opinion, except that I don\u0027t think this CL, which fixes a current bug, should be gated on that design discussion.  There are only two importers, and there are no current prospects of ever adding another importer, so I don\u0027t think it\u0027s a particularly important issue.  It\u0027s something to raise with gri.",
      "parentUuid": "12003989_8144b47f",
      "revId": "9690372029b63f5af219b2b9a8d910b48bbd7d99",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5279255_0f807b76",
        "filename": "src/cmd/vet/main.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-05-24T18:40:01Z",
      "side": 1,
      "message": "Ok, I\u0027ll follow up separately.",
      "parentUuid": "ae833cc9_ea9b7ab4",
      "revId": "9690372029b63f5af219b2b9a8d910b48bbd7d99",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}