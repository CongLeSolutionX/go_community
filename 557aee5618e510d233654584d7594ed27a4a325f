{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "cecc87f5_3ad61156",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-09-22T16:28:40Z",
      "side": 1,
      "message": "Matthew, adding you in case you have any comments/suggestions on this crawler change for generics (because we always create methods for any instantiated type we see during export).",
      "revId": "557aee5618e510d233654584d7594ed27a4a325f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aca035de_bcd72865",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-09-22T17:28:18Z",
      "side": 1,
      "message": "Looks ok. Not sure I completely understand what\u0027s going on here. It\u0027s certainly the case that the method Has in the example is never called, so it\u0027s not clear why we\u0027d need to generate it, as opposed to deciding it wasn\u0027t necessary somehow. Or are there cases where we do need it? Can we write such a test?\n\n",
      "revId": "557aee5618e510d233654584d7594ed27a4a325f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e948fd4f_cc5e17a8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-09-22T18:27:15Z",
      "side": 1,
      "message": "One of the issues is that when we import code that references a new instantiated type (or a type that contains a new instantiated type), we don\u0027t distinguish how that instantiated type will be used (if at all).  For simplicity, we currently always instantiate its methods and mark that we need its runtime-type (which means we have to construct its itab, which does reference those methods).  As mentioned in comments, this is in subsInstType in iexport.go.\n\nWe could attempt to distinguish various cases, but I\u0027m not sure it is worth adding that complexity.  In many of the cases, we do definitely need the instantiated type\u0027s itab and many/all of its methods and the associated dictionaries.  (e.g. see issue https://github.com/golang/go/issues/48543)",
      "parentUuid": "aca035de_bcd72865",
      "revId": "557aee5618e510d233654584d7594ed27a4a325f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5c17508a_965bff40",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-09-24T16:57:37Z",
      "side": 1,
      "message": "Keith - does this seem OK, given my response?  Matthew is now on vacation, so he likely won\u0027t be looking at this for a while.\n",
      "revId": "557aee5618e510d233654584d7594ed27a4a325f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}