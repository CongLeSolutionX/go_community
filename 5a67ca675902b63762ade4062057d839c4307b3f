{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "15988942_3bc9edf2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-05-03T17:22:12Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d5a67ca67",
      "tag": "autogenerated:trybots~beginning",
      "revId": "5a67ca675902b63762ade4062057d839c4307b3f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fa77b4d_b79c4dcf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-05-03T17:28:54Z",
      "side": 1,
      "message": "Something to consider: using sha256.Sum256 is somewhat expensive, on basic inputs this adds ~30Âµs per execution of my machine.\n\nDo we need to include the hash at all? When a target panics we already log it when printing the file name, so it\u0027s somewhat redundant. When a test fails but doesn\u0027t panic, I\u0027m not entirely sure what value the hash provides to the user, since it\u0027s a mutated input there is nothing they can really do with it, or derive from its value. I think the only case where it\u0027s useful is when a seeded input fails, which we can indicate with the test name \"FuzzTarget/seed#N\" which is likely to be more valuable than the hash of the seed.",
      "revId": "5a67ca675902b63762ade4062057d839c4307b3f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1d8a2d7_e464bf91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-05-03T17:33:55Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "15988942_3bc9edf2",
      "tag": "autogenerated:trybots~happy",
      "revId": "5a67ca675902b63762ade4062057d839c4307b3f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7cf3f96e_4e40f09d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-05-06T20:14:38Z",
      "side": 1,
      "message": "That might be an issue if a target that\u0027s already in the seed corpus fails. Like maybe someone runs fuzzing, it finds a crash and the person commits both the bug fix and the file to their repo. Then a few months down the line someone re-introduces a bug and now the existing seed corpus file fails. In that situation, if we don\u0027t print the hash/filename then they won\u0027t know what failed. So I think we should just keep this for now, but consider what we might want to do instead in the future if this ends up being a major bottleneck.",
      "parentUuid": "0fa77b4d_b79c4dcf",
      "revId": "5a67ca675902b63762ade4062057d839c4307b3f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "136608d7_3cbc5408",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-05-06T20:14:38Z",
      "side": 1,
      "message": "Just the one comment, but otherwise LGTM. Thanks Roland!",
      "revId": "5a67ca675902b63762ade4062057d839c4307b3f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6ecd8f69_eb8aa9ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-05-06T21:19:25Z",
      "side": 1,
      "message": "I think we could write the code that populates the code in such a way that this would be avoided. For inputs seeded from the Fuzz.. function, or from the testdata/corpus directory, we can populate CorpusEntry.Name (I think this is actually already done for testdata inputs?) and then append that name to the test name if it\u0027s non-empty. That way the only inputs that would result in boilerplate names would be those that are the results of mutation, so in the case of the crash we\u0027d still be printing the filename.",
      "parentUuid": "7cf3f96e_4e40f09d",
      "revId": "5a67ca675902b63762ade4062057d839c4307b3f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "baff195e_15499c4b",
        "filename": "src/internal/fuzz/worker.go",
        "patchSetId": 2
      },
      "lineNbr": 611,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-05-06T20:14:38Z",
      "side": 1,
      "message": "We should probably keep this consistent with how the filename is generated in writeToCorpus in internal/fuzz/fuzz.go. A helper function would be nice, so we\u0027re just always generating this hash the same way.\n\nIn that file, we just use \"fmt.Sprintf(\"%x\", sha256.Sum256(b))\". I don\u0027t know if it makes much of a difference either way, so whichever one is the most readable, that can go into a function and it can be used here and throughout.",
      "range": {
        "startLine": 611,
        "startChar": 48,
        "endLine": 611,
        "endChar": 82
      },
      "revId": "5a67ca675902b63762ade4062057d839c4307b3f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}