{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dacfc33c_8317bfa8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T22:52:23Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "f3637855_626ab938",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93ba0ad2_1cc41f23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T22:52:23Z",
      "side": 1,
      "message": "SlowBots beginning. Status page: https://farmer.golang.org/try?commit\u003dd56c4974",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bcf33e6_1f71c784",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T23:03:32Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003dd56c4974\nFailed on linux-amd64-nocgo: https://storage.googleapis.com/go-build-log/d56c4974/linux-amd64-nocgo_6b21bb27.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "93ba0ad2_1cc41f23",
      "tag": "autogenerated:trybots~progress",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23371f42_8431dace",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T23:05:51Z",
      "side": 1,
      "message": "1 of 29 SlowBots failed.\nFailed on linux-amd64-nocgo: https://storage.googleapis.com/go-build-log/d56c4974/linux-amd64-nocgo_6b21bb27.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\nSlowBot builds that ran:\n* linux-amd64-nocgo\n",
      "parentUuid": "93ba0ad2_1cc41f23",
      "tag": "autogenerated:trybots~failed",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da86bf23_f562f002",
        "filename": "src/runtime/os_aix.go",
        "patchSetId": 6
      },
      "lineNbr": 378,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "Throw?",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae36e7ea_183a3bd2",
        "filename": "src/runtime/os_aix.go",
        "patchSetId": 6
      },
      "lineNbr": 378,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "sighandler doesn\u0027t check GOARCH before calling this function, so it can\u0027t throw. Do you think that would be cleaner? I don\u0027t feel strongly either way.",
      "parentUuid": "da86bf23_f562f002",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6411c1ea_ff0b5c2a",
        "filename": "src/runtime/os_aix.go",
        "patchSetId": 6
      },
      "lineNbr": 378,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T22:22:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ae36e7ea_183a3bd2",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "111d3da4_75f0fb44",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 690,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "Which mp? Or is this saying that this must be true for all mp?",
      "range": {
        "startLine": 690,
        "startChar": 46,
        "endLine": 690,
        "endChar": 74
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0304b999_40a72b1b",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 690,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "Done. All Ms, because any M may read this from its signal handler if needPerThreadSyscall is set.",
      "parentUuid": "111d3da4_75f0fb44",
      "range": {
        "startLine": 690,
        "startChar": 46,
        "endLine": 690,
        "endChar": 74
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f06a802_44ff5d12",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 737,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "Shouldn\u0027t syscall.Syscall just return 0 for this? Or is this something really annoying where *some* syscalls use r2 and others leave it unset and the ones we\u0027re interested in here leave it unset?",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51da385a_6a163670",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 737,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "I need to look into this more. This is a holdover from the fix for https://go.dev/issue/42178. I agree it seems like the ppc64 syscall function should just return 0.",
      "parentUuid": "6f06a802_44ff5d12",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98073401_93aabb96",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 737,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-13T17:52:01Z",
      "side": 1,
      "message": "Observations on the ppc64 syscalls were that the r2 value was not set consistently. The ABI for those platforms leaves the return values undefined (https://github.com/golang/go/issues/42178#issuecomment-718353394). Go overriding this to force it to always be 0 shouldn\u0027t break anyone\u0027s code. However, might it create a code expectation for apparent consistency where the kernel doesn\u0027t actually provide one? Perhaps this is OK because the Go runtime is the defining implementation?",
      "parentUuid": "51da385a_6a163670",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da5864b7_e4b4c57c",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 737,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-14T17:53:05Z",
      "side": 1,
      "message": "My read of man syscall (and https://github.com/golang/go/issues/42178#issuecomment-718353394) is that there simply is no second return register on ppc64. That is, it is consistently not set (maybe that\u0027s what you meant by \"not set consistently\" :)\n\nIn that case, we should just return 0 from Syscall and Syscall6 on ppc64.\n\nLooking at the kernel, system_call_exception only returns a single long (https://elixir.bootlin.com/linux/v5.16.9/source/arch/powerpc/kernel/interrupt.c#L78), but I haven\u0027t been able to make sense of the syscall return path (https://elixir.bootlin.com/linux/v5.16.9/source/arch/powerpc/kernel/interrupt_64.S#L115), which sure looks like it clobbers R3 (the return value). It\u0027s also possible that any syscall could set R4 (the second return word on ppc64) in the pt_regs.",
      "parentUuid": "98073401_93aabb96",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a15e78ab_5ebd0b78",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 737,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-14T20:09:06Z",
      "side": 1,
      "message": "I\u0027ve filed https://go.dev/issue/51192 for further investigation, but I don\u0027t think that needs to block this CL.",
      "parentUuid": "98073401_93aabb96",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1232113d_575165e0",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-08T23:43:22Z",
      "side": 1,
      "message": "Won\u0027t this deadlock if a thread is already executing a signal handler? IIRC this is what the signal test was testing for and why the current implementation has an mDoFixupAndOSYield().",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70538955_7931d131",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T17:47:54Z",
      "side": 1,
      "message": "I don\u0027t think so.\n\nhttps://go-review.googlesource.com/c/go/+/305149/9/src/runtime/sigqueue.go ran into trouble because sigsend would spin in the signal handler waiting for the signal_recv goroutine to change state back to sigIdle.\n\nWith this CL, sigFixup is gone completely and sigsend should no longer spin indefinitely. It can now loop only if it loses a CAS race, which it should eventually win.\n\nI\u0027m not aware of anywhere else that signal handlers can block indefinitely.",
      "parentUuid": "1232113d_575165e0",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b127b12_23e9f692",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-09T21:11:20Z",
      "side": 1,
      "message": "So this code runs without stop the world and that changes the dynamics somewhat.\n\nWhen I added that sigFixup code it was to account for the fact that the spinning thread couldn\u0027t complete until another thread was able to receive the data the in-signal-handler thread was trying to forward. This couldn\u0027t happen because the world was stopped. This meant we could neither receive signals on the code running this present function - while spinning it would be unable to start the world again, and I had to find a way to execute the fixup code from whatever that asynchronous signal handler was spinning doing.\n\nBoth of those two things are not present here. Are we saying that because the world isn\u0027t stopped, the runtime can happily schedule one of the running Ms to execute that code and unblock the signal handler M?",
      "parentUuid": "70538955_7931d131",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "376c7652_a3d1845b",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T22:34:10Z",
      "side": 1,
      "message": "I think too many subsequent issues are getting confused here.\n\nTaking a look at the initial CL 277434 which added the initial sigqueue, the problem was that the M running signal_recv was blocked in notetsleepg, thus preventing the fixup from completely [1].\n\nThat CL kicked the note so that M could reach the fixup in exitsyscall -\u003e gcstopm.\n\nBut it needed to do something about the signal handler sigsend, which couldn\u0027t handle state sigFixup, so it added the osyield() loop waiting for sigIdle, which introduced the deadlock possibility.\n\nWithout sigFixup, this problem no longer applies.\n\nPut another way, let\u0027s look at what the signal handler does for each state:\n\nsigIdle: CAS to sigSending, then return\nsigSending: return\nsigReceiving: CAS to sigIdle, then return\n\nThere is no reason for any of those to ever block indefinitely. Yes, CAS is a loop and could fail in the event of a race, but there is no reason for it to fail continuously. If constantly racing with signal_recv or other threads\u0027 signal handler, it probabilistically should eventually win one of those races.\n\n[1] Note that notetsleepg is ironically just a blocking syscall, like we are fixing now: https://cs.opensource.google/go/go/+/master:src/runtime/lock_futex.go;l\u003d235-237;drc\u003df229e7031a6efb2f23241b5da000c3b3203081d6",
      "parentUuid": "6b127b12_23e9f692",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d5a5fc4a_584fe35a",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T22:22:07Z",
      "side": 1,
      "message": "Resolved.",
      "parentUuid": "376c7652_a3d1845b",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd7a8960_5d387b20",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 803,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-09T21:11:20Z",
      "side": 1,
      "message": "Is there any need to lock the coordinating OS thread in this function? Or is it somehow true implicitly that the M that has already run the initial syscall is guaranteed to still be this one?",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36dd0fb9_386ce6de",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 803,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T22:34:10Z",
      "side": 1,
      "message": "`allocmLock.lock()` implicitly locks us to this M. But perhaps I should also add `acquirem` to make this more explicit.",
      "parentUuid": "fd7a8960_5d387b20",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "126eec98_3cb8ca19",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 803,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "36dd0fb9_386ce6de",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef070571_a6c67973",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 810,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-09T21:11:20Z",
      "side": 1,
      "message": "I can\u0027t see what stops goroutines migrating from one M to another while this loop is running. If that is possible and, say, we are transitioning from UID0 to UID1, is it possible for some goroutine to transition between them before the loop below completes? That is, a single goroutine observes:\n\n  running with UID0 on m1\n  running with UID1 on m1\n  running with UID0 on m2\n  running with UID1 on m2\n\nIt was to avoid this experience (and never observe the reverse transition) that the old code used stop the world.",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75bdcdd6_b5743600",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 810,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T22:34:10Z",
      "side": 1,
      "message": "Yes, that is definitely possible. Was that a constraint on the API? I didn\u0027t notice any mention. If we need it, we could add STW back just for that purpose.\n\nThough IMO, goroutines shouldn\u0027t rely on thread state until AllThreadsSyscall returns. Is there a particular case where this visibility causes problems?",
      "parentUuid": "ef070571_a6c67973",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5401d8c_ca77ead1",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 810,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-10T23:45:41Z",
      "side": 1,
      "message": "This behavior is different from the CGO implementation of things like `C.setuid()` and also existing uses of the `AllThreadsSyscall()`.\n\nIt doesn\u0027t seem too hard to imagine some user code that might be tripped up by these semantics `if syscall.Getuid() !\u003d 0 { deleteAFileWithoutBotheringToCheckForPermission() } else if readFilePermissionsDontRequirePrivilegeToDelete() { removeTheFile() }`. That is, the code can rely on the kernel to prevent it deleting something only after it verifies the process has dropped privilege.\n\nThe slower (safer) code could execute in all cases, but the lower complexity code assumes once the test confirms the UID is no longer that of root, it can\u0027t be retracted. I think, if someone found this worked as expected when compiled with cgo, but not without cgo, we\u0027d be treating that user report as a Go bug.",
      "parentUuid": "75bdcdd6_b5743600",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee277d74_f101bbce",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 810,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "OK, I\u0027ve added STW back, I was just removing it opportunistically.\n\nThat said, I would strongly advise against anyone racing AllThreadsSyscall with code that depends on the changing thread state (e.g., UID). You happened to give an example that is OK, but it is really easy to mess up. e.g.,\n\n  if syscall.Getuid() !\u003d 0 {\n    create(\"/tmp/foo\")\n    // Don\u0027t need to chown!\n  } else {\n    // Change owner to the non-root user.\n    fd :\u003d create(\"/tmp/foo\")\n    fchown(fd, \"unpriv-user\")\n  }\n  \nEven with STW, this code is incorrect when racing with syscall.Setuid, as the UID may change to non-root after Getuid but before create(). Then it would even up missing the chown.\n\nIt could be fixed by moving Getuid after create (assuming Setuid is called only exactly once). But much better would be for applications that depend on changes to UID to add a lock serializing access to the state. If that was done, then whether or not we do STW wouldn\u0027t matter.",
      "parentUuid": "d5401d8c_ca77ead1",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "28ece467_0cb56ebd",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 810,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T22:57:40Z",
      "side": 1,
      "message": "Resolving as there is nothing explicitly to be done here.",
      "parentUuid": "ee277d74_f101bbce",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64bee0b1_3521b65d",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 820,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "This logic tripped both you and me up a while ago. :) Can we reverse the loop nesting so the outer loop goes over allm and the inner loop osyields until mp.needPerThreadSyscall is 0?",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16eda57e_9c1f56bf",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 820,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "64bee0b1_3521b65d",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3479ff1d_e190bd72",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 848,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-14T17:53:05Z",
      "side": 1,
      "message": "Same comment about r2 on ppc64.",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "454dbc9a_b3f5029a",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2023,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "This isn\u0027t quite right. Since we acquire it in read mode for allocm, it doesn\u0027t serialize the *creation* of Ms. It\u0027s more like acquiring it in write mode blocks the creation of new Ms or something.",
      "range": {
        "startLine": 2023,
        "startChar": 15,
        "endLine": 2023,
        "endChar": 45
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2274216_c7599a40",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2023,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "454dbc9a_b3f5029a",
      "range": {
        "startLine": 2023,
        "startChar": 15,
        "endLine": 2023,
        "endChar": 45
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "369b59a6_826901aa",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2061,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "\"created by\"?",
      "range": {
        "startLine": 2061,
        "startChar": 60,
        "endLine": 2061,
        "endChar": 72
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db7a2489_9b1c9531",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2061,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "\"a new M\"?",
      "range": {
        "startLine": 2061,
        "startChar": 16,
        "endLine": 2061,
        "endChar": 22
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0af93408_03326914",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2061,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "369b59a6_826901aa",
      "range": {
        "startLine": 2061,
        "startChar": 60,
        "endLine": 2061,
        "endChar": 72
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6350a4d1_ccd2c512",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2061,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "db7a2489_9b1c9531",
      "range": {
        "startLine": 2061,
        "startChar": 16,
        "endLine": 2061,
        "endChar": 22
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b59110b_aae01dc4",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2067,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "I was really confused the first time I read this. I thought you were saying this acquirem would prevent the *new* thread from stopping until it started and became signal-able. Coming back here after reading your comment in doAllThreadsSyscall, I think you\u0027re just saying that newm itself needs to not be preempted between allocm and newm1, which makes a lot more sense.",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81703371_ed66f9ef",
        "filename": "src/runtime/proc.go",
        "patchSetId": 6
      },
      "lineNbr": 2067,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "I\u0027ve changed this to try to state that most explicitly.",
      "parentUuid": "0b59110b_aae01dc4",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41835430_5bb99edf",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 6
      },
      "lineNbr": 619,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "Update the documentation on sigPreempt to mention that it\u0027s also used for all-threads syscalls.",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c74e4c2e_620b2e02",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 6
      },
      "lineNbr": 619,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "41835430_5bb99edf",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3844035f_43bb0ef6",
        "filename": "src/syscall/syscall_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 977,
      "author": {
        "id": 5167
      },
      "writtenOn": "2022-02-10T15:03:09Z",
      "side": 1,
      "message": "No longer true",
      "range": {
        "startLine": 976,
        "startChar": 65,
        "endLine": 977,
        "endChar": 8
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5b747436_11bba6cb",
        "filename": "src/syscall/syscall_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 977,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-11T17:59:36Z",
      "side": 1,
      "message": "It is now (see agm@\u0027s comment)",
      "parentUuid": "3844035f_43bb0ef6",
      "range": {
        "startLine": 976,
        "startChar": 65,
        "endLine": 977,
        "endChar": 8
      },
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}