{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dacfc33c_8317bfa8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T22:52:23Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "f3637855_626ab938",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93ba0ad2_1cc41f23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T22:52:23Z",
      "side": 1,
      "message": "SlowBots beginning. Status page: https://farmer.golang.org/try?commit\u003dd56c4974",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bcf33e6_1f71c784",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T23:03:32Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003dd56c4974\nFailed on linux-amd64-nocgo: https://storage.googleapis.com/go-build-log/d56c4974/linux-amd64-nocgo_6b21bb27.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "93ba0ad2_1cc41f23",
      "tag": "autogenerated:trybots~progress",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23371f42_8431dace",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-02-08T23:05:51Z",
      "side": 1,
      "message": "1 of 29 SlowBots failed.\nFailed on linux-amd64-nocgo: https://storage.googleapis.com/go-build-log/d56c4974/linux-amd64-nocgo_6b21bb27.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\nSlowBot builds that ran:\n* linux-amd64-nocgo\n",
      "parentUuid": "93ba0ad2_1cc41f23",
      "tag": "autogenerated:trybots~failed",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1232113d_575165e0",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-08T23:43:22Z",
      "side": 1,
      "message": "Won\u0027t this deadlock if a thread is already executing a signal handler? IIRC this is what the signal test was testing for and why the current implementation has an mDoFixupAndOSYield().",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70538955_7931d131",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T17:47:54Z",
      "side": 1,
      "message": "I don\u0027t think so.\n\nhttps://go-review.googlesource.com/c/go/+/305149/9/src/runtime/sigqueue.go ran into trouble because sigsend would spin in the signal handler waiting for the signal_recv goroutine to change state back to sigIdle.\n\nWith this CL, sigFixup is gone completely and sigsend should no longer spin indefinitely. It can now loop only if it loses a CAS race, which it should eventually win.\n\nI\u0027m not aware of anywhere else that signal handlers can block indefinitely.",
      "parentUuid": "1232113d_575165e0",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b127b12_23e9f692",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-09T21:11:20Z",
      "side": 1,
      "message": "So this code runs without stop the world and that changes the dynamics somewhat.\n\nWhen I added that sigFixup code it was to account for the fact that the spinning thread couldn\u0027t complete until another thread was able to receive the data the in-signal-handler thread was trying to forward. This couldn\u0027t happen because the world was stopped. This meant we could neither receive signals on the code running this present function - while spinning it would be unable to start the world again, and I had to find a way to execute the fixup code from whatever that asynchronous signal handler was spinning doing.\n\nBoth of those two things are not present here. Are we saying that because the world isn\u0027t stopped, the runtime can happily schedule one of the running Ms to execute that code and unblock the signal handler M?",
      "parentUuid": "70538955_7931d131",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "376c7652_a3d1845b",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 796,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T22:34:10Z",
      "side": 1,
      "message": "I think too many subsequent issues are getting confused here.\n\nTaking a look at the initial CL 277434 which added the initial sigqueue, the problem was that the M running signal_recv was blocked in notetsleepg, thus preventing the fixup from completely [1].\n\nThat CL kicked the note so that M could reach the fixup in exitsyscall -\u003e gcstopm.\n\nBut it needed to do something about the signal handler sigsend, which couldn\u0027t handle state sigFixup, so it added the osyield() loop waiting for sigIdle, which introduced the deadlock possibility.\n\nWithout sigFixup, this problem no longer applies.\n\nPut another way, let\u0027s look at what the signal handler does for each state:\n\nsigIdle: CAS to sigSending, then return\nsigSending: return\nsigReceiving: CAS to sigIdle, then return\n\nThere is no reason for any of those to ever block indefinitely. Yes, CAS is a loop and could fail in the event of a race, but there is no reason for it to fail continuously. If constantly racing with signal_recv or other threads\u0027 signal handler, it probabilistically should eventually win one of those races.\n\n[1] Note that notetsleepg is ironically just a blocking syscall, like we are fixing now: https://cs.opensource.google/go/go/+/master:src/runtime/lock_futex.go;l\u003d235-237;drc\u003df229e7031a6efb2f23241b5da000c3b3203081d6",
      "parentUuid": "6b127b12_23e9f692",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd7a8960_5d387b20",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 803,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-09T21:11:20Z",
      "side": 1,
      "message": "Is there any need to lock the coordinating OS thread in this function? Or is it somehow true implicitly that the M that has already run the initial syscall is guaranteed to still be this one?",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36dd0fb9_386ce6de",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 803,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T22:34:10Z",
      "side": 1,
      "message": "`allocmLock.lock()` implicitly locks us to this M. But perhaps I should also add `acquirem` to make this more explicit.",
      "parentUuid": "fd7a8960_5d387b20",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef070571_a6c67973",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 810,
      "author": {
        "id": 34636
      },
      "writtenOn": "2022-02-09T21:11:20Z",
      "side": 1,
      "message": "I can\u0027t see what stops goroutines migrating from one M to another while this loop is running. If that is possible and, say, we are transitioning from UID0 to UID1, is it possible for some goroutine to transition between them before the loop below completes? That is, a single goroutine observes:\n\n  running with UID0 on m1\n  running with UID1 on m1\n  running with UID0 on m2\n  running with UID1 on m2\n\nIt was to avoid this experience (and never observe the reverse transition) that the old code used stop the world.",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75bdcdd6_b5743600",
        "filename": "src/runtime/os_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 810,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-02-09T22:34:10Z",
      "side": 1,
      "message": "Yes, that is definitely possible. Was that a constraint on the API? I didn\u0027t notice any mention. If we need it, we could add STW back just for that purpose.\n\nThough IMO, goroutines shouldn\u0027t rely on thread state until AllThreadsSyscall returns. Is there a particular case where this visibility causes problems?",
      "parentUuid": "ef070571_a6c67973",
      "revId": "d56c4974bf8163b5a1243c0a8ca8b4c5c3d97fb6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}