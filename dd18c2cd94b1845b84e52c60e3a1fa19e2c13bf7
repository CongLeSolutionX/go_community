{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b310c24f_c8a7bf89",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-08-17T02:48:24Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "fd885116_e67d8772",
      "tag": "autogenerated:trybots~beginning",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e12473b1_984293c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-08-17T02:48:24Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003ddd18c2cd",
      "tag": "autogenerated:trybots~beginning",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9e1199c1_2fca64fc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-08-17T03:14:05Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "e12473b1_984293c6",
      "tag": "autogenerated:trybots~happy",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7bba77a_64d9eab7",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-17T21:59:30Z",
      "side": 1,
      "message": "What\u0027s wrong with just the unconditional set here?",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf0161b1_4832972b",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-18T10:55:08Z",
      "side": 1,
      "message": "If `x.Name()` was called with `SetAddrTakenNoStackObject` before, then unconditional set here will change `nameNeedStackObject` from false to true.",
      "parentUuid": "a7bba77a_64d9eab7",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24bfde0f_a4b89cc9",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-18T21:45:00Z",
      "side": 1,
      "message": "That\u0027s what we want, is it not?\nAnything we pass to markAddrOf should get both flags set.",
      "parentUuid": "cf0161b1_4832972b",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24bfe997_5a5663c8",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-19T12:15:22Z",
      "side": 1,
      "message": "The problem is that we may set n addr taken before we generate \u0026n node. e.g in case of map key, in order.go:mapKeyTemp, we set the tmp key with SetAddrTakenNoStackObject, then in walk/expr.go:mapKeyArg, we generate node address there with typecheck.NodAddr",
      "parentUuid": "24bfde0f_a4b89cc9",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34021772_f0ae38ab",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-19T17:27:52Z",
      "side": 1,
      "message": "What about\n\nm[x] \u003d 5\np \u003d \u0026x\n\nThis correctly handles the map operation, marking x as AddrTaken but not NeedStackObject.  But when we get to p\u003d\u0026x we really want to mark x as needing a stack object. This code doesn\u0027t handle that correctly, I think.\n\nI think mapKeyArg needs to do something special to not mark the address operation it does with NeedStackObject.",
      "parentUuid": "24bfe997_5a5663c8",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9812d1cd_7143bb3c",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-19T18:08:20Z",
      "side": 1,
      "message": "Hmm, I think it does handle that case, because \"p \u003d \u0026x\" is handled at noder step (see noder.go:L774), thus \"x\" is mark addr taken + need stack object before we enter walk pass.",
      "parentUuid": "34021772_f0ae38ab",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d3b748f_0a9a0310",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-20T15:49:30Z",
      "side": 1,
      "message": "Ok, so we\u0027re depending on all the user\u0027s addrtaken operations to be marked before any autotmps are marked. That sounds quite fragile. I think we\u0027d want a mode (kind of like IncrementalAddrTaken) to make sure that we don\u0027t introduce anything that requires stack objects after noder(?).",
      "parentUuid": "9812d1cd_7143bb3c",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ac25c2f_2779d489",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-20T17:38:24Z",
      "side": 1,
      "message": "Is it safe to always use SetAddrTakenNoStackObject after noder?\n\nI tried it out, and the following test now does not show stack object for autotmp anymore:\n\n```\nfunc f11a() *int {\n\tselect { // ERROR \"stack object .autotmp_[0-9]+ \\[2\\]struct\"\n\tcase \u003c-c:\n\t\treturn nil\n\tcase \u003c-c:\n\t\treturn nil\n\t}\n}\n```\n\nI think we still need liveness track here right? (I think the problem is that this CL currently only call markArgAlive for map operation, I think we need to apply it to all builtin call, so this stack object will turn to live at call)",
      "parentUuid": "2d3b748f_0a9a0310",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0290b7b9_35a85415",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-20T17:56:36Z",
      "side": 1,
      "message": "Yes, I think you\u0027re right. We\u0027d have to find all instances of taking the address post-noder and make sure we add the right keepalive for them.\nSounds kinda tricky, but maybe if we make markAddrOf fail after noder, we can be sure to find them all.",
      "parentUuid": "7ac25c2f_2779d489",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f379a611_f8e798d3",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-21T15:03:02Z",
      "side": 1,
      "message": "So I think the safer approach is split into two modes, pre-noder and post-noder. In post-noder, find all places where call markAddrOf, and mark them explicitly there. Subsequent CLs, we can review all instances and incrementally inject proper keep alive for them.\n\nHow do you think?",
      "parentUuid": "0290b7b9_35a85415",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81cbe2ca_ed839c9b",
        "filename": "src/cmd/compile/internal/typecheck/subr.go",
        "patchSetId": 10
      },
      "lineNbr": 88,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-21T15:35:58Z",
      "side": 1,
      "message": "Hmm, this does not work well with unified IR ...",
      "parentUuid": "f379a611_f8e798d3",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b275225f_02b0321c",
        "filename": "src/cmd/compile/internal/walk/walk.go",
        "patchSetId": 10
      },
      "lineNbr": 407,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-17T21:59:30Z",
      "side": 1,
      "message": "I think we would have to handle PPARAM and PPARAMOUT classes as well.\nNot sure about PAUTOHEAP.\n\nOr maybe we only ever call this with autos currently? In which case, an assert that it doesn\u0027t happen would work.",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86ecda7b_a8fa9079",
        "filename": "src/cmd/compile/internal/walk/walk.go",
        "patchSetId": 10
      },
      "lineNbr": 407,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-18T10:55:08Z",
      "side": 1,
      "message": "No, we call this with all kinds of arguments.\n\nI just don\u0027t feel strongly enough handle those cases, would you mind giving me any hints to handle other classes? I will do it in follow up CL.",
      "parentUuid": "b275225f_02b0321c",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35291946_eb375c4e",
        "filename": "src/cmd/compile/internal/walk/walk.go",
        "patchSetId": 10
      },
      "lineNbr": 407,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-18T21:45:00Z",
      "side": 1,
      "message": "I think you would just need to not return for all of PAUTO, PPARAM, and PPARAMOUT.\nPAUTOHEAP is weird, I\u0027d have to think about that one. Maybe we need to mark the underlying PAUTO that points to it as well?",
      "parentUuid": "86ecda7b_a8fa9079",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d35c3acb_555e5bec",
        "filename": "src/cmd/compile/internal/walk/walk.go",
        "patchSetId": 10
      },
      "lineNbr": 407,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-19T12:15:22Z",
      "side": 1,
      "message": "I added a TODO about handling PAUTOHEAP.\n\nDone",
      "parentUuid": "35291946_eb375c4e",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c96c70e_3d120a6c",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-17T21:59:30Z",
      "side": 1,
      "message": "Hm, the whole point here is to make sure x gets a stack object, even if we pass \u0026x to the map routine. But if we\u0027re making a copy into an autotmp first and passing the address of that autotmp, then the careful recording of who needs a stack object and who doesn\u0027t is kind of pointless. The autotmps for map accesses would never need stack objects.\n\nMaybe we can\u0027t arrange to pass the address of a user variable to the map routines?\nConsider this code:\n\npackage main\n\ntype T struct {\n\ta, b int\n}\n\nfunc f(m map[T]bool) {\n\tvar x T\n\tg(\u0026x)\n\tm[x] \u003d true\n}\n\nfunc h(m map[T]bool, p *T) {\n\tg(p)\n\tm[*p] \u003d true\n}\n\n//go:noescape\nfunc g(t *T)\n\nIn f, the compiler makes an autotmp to pass to the map routine. In h, it doesn\u0027t - it passes p directly to the map routine. Maybe something that calls h, and h gets inlined, would cause a situation where the address of something the user declared (and thus could have its address taken in other ways that require a stack object) could happen.",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85ea320c_9f6ff550",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-17T23:03:56Z",
      "side": 1,
      "message": "Yes, this code:\n\nfunc i(m map[T]bool) {\n\tvar x T\n\th(m, \u0026x)\n}\n\npasses the address of x to both g and to mapassign.",
      "parentUuid": "0c96c70e_3d120a6c",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "325f78a0_42d2aa46",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-18T10:55:08Z",
      "side": 1,
      "message": "\u003e The autotmps for map accesses would never need stack objects.\n\nHere\u0027s the map assign, not map accesses, is that still applied?\n\n\u003e In f, the compiler makes an autotmp to pass to the map routine. In h, it doesn\u0027t - it passes p directly to the map routine. Maybe something that calls h, and h gets inlined, would cause a situation where the address of something the user declared (and thus could have its address taken in other ways that require a stack object) could happen.\n\nBut if p was set addr taken before, then call to SetAddrTakenNoStackObject won\u0027t turn the need nameNeedStackObject from false to true, thus I think we are safe?",
      "parentUuid": "85ea320c_9f6ff550",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff3a9755_91af21b2",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-18T21:45:00Z",
      "side": 1,
      "message": "\u003e Here\u0027s the map assign, not map accesses, is that still applied?\n\nI think it is the same situation for both.\n\n\u003e But if p was set addr taken before, then call to SetAddrTakenNoStackObject won\u0027t turn the need nameNeedStackObject from false to true, thus I think we are safe?\n\nYes, it is safe. That\u0027s not what I was trying to describe. Here I was just trying to figure out if it ever happens that we\n 1) take the address of a variable, that the user uses\n 2) take the address of that same variable, for map operations\n\nI think my example in this comment thread demonstrates that yes, that can happen. But it requires some convoluted coding. I\u0027m surprised that it doesn\u0027t happen in the example in this test file. Why does the compiler not just pass \u0026x to the map operation in line 732? (Not to resolve in this CL, except that this test isn\u0027t testing this CL, as the variables are different.)",
      "parentUuid": "325f78a0_42d2aa46",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "928ebbf7_d3701540",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-19T12:15:22Z",
      "side": 1,
      "message": "I think this can be easily fixed. Currently, the autotmp get stack object, because I checked in order.go that:\n\n```\nif ov :\u003d ir.OuterValue(n); ov.Op() !\u003d ir.ONAME || !ov.Name().NeedStackObject() {\n\tif tmpOv :\u003d ir.OuterValue(tmp); tmpOv.Op() \u003d\u003d ir.ONAME {\n\t\ttmpOv.Name().SetAddrTakenNoStackObject()\n\t}\n}\n```\n\nSo here we see x get stack object (\u0026x passed to user function), so autotmp get stack object, too.\n\nWe can change the condition to:\n\n```\nif ov :\u003d ir.OuterValue(n); ov.Op() !\u003d ir.ONAME \u0026\u0026 ov.Name().AddrTaken()\n```\n\nso if x is addr taken, whether or not x get stack object, we can just set tmp with SetAddrTakenNoStackObject.",
      "parentUuid": "ff3a9755_91af21b2",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b95a3fb1_c34cbf26",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 5200
      },
      "writtenOn": "2021-08-19T17:27:52Z",
      "side": 1,
      "message": "Right, if the temp is a separate copy of x, we don\u0027t need to inherit x\u0027s markings.\nBut that\u0027s only safe if addrTemp really returns a new temporary. It doesn\u0027t always, so we have to be careful.",
      "parentUuid": "928ebbf7_d3701540",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c6d0af9d_9e01afff",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-19T18:08:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b95a3fb1_c34cbf26",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a157eb8_30e35454",
        "filename": "test/live.go",
        "patchSetId": 10
      },
      "lineNbr": 732,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-08-19T18:45:14Z",
      "side": 1,
      "message": "Another case is that if \"tmp \u003d\u003d n\", but n itself is an autotmp, then we can make tmp as SetAddrTakenNoStackObject, too.",
      "parentUuid": "c6d0af9d_9e01afff",
      "revId": "dd18c2cd94b1845b84e52c60e3a1fa19e2c13bf7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}