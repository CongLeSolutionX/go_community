{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "49fd455e_e98a8594",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5210
      },
      "writtenOn": "2020-10-06T17:31:25Z",
      "side": 1,
      "message": "I don\u0027t think this is good enough. It\u0027s really easy to fix one specific error scenario, but make it worse in all other cases. What happens if the code is \"struct }\", or \"interface m() }\" etc? The parser will exit the struct/interface parsing functions but then will also be unsynchronized. It\u0027s really hard to get this right for most common cases.\n\nIf writing \"interface\" without \"{}\" is a common case, what should happen is that we recognize it as if it were \"interface{}\" (correct node) but report a parser error. But I am not convinced this is a common case.\n\nI think this needs a) more test cases showing the effect on different code scenarios, b) probably a bit smarter logic in case of a failure.\n",
      "revId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "550469b4_6e8f41d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5210
      },
      "writtenOn": "2020-10-06T17:37:14Z",
      "side": 1,
      "message": "PS: The compiler\u0027s parser is in cmd/compile/internal/syntax/parser.go. It\u0027s a newer version of the code in go/parser and the original parser that was used by the compiler. It has much better error recovery. I believe the better approach would be to borrow as much as we can from the compiler\u0027s error recovery.",
      "parentUuid": "49fd455e_e98a8594",
      "revId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d231ad9b_fb1af216",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 26889
      },
      "writtenOn": "2020-10-08T11:20:07Z",
      "side": 1,
      "message": "Hmm okay, seems interesting. I agree that it\u0027s not solved for all parsing issues. I\u0027ve not come up with cases where it became worse, but that is indeed a possibility. I might be wrong, but isn\u0027t \"interface m() }\" invalid syntax anyways, the current parser fails on that, since it still expects a \"{\" after the \"interface\".\n\nAnyways, I do have a couple questions:\n1) Why are there two parsers? The one in the compiler seems identical to the one in the parser, only having some newer stuff, but in essence, it seems to work the same.\n2) Would it make sense to unify these parsers?\n3) If not, then the solution is to just use the error handling from the compiler parser right?\n\nI\u0027m just trying to figure out what the most logical steps would be, if I\u0027m doing something, I better be helpful ;)",
      "parentUuid": "550469b4_6e8f41d1",
      "revId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa885d22_8f4afbcf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5210
      },
      "writtenOn": "2020-10-09T04:50:56Z",
      "side": 1,
      "message": "This is not the best place to discuss this but here\u0027s the background:\n\n1) The compiler was originally written in C with the parser being generated (yacc). Eventually, the compiler was translated to Go (semi-automatically). At some point I replaced the yacc parser with a more-or-less yacc-version equivalent hand-written Go parser so we could get rid of the dependency on yacc and do many cleanups and simplifications. Further down the road, I completely rewrote the scanner (lexer), parser, and syntax tree and put it into a new package called syntax. The go/parser was written independently, early on, as part of the go/* libraries. Its initial main application was gofmt. There is no connection between the compiler and go/parser (at that time, the compiler was still written in C). The compiler\u0027s parser in the syntax package is the \"next generation\" parser, based on what we learned from the original compiler\u0027s parser and go/parser. They look similar but the syntax package parser is quite a bit faster, easier to use, and produces smaller and less complex ASTs. Ideally we\u0027d like to have just one parser but that\u0027s not so easy to do given backward-compatibility. We could use go/parser in the compiler but that would not permit us to evolve it as we like to (for backward-compatibility); also it\u0027s slower than what we have. Note that one my goals was to have only one parser, which is why the syntax package is a separate package from the compiler and completely independent. It\u0027s internal because we still want to evolve its API. And even if we made it public, all the external tools (gofmt, vet, lint, go/types, gopls, etc.) are based on go/parser, so we cannot simply deprecate it.\n\n2) See 1). Also, several attempts have been made to use the syntax parser underneath go/parser but to maintain the go/parser API for backward-compatibility. It\u0027s not easily possible (the go/parser does more, e.g. it computes scopes etc.).\n\n3) Yes. If we want to \"upgrade\" go/parser, it would be nice to use the syntax package parser code (a suitably adjusted copy of it) as it\u0027s more resilient to errors. Note that \"error handling\" in a hand-written parser is often a bit of a heuristic with lots of fine-tuning over time, and it requires that all parts work together well. Copying just one part of it may work, or it may not. Feel free to give it a shot. But please note this is not urgent, so code reviews may not happen as quickly as you might wish. Just a heads-up.\n\nThanks.",
      "parentUuid": "d231ad9b_fb1af216",
      "revId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one Code-Review+2 is required. Self review is not allowed."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Do-Not-Review",
        "description": {
          "value": "Changes that have DO NOT REVIEW in their commit message are not submittable."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""]}
      },
      "submittabilityExpressionResult": {},
      "overrideExpressionResult": {},
      "patchSetCommitId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Do-Not-Submit",
        "description": {
          "value": "Changes that have DO NOT SUBMIT in their commit message are not submittable."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""]}
      },
      "submittabilityExpressionResult": {},
      "overrideExpressionResult": {},
      "patchSetCommitId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Hold",
        "description": {
          "value": "Changes with a Hold+1 vote are not submittable."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "NOT label:Hold\u003d1"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"NOT label:Hold=1"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Hold=1"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["is:review-enforced_gerrit"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforcement-satisfied_gerrit"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "728a0c2ca3ec6f04e661239e4ac9e3eea7b49a61",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}