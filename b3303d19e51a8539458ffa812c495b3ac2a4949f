{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d5412d73_43e7e87d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 31647
      },
      "writtenOn": "2021-09-07T14:35:45Z",
      "side": 1,
      "message": "Add \u0027Updates #48185\u0027?",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 8
      },
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd138bb2_36100962",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-05T15:14:55Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003db3303d19",
      "tag": "autogenerated:trybots~beginning",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a27639d7_8378137d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-05T15:14:55Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "eaea607b_e096491f",
      "tag": "autogenerated:trybots~beginning",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e7b2b0ab_72c1cf54",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-05T15:26:36Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "bd138bb2_36100962",
      "tag": "autogenerated:trybots~happy",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "da67c7c5_97852113",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5210
      },
      "writtenOn": "2021-09-06T20:44:28Z",
      "side": 1,
      "message": "@rfindley should look at this as he\u0027s made the most recent changes to *Named and has additional pending changes in that space.",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5e084338_ec517def",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 31647
      },
      "writtenOn": "2021-09-07T13:47:40Z",
      "side": 1,
      "message": "This looks superficially fine to me. It should avoid the deadlock, and nothing I\u0027m doing is in conflict with this change.\n\nHowever, it seems like there could be some side effects of this that need to be understood: what is the code-path that leads to re-entrancy, and does that code path use tparams, methods, or underlying? mdempsky@ would probably know.",
      "parentUuid": "da67c7c5_97852113",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1fb2c49e_5449f3c4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-09-07T14:07:11Z",
      "side": 1,
      "message": "\u003e This looks superficially fine to me. It should avoid the deadlock, and nothing I\u0027m doing is in conflict with this change.\n\u003e \n\u003e However, it seems like there could be some side effects of this that need to be understood: what is the code-path that leads to re-entrancy, and does that code path use tparams, methods, or underlying? mdempsky@ would probably know.\n\nSee my comment in the issue for the code that introduce this.\n\nThe problem is the lazy resolution API of types2. In reader2.go:L374, we register \"resolve\" function for various kind of object. for objFunc, we call r.signature -\u003e r.params -\u003e r.param -\u003e r.typ -\u003e r.p.typIdx -\u003e r.doTyp\n\nNow, r.doTyp call types2.Instantiate with some targs, these targs also have the same \"resolve\" function above, so when doing typHash in types2.Instantiate causes the reentrancy issue, if one of the targ is the same as the one is being resolved.\n\nIf you looked at the code in the issue, it\u0027s the arshalers type.",
      "parentUuid": "5e084338_ec517def",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "41b05a76_c2c38867",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 31647
      },
      "writtenOn": "2021-09-07T14:35:45Z",
      "side": 1,
      "message": "Thanks for the analysis.\n\nAfter considering, I no longer think we should make this change as-is. I think we should instead panic on re-entrancy, and fix codepaths that would re-enter.\n\nFor example, in typeHash, we don\u0027t need to format type parameters if we\u0027re hashing (but why are we encountering an uninstantiated parameterized type in typeHash anyway...)?\n\nI think this needs to be further investigated, probably with some fixes to typeHash. If you agree, you could modify this CL to instead produce a useful panic when re-entrancy is detected.\n\n@mdempsky, @gri, do you agree?",
      "parentUuid": "1fb2c49e_5449f3c4",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a88a37bc_6cd84076",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2021-09-07T15:34:03Z",
      "side": 1,
      "message": "\u003e After considering, I no longer think we should make this change as-is. I think we should instead panic on re-entrancy, and fix codepaths that would re-enter.\n\nI\u0027m not sure, but as we provide the \"resolve\" function for lazy resolution, then user is free to do anything, e.g this code go to infinite loop:\n\n```\npkg1.Scope().InsertLazy(\"arshalers\", func() Object {\n\tpkg1.Scope().Lookup(\"arshalers\")\n\t_, err \u003d Instantiate(env, tt.Type(), []Type{O, E}, false)\n\treturn tt\n})\n```\n\n\u003e For example, in typeHash, we don\u0027t need to format type parameters if we\u0027re hashing (but why are we encountering an uninstantiated parameterized type in typeHash anyway...)?\n\nThe document of typHash:\n\n```\n// If typ is a *Named type and targs is not empty, typ is printed as if it were\n// instantiated with targs.\n```\n\nI think it\u0027s reasonable, `T[int]` and `T[int8]` are different.\n\nThe reason can be:\n\n```\ntype Marshalers \u003d arshalers[MarshalOptions, Encoder]\n\ntype MarshalOptions struct {\n\tMarshalers *Marshalers\n}\n```\n\nNote that this is type-checked ok, just panic in process of reconstructing the types2 objects using lazy resolution API.",
      "parentUuid": "41b05a76_c2c38867",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85d62ed5_4e5e323e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 31647
      },
      "writtenOn": "2021-09-07T16:12:01Z",
      "side": 1,
      "message": "\u003e I think it\u0027s reasonable, `T[int]` and `T[int8]` are different.\n\nI was referring to this, where there are no targs.\nhttps://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/types2/typestring.go;l\u003d237;drc\u003d1a9807906df1d1cb9955dfda387b92e03375c0f0\n\nWe actually don\u0027t know whether there are tparams until after loading, so it _is_ reasonable to hit this code path. However, for the purpose of type hashing we don\u0027t need to actually format the TParams (and shouldn\u0027t hit this code path anyway with non-empty TParams, I think). So we can avoid this panic by not checking TParams().Len() if we are hashing.",
      "parentUuid": "a88a37bc_6cd84076",
      "revId": "b3303d19e51a8539458ffa812c495b3ac2a4949f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}