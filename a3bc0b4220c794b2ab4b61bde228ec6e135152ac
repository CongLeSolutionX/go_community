{
  "comments": [
    {
      "key": {
        "uuid": "93cdb9e9_d6a07d1e",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 36
      },
      "lineNbr": 1130,
      "author": {
        "id": 5167
      },
      "writtenOn": "2018-10-23T21:09:19Z",
      "side": 1,
      "message": "t \u003d unscav.removeNode(t) and eliminate p and the logic below?",
      "revId": "a3bc0b4220c794b2ab4b61bde228ec6e135152ac",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b6f5466_f292f18d",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 36
      },
      "lineNbr": 1130,
      "author": {
        "id": 25391
      },
      "writtenOn": "2018-10-25T16:21:47Z",
      "side": 1,
      "message": "it\u0027s unfortunately not quite so simple, and that\u0027s why I did it more explicitly this way in the first place :(\n\nremoveNode returns whatever node is now in the place where the old node was. this means if t is a leaf, then you get back nil. in this particular case, you don\u0027t want nil because that would cause the loop to end prematurely.\n\nhowever, by doing that the logic can simplify a bit. it would look like\n\nt \u003d unscav.removeNode(t)\n...\n// If t was a leaf, start the search again from its parent.\nif t \u003d\u003d nil {\n  t \u003d p\n}\n\nwe don\u0027t need the branch for if p is nil, since in the case where t was the root, removeNode will have handled that for us.",
      "parentUuid": "93cdb9e9_d6a07d1e",
      "revId": "a3bc0b4220c794b2ab4b61bde228ec6e135152ac",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "912d8947_0ed91280",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 36
      },
      "lineNbr": 1130,
      "author": {
        "id": 5167
      },
      "writtenOn": "2018-10-25T16:44:55Z",
      "side": 1,
      "message": "Oh, I see. Okay.\n\nMaybe a cleaner, less assumptiony, abstraction-ier way to do this would be\n\nt2 :\u003d t.pred()\nunsav.removeNode(t)\nt \u003d t2\n\nAnd define (*treapNode).pred to return the predecessor in key order.\n\nIf you also define (*treapNode).succ, then you could make removeNode return nothing again (removing a foot-gun) and convert scavengeTreap into an entirely iterative algorithm.",
      "parentUuid": "4b6f5466_f292f18d",
      "revId": "a3bc0b4220c794b2ab4b61bde228ec6e135152ac",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e40a0ab5_400806e0",
        "filename": "src/runtime/mheap.go",
        "patchSetId": 36
      },
      "lineNbr": 1130,
      "author": {
        "id": 25391
      },
      "writtenOn": "2018-10-25T21:32:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "912d8947_0ed91280",
      "revId": "a3bc0b4220c794b2ab4b61bde228ec6e135152ac",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}