{
  "comments": [
    {
      "key": {
        "uuid": "e3bdfae6_197d75ad",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 20,
      "author": {
        "id": 5186
      },
      "writtenOn": "2015-04-04T15:41:57Z",
      "side": 1,
      "message": "I\u0027ll look at the code but the ragged barrier is useful for more than just the mark phase transitions so should probably be named something like _GCchangephase, quiesce isn\u0027t that good.",
      "revId": "70da7dbd87231404e0afbb640a4e71d7e044e54a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d0aefe64_093e2dde",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 20,
      "author": {
        "id": 5167
      },
      "writtenOn": "2015-04-18T14:41:21Z",
      "side": 1,
      "message": "Sure, but the ragged barrier isn\u0027t the gcphase, it\u0027s forEachP, which is general-purpose. The new phase is important because we need to turn on write barriers on all Ps before we turn on mutator assists on any P. Currently there\u0027s no phase that enables just write barriers without also enabling assists.",
      "parentUuid": "e3bdfae6_197d75ad",
      "revId": "70da7dbd87231404e0afbb640a4e71d7e044e54a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "83143e89_d0056914",
        "filename": "src/runtime/mgc.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 5056
      },
      "writtenOn": "2015-03-31T19:31:59Z",
      "side": 1,
      "message": "Not obvious what this is about. \n\nforEachP(func(*p){}) // make sure each p reaches a safe point\n\nmight be clearer.\nOtherwise put a comment above the if explaining what this check is trying to detect.",
      "revId": "70da7dbd87231404e0afbb640a4e71d7e044e54a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e3bdfae6_f979a1c1",
        "filename": "src/runtime/mgc.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 5186
      },
      "writtenOn": "2015-04-04T15:41:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "83143e89_d0056914",
      "revId": "70da7dbd87231404e0afbb640a4e71d7e044e54a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d0aefe64_2943e972",
        "filename": "src/runtime/mgc.go",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 5167
      },
      "writtenOn": "2015-04-18T14:41:21Z",
      "side": 1,
      "message": "This check was just me being needlessly paranoid about memory ordering, but if something\u0027s going to go wrong with forEachP, it\u0027s not going to be this. You\u0027re right that forEachP(func(*p){}) is fine. It\u0027s as much about GC safe points as it is about memory ordering, but forEachP already ensures (and must ensure) that ordering.",
      "parentUuid": "83143e89_d0056914",
      "revId": "70da7dbd87231404e0afbb640a4e71d7e044e54a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}