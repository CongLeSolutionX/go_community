{
  "comments": [
    {
      "key": {
        "uuid": "ff8d9496_ad2a4631",
        "filename": "src/database/sql/sql.go",
        "patchSetId": 2
      },
      "lineNbr": 1341,
      "author": {
        "id": 6365
      },
      "writtenOn": "2019-07-16T16:42:26Z",
      "side": 1,
      "message": "Is there a particular reason for the resetSession calls to be executed sequentially in the typical case, or for the reset queue to have a fixed capacity? (My general rule is that the useful channel buffer sizes are 0, 1, and “an upper bound on the number of possible work items”, and 50 is not any of those.)\n\nI would instead expect to see a semaphore or some sort of high-water mark guarding the number of idle connections, a sync.WaitGroup or semaphore guarding active connections, and the individual resetSession calls occurring in one-off goroutines rather than a single long-lived background goroutine. Given that it would be helpful to have some more guidance in the code to understand the reasons for the current design.\n\n(This is closely related to the recurring “Start goroutines when you have concurrent work” theme from my GopherCon talk last year.)",
      "revId": "252f1fb9e299e86db9ad09af78da19b5c694ec65",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}