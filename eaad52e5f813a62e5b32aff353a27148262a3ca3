{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "76629c44_b66c54c0",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-05-11T19:09:08Z",
      "side": 1,
      "message": "I\u0027m not sure I understand how the return address works here.\nWhere is the return address of runtime.libfuzzerCallTraceIntCmp stored and restored?\nThe return address starts in R30, but you end up clobbering that register with an address in the sled. The sled needs to know where it should return to somehow.\n\nThe x86 code puts the return address on the stack, so the return address to the sled doesn\u0027t overwrite the overall return address. It just requires some push/pop to use a different stack slot.",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8e6bf8d_18818e85",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 56363
      },
      "writtenOn": "2022-05-12T11:00:19Z",
      "side": 1,
      "message": "You are right. The original return address is not stored before manipulating R30. This is based on the maybe-wrong assumption about how the RET instruction in Go assembly works for ARM. The existing implementation of runtimeÂ·libfuzzerCall calls the original libFuzzer function with a brach with link instruction (BL R9) which also overwrites the R30 with the address of the next instruction. That is why I assumed that the RET instruction takes care of restoring R30 from a value that is pushed on the stack. However, based on your comment and investigating the resulting ARM64 code with objdump, this does not seem the case. Does the existing implementation work? is it tested somehow? Or, have I overseen something?\n\nI\u0027ve updated the implementation to store R30 into a local variable and restore it before returning.",
      "parentUuid": "76629c44_b66c54c0",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e5743d8_e65dd6f8",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-12T21:25:54Z",
      "side": 1,
      "message": "The RET instruction works differently depending on whether the function is leaf (contains a call instruction). For non-leaf functions, the assembler inserts prologue to store the LR on stack, and the RET instruction loads it. This is how the old code works. With the new code, end_of_function is no longer a leaf function (the assembler doesn\u0027t know the new control flow) so RET is just JMP (LR). You could probably write it as loading LR from stack then jump to it, something like\n\nMOVD.P 16(SP), R30 // offset is the frame size, check it with the prologue\nJMP (R30)",
      "parentUuid": "f8e6bf8d_18818e85",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "acc13324_f9c5e929",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-12T21:27:18Z",
      "side": 1,
      "message": "\u003e  end_of_function is no longer a leaf function\n\nno longer a non-leaf function (as it contains no call now)",
      "parentUuid": "1e5743d8_e65dd6f8",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e05f264_033ef49f",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 56363
      },
      "writtenOn": "2022-05-13T15:48:15Z",
      "side": 1,
      "message": "Thanks for the clarification. I\u0027ve updated the code so that the original return address is saved into a local variable that is used to restore the original value of R30 before returning. Could you have a look?",
      "parentUuid": "acc13324_f9c5e929",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b42ebeaf_d50d6f9b",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-13T18:23:56Z",
      "side": 1,
      "message": "This probably will work. But I feel that it is clearer if we use a list of calls, instead of a list of return addresses. I think manually computing the entry address  is easier to follow than computing the return address. Maybe something like\n\nTEXT calls\u003c\u003e(SB),NOSPLIT,$0-0\n  CALL (R9)\n  JMP end\n  CALL (R9)\n  JMP end\n  ... // repeat\nend:\n  RET\n\n\nIn the main function you can just do\n\nMOVD $calls\u003c\u003e(SB), R20 // R20 is an arbitrary scratch register\nADD R8\u003c\u003c3, R20         // add offset*8 (CALL+JMP is 8 bytes)\nCALL (R20)\n\n// old code continues here\nMOVD R19, RSP\nRET",
      "parentUuid": "7e05f264_033ef49f",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78363f8b_f8774d75",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 56363
      },
      "writtenOn": "2022-05-13T21:01:38Z",
      "side": 1,
      "message": "This was one of the ideas I thought about, and it would have a negative impact on the fuzzing performance. With the proposed approach, the return addresses would then have a granularity of 8 bytes (each of the call+jump pairs takes 8 bytes). This means that the three least significant bits would be fixed for all of them. With the JUMP approach, the return addresses have a granularity of 4 bytes. This gives us one more bit that we can we influence with fakePC, and as a result, the value profiling mode of libFuzzer would be more effective.",
      "parentUuid": "b42ebeaf_d50d6f9b",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "34123b47_ba4c7fd7",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-05-17T06:55:41Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "78363f8b_f8774d75",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5db9526f_a66e4af2",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-23T19:14:08Z",
      "side": 1,
      "message": "How many bits of the return PC does libfuzzer use as discriminator? Would it be possible to multiply the fake PC by 4 (or 8) as the offset, instead of just losing the lowest bits?\n\n(As it is already submitted, I think we don\u0027t need to rewrite it to CALL+JMP. But if it works it might be a good idea to multiply the fake PC by 4 and have 512 return addresses as AMD64 does.)",
      "parentUuid": "34123b47_ba4c7fd7",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "148cf429_9ebe1c89",
        "filename": "src/runtime/libfuzzer_arm64.s",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 56363
      },
      "writtenOn": "2022-05-23T21:56:18Z",
      "side": 1,
      "message": "libfuzzer\u0027s value profiling mode only uses the lowest 9 bits of the return address. Could you clarify how multiplying the fakePC by 4 would be better? Isn\u0027t this just shifting the value by two to the left, which also results in the lowest two bits set to zero? The issue I see is that we cannot have return addresses on ARM64 where the lowest two bits are zero.",
      "parentUuid": "5db9526f_a66e4af2",
      "revId": "eaad52e5f813a62e5b32aff353a27148262a3ca3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}