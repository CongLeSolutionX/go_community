{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fafa24aa_e68ec812",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2024-01-22T12:58:02Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d6990cb22\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "794aaa95_87ceacea",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2024-01-22T13:05:01Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003d6990cb22\nFailed on windows-386-2016: https://storage.googleapis.com/go-build-log/6990cb22/windows-386-2016_0dc2fbc8.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "fafa24aa_e68ec812",
      "tag": "autogenerated:trybots~progress",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c27d338_ab6ea58e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2024-01-22T13:08:34Z",
      "side": 1,
      "message": "1 of 47 TryBots failed.\nFailed on windows-386-2016: https://storage.googleapis.com/go-build-log/6990cb22/windows-386-2016_0dc2fbc8.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\n",
      "parentUuid": "fafa24aa_e68ec812",
      "tag": "autogenerated:trybots~failed",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea8563be_c3f7a8ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6785
      },
      "writtenOn": "2024-01-23T19:12:18Z",
      "side": 1,
      "message": "I\u0027m not sure that this is related to my changes. It does look kind of similar to https://github.com/golang/go/issues/56875 though.",
      "parentUuid": "8c27d338_ab6ea58e",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a2b1ed2_2de6ed43",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6365
      },
      "writtenOn": "2024-01-23T22:01:29Z",
      "side": 1,
      "message": "This feels like it is at the wrong layer. `time.Time` already has support for a higher-precision “monotonic clock” for measuring durations — if we can make that work on Windows too, then it will improve `time.Time.Sub` and `time.Since` for all programs, not just benchmarks.\n\nI see in https://go.dev/issue/31160#issuecomment-612584400 that Alex investigated that possibility in 2020, and found that an implementation using `syscall.Syscall` would make `time.Now` about an order of magnitude slower.\n\nHowever, `time.now` is currently implemented in assembly on `linux/amd64`, and Austin wrote a proof-of-concept change to call `QueryUnbiasedInterruptTime` in assembly in CL 211307. Has anyone investigated the possibility of changing `time.now` to call `QueryPerformanceCounter` from assembly?",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0b67cb0_57c3fd85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6785
      },
      "writtenOn": "2024-01-24T00:07:24Z",
      "side": 1,
      "message": "In principle I agree, if there was a better solution for time.Time then that would be great.\n\nI\u0027m not aware of anyone investigating to call `QueryPerformanceCounter` from assembly. Also, do you mean calling QPC from assembly, or reimplementing QPC in assembly?",
      "parentUuid": "0a2b1ed2_2de6ed43",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfcf718a_71430431",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6785
      },
      "writtenOn": "2024-01-24T10:32:29Z",
      "side": 1,
      "message": "Calling QPC from assembly is 20ns vs current `time.Now` 4ns.\n\n(assuming I got the implementation roughly correct https://github.com/egonelbre/exp/blob/main/bench/qpc/main.s)",
      "parentUuid": "d0b67cb0_57c3fd85",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec66aaf4_324d260a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6365
      },
      "writtenOn": "2024-01-24T16:10:11Z",
      "side": 1,
      "message": "From the numbers on CL 315369, 20ns for `time.Now` seems roughly in line with the timing on Linux (which was reported as 29.8ns there). That seems like a very reasonable cost to pay in exchange for much more accurate monotonic measurements.",
      "parentUuid": "bfcf718a_71430431",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99eeb170_5eeae889",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5070
      },
      "writtenOn": "2024-02-03T07:02:50Z",
      "side": 1,
      "message": "I agree with Bryan. If we will get about 4-5 times slow down in benchmarking from using `time.Now` to `highPrecisionTimeNow`, then it is OK.\n\nAlso, please add new benchmark for `highPrecisionTimeNow` function and run it to show the slow down you see - use `time.Now` as `old` version of that benchmark for comparison. And include the output in the commit message. Maybe provide all benchmarks diffs there.\n\nI also created https://github.com/alexbrainman/goissue31160 that contains my investigations from https://github.com/golang/go/issues/31160#issuecomment-612584400 in case you find these useful.",
      "parentUuid": "ec66aaf4_324d260a",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a4468d9_61e59f0a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5070
      },
      "writtenOn": "2024-02-03T07:20:21Z",
      "side": 1,
      "message": "Adding @quimmuntal@gmail.com and @dagood@microsoft.com in case they have something to add here.",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fef3be8_aeec4d90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6785
      },
      "writtenOn": "2024-02-05T13:09:58Z",
      "side": 1,
      "message": "I added relevant benchmark. I didn\u0027t change `time.Now` behavior yet.\n\nNote, I\u0027m using stdcall1 in runtime, because it reduces the overhead from 80ns (using syscall) to 30ns.\n\nI did not call it directly from assembly, because I\u0027m not certain it\u0027s valid to do so. There\u0027s some extra logic happening in https://github.com/golang/go/blob/master/src/runtime/os_windows.go#L953. The direct call from assembly was ~20ns, https://github.com/egonelbre/exp/blob/main/bench/qpc/main.s, but I didn\u0027t include it in this comparison, because I wasn\u0027t certain it was correct code.\n\nI\u0027m not sure what the implications are replacing INTERRUPT_TIME with QPC in time.Now are. Things I\u0027m wondering about:\n\n1. Are there systems where QPC is significantly slower? (e.g. instead of 20ns it takes 1000ns)\n2. What\u0027s the max measureable duration for QPC and do we need to fallback to \"non-monotonic measurement\" after some time? e.g. if it would measure 100 days, are there going to be any problems?\n3. Is there a reason, other than call overhead, it wasn\u0027t used before?",
      "parentUuid": "99eeb170_5eeae889",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "589b6751_69c5e923",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5070
      },
      "writtenOn": "2024-04-01T05:52:32Z",
      "side": 1,
      "message": "\u003e I added relevant benchmark. I didn\u0027t change `time.Now` behavior yet.\n\u003e \n\u003e Note, I\u0027m using stdcall1 in runtime, because it reduces the overhead from 80ns (using syscall) to 30ns.\n\u003e \n\u003e I did not call it directly from assembly, because I\u0027m not certain it\u0027s valid to do so. There\u0027s some extra logic happening in https://github.com/golang/go/blob/master/src/runtime/os_windows.go#L953. The direct call from assembly was ~20ns, https://github.com/egonelbre/exp/blob/main/bench/qpc/main.s, but I didn\u0027t include it in this comparison, because I wasn\u0027t certain it was correct code.\n\u003e \n\u003e I\u0027m not sure what the implications are replacing INTERRUPT_TIME with QPC in time.Now are. Things I\u0027m wondering about:\n\u003e \n\u003e 1. Are there systems where QPC is significantly slower? (e.g. instead of 20ns it takes 1000ns)\n\u003e 2. What\u0027s the max measureable duration for QPC and do we need to fallback to \"non-monotonic measurement\" after some time? e.g. if it would measure 100 days, are there going to be any problems?\n\u003e 3. Is there a reason, other than call overhead, it wasn\u0027t used before?\n\nMakes sense.\n\nI also don\u0027t have enough time to spend looking at your CL.\n\nSo let\u0027s try to go with your CL as is.\n\nI have not reviewed your CL yet. I would like you to rebase your CL on current tip, in case there are some performance changes there. In particular\n\nhttps://go-review.googlesource.com/c/go/+/562915\n\nThen I will review your CL.\n\nThank you.",
      "parentUuid": "4fef3be8_aeec4d90",
      "revId": "6990cb2279c68d4c5dc1a25fde3d5bd90b9bbdd6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}