{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9ee6e84e_f132906f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-10-26T21:11:34Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003debe5d3eb\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "61b3efc3_7d6f62b4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-10-26T21:30:54Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "9ee6e84e_f132906f",
      "tag": "autogenerated:trybots~happy",
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ba7ed61_4176543a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "So as I understand this CL, the idea is we know the compiler is going to need a lot of memory, so we want to run with minimal GC until we\u0027re using that much; then we want to back off and use GC normally.\n\nThis CL approaches that strategy by continuously tuning GOGC until we\u0027re around the target memory limit, using SetFinalizer as a cue to indicate when the GC has triggered. But I guess there\u0027s some dodginess to GOGC achieving what we want?\n\nCan we take advantage of SetMemoryLimit? For example, how does the strategy implemented in this CL compare to something like:\n\n```\n// set GOGC\u003doff to start, but set GOMEMLIMIT to double our target memory usage.\ndebug.SetGCPercent(-1)\ndebug.SetMemoryLimit(2 * targetUsage)\n\nEachGC(func() bool {\n  var stats runtime.MemStats\n  runtime.ReadMemStats(\u0026stats)\n  \n  if usage :\u003d stats.Sys - stats.HeapReleased; use \u003c targetUsage {\n    return true // live memory is still below targetUsage; check again next GC cycle\n  }\n  \n  // We\u0027ve reached target heap size, with 50% utilization.\n  // Reset GOGC\u003d100 and disable GOMEMLIMIT.\n  debug.SetGCPercent(100)\n  debug.SetMemoryLimit(math.MaxInt64)\n  return false\n})\n```",
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b53dfbc_86ce2d87",
        "filename": "src/cmd/compile/internal/base/base.go",
        "patchSetId": 10
      },
      "lineNbr": 35,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "Could abstract as:\n\n```\n// EachGC calls fn each GC cycle until it returns false.\nfunc EachGC(fn func() bool) {\n  type T [32]byte // large enough to avoid runtime\u0027s tiny object allocator\n  \n  var finalizer func(*T)\n  finalizer \u003d func(p *T) {\n    if fn() {\n      runtime.SetFinalizer(p, finalizer)\n    }\n  }\n  \n  finalizer(new(T))\n}\n```",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 35,
        "endChar": 1
      },
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2bce33b_61c5adae",
        "filename": "src/cmd/compile/internal/base/base.go",
        "patchSetId": 10
      },
      "lineNbr": 42,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "Can we make this a base.Debug flag instead?",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 42,
        "endChar": 47
      },
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "562bae90_54b5c252",
        "filename": "src/cmd/compile/internal/base/base.go",
        "patchSetId": 10
      },
      "lineNbr": 47,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "nit: Replace with go.dev/issue/NNN link to actual issue?",
      "range": {
        "startLine": 47,
        "startChar": 51,
        "endLine": 47,
        "endChar": 61
      },
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27b80fc8_428d1752",
        "filename": "src/cmd/compile/internal/base/base.go",
        "patchSetId": 10
      },
      "lineNbr": 51,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "Should probably add:\n\n```\nif CompilerBootstrap {\n  return // avoid assumptions about GOROOT_BOOTSTRAP toolchain\u0027s GC\n}\n```",
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eeb6ebf7_a61d6c06",
        "filename": "src/cmd/compile/internal/base/base.go",
        "patchSetId": 10
      },
      "lineNbr": 91,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "Why do we use currentGoal here, but max(inUse, startHeapGoal) later?",
      "range": {
        "startLine": 91,
        "startChar": 37,
        "endLine": 91,
        "endChar": 48
      },
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d403db1a_ada129a4",
        "filename": "src/cmd/compile/internal/base/base.go",
        "patchSetId": 10
      },
      "lineNbr": 98,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "I expect this is safe in practice, but theoretically the uses of `sample` here race with the uses in the SetFinalizer call back?\n\nEasy fix would be:\n\n```\nif logHeapTweaks {\n  sample :\u003d append([]metric.Sample(nil), sample...) // avoid races with GC callback\n  AtExit(func() { ... })\n}\n```",
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86675af4_d94998f1",
        "filename": "src/cmd/compile/internal/base/base.go",
        "patchSetId": 10
      },
      "lineNbr": 125,
      "author": {
        "id": 5440
      },
      "writtenOn": "2022-10-27T22:26:36Z",
      "side": 1,
      "message": "Sorry, I don\u0027t understand this comment/code.\n\nE.g., what does it mean that inUse is not the same as goal? Why would we expect them to be the same? (My naive expectation is that inUse would naturally fluctuate, and the GC is trying to keep it close to the goal.)\n\nAlso, what steady-state assumptions are we talking about here? And why do we lower-bound inUse with startHeapGoal?",
      "range": {
        "startLine": 119,
        "startChar": 0,
        "endLine": 125,
        "endChar": 3
      },
      "revId": "ebe5d3ebc8ffb8c840d7f2cc75cbc546cb26797a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}