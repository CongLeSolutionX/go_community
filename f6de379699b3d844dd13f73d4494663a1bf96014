{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "db12c715_e83e0263",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-24T15:30:49Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003df6de3796\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a9e6e31c_a842d3e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-24T15:42:36Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "db12c715_e83e0263",
      "tag": "autogenerated:trybots~happy",
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e29cbe1_4b1dd3e0",
        "filename": "src/cmd/compile/internal/types2/unify.go",
        "patchSetId": 7
      },
      "lineNbr": 408,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-24T17:47:30Z",
      "side": 1,
      "message": "inexact",
      "range": {
        "startLine": 408,
        "startChar": 25,
        "endLine": 408,
        "endChar": 32
      },
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "885a7c25_bcccece9",
        "filename": "src/cmd/compile/internal/types2/unify.go",
        "patchSetId": 7
      },
      "lineNbr": 408,
      "author": {
        "id": 7392
      },
      "writtenOn": "2023-08-29T21:06:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8e29cbe1_4b1dd3e0",
      "range": {
        "startLine": 408,
        "startChar": 25,
        "endLine": 408,
        "endChar": 32
      },
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f2d164c_3025ea95",
        "filename": "src/cmd/compile/internal/types2/unify.go",
        "patchSetId": 7
      },
      "lineNbr": 421,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-24T17:47:30Z",
      "side": 1,
      "message": "There is still order dependence in this CL.\n\nObserve that the following code is accepted.\n```\ntype A chan int\ntype B chan int\ntype C \u003d chan\u003c- int\n\nfunc F[T any](x, y, z T) {}\n\nfunc main() {\n\tvar a A\n\tvar b B\n\tvar c C\n\tF(c, a, b)\n}\n```\n\nBut change the arguments to `F` to `(a, b, c)`, and it fails. Coincidentally, changing C to `type C \u003d chan int` also fails, because the undirectional channel no longer prevents inferring the named types.\n\nI believe the condition should be `if yd || yn \u0026\u0026 !xd`, in order to have no order dependence (directionality always wins over namedness), but that will change the outcome of successful inference in some cases.",
      "range": {
        "startLine": 421,
        "startChar": 8,
        "endLine": 421,
        "endChar": 37
      },
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "755d8359_e04735fd",
        "filename": "src/cmd/compile/internal/types2/unify.go",
        "patchSetId": 7
      },
      "lineNbr": 421,
      "author": {
        "id": 7392
      },
      "writtenOn": "2023-08-24T23:58:24Z",
      "side": 1,
      "message": "Hm. That condition is not correct, either: for F(a, b, c). With both conditions we infer A for F(a, b, c) which conflicts with B and we get an error.\n\nThere\u0027s no easy way out I think. We may have to start collecting multiple possible types per type parameter. We may be able to get away with two: a named and an unnamed type (corresponding to the fact that inexact unification differs in essentially ignoring a type name). So we keep an unnamed type, and, if present, an (inexactly) matching named type. At the end we select the named type if possible, otherwise the unnamed one.\n\nThinking.",
      "parentUuid": "8f2d164c_3025ea95",
      "range": {
        "startLine": 421,
        "startChar": 8,
        "endLine": 421,
        "endChar": 37
      },
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75ab17ee_dfbfb341",
        "filename": "src/cmd/compile/internal/types2/unify.go",
        "patchSetId": 7
      },
      "lineNbr": 421,
      "author": {
        "id": 7392
      },
      "writtenOn": "2023-08-25T01:01:59Z",
      "side": 1,
      "message": "It may not too bad after all. This only matters for inexact unification. In that case we should be able to simply always work with the underlying types (but remember a defined type if we see one), and for channels, we always select the directed channel. At the end, if inference succeeds, if we remembered a defined type where we inferred an underlying type, we can make the selection based on whether we have channels or not. For channels, a defined directional channel wins, followed by a directional (literal) channel. For other types, the defined type wins (as before). If we see multiple defined types we\u0027ll get an assignment error later, so it doesn\u0027t matter which one we choose (also as before).\n\nThis will require some more changes: we need to replace the current *Type handles with actual handle structs that can remember two types, the underlying and the defined type (if any). That\u0027s an easy and systematic change. Then we have to adjust the logic a bit. That\u0027s more subtle as it may introduce new bugs.\n\nProbably won\u0027t get to this before early next week.",
      "parentUuid": "755d8359_e04735fd",
      "range": {
        "startLine": 421,
        "startChar": 8,
        "endLine": 421,
        "endChar": 37
      },
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d7ee6ea_e96de506",
        "filename": "src/cmd/compile/internal/types2/unify.go",
        "patchSetId": 7
      },
      "lineNbr": 421,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-25T17:02:18Z",
      "side": 1,
      "message": "\u003e Hm. That condition is not correct, either: for F(a, b, c). With both conditions we infer A for F(a, b, c) which conflicts with B and we get an error.\n\nNo, I think we\u0027d infer `chan\u003c-int` in that case because C is directional. But you\u0027re right that there\u0027s a bug: If A and B were _also_ directional, they would overwrite the unnamed directional channel, and inference would fail depending on which was last.\n\nThis is indeed tricky. Too late to change now, but I wonder if it would have been simpler to always infer the \u0027widest\u0027 type.  I guess we could aim for the following heuristic: infer the narrowest type that works?",
      "parentUuid": "75ab17ee_dfbfb341",
      "range": {
        "startLine": 421,
        "startChar": 8,
        "endLine": 421,
        "endChar": 37
      },
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1fa11d58_fe7941fb",
        "filename": "src/cmd/compile/internal/types2/unify.go",
        "patchSetId": 7
      },
      "lineNbr": 421,
      "author": {
        "id": 7392
      },
      "writtenOn": "2023-08-29T21:06:27Z",
      "side": 1,
      "message": "Reworked CL and added more rigorous justification.",
      "parentUuid": "2d7ee6ea_e96de506",
      "range": {
        "startLine": 421,
        "startChar": 8,
        "endLine": 421,
        "endChar": 37
      },
      "revId": "f6de379699b3d844dd13f73d4494663a1bf96014",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}