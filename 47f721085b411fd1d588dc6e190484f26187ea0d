{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "34f8f150_5c96c1ec",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-04-17T15:59:40Z",
      "side": 1,
      "message": "`taggedPointer` appears to support something like 10–11 tag bits on the most restricted platforms. How do we guarantee that a given pollDesc won\u0027t cycle through its tag space before the in-flight errors are reported?",
      "range": {
        "startLine": 15,
        "startChar": 44,
        "endLine": 19,
        "endChar": 14
      },
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95b85b0e_9727a7ee",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-04-17T21:49:04Z",
      "side": 1,
      "message": "We don\u0027t.  We can\u0027t.  But the failure requires 1) a call to netpoll starts, calling epoll_wait (or whatever); 2) one of the descriptors passed to epoll is erroneous, so epoll_wait is going to return immediately with an error; 3) but before it does, we close the erroneous descriptor; 4) then we open and close at least 1024 other descriptors, so that the sequence number wraps around; 5) then we open a file that gets the wrapped sequence number; 6) now, finally, after at least 1025 other system calls, epoll_wait returns; 7) because of the wrapped sequence number, we incorrectly mark a valid descriptor as not pollable.\n\nAnd it\u0027s worth noting that the lowest number of tag bits, on AIX, doesn\u0027t need to use this mechanism.  To date the only case where the problem is known to be possible is Linux, on which we have 19 tag bits except on riscv64, where we have 11.  So, current worst case requires at least 2049 system calls to complete before epoll_wait returns in order to see the problem.\n\nWith the current design I have not yet seen a way to avoid this problem completely.  The problem is that the runtime poller is part of the runtime scheduler and as such has to run entirely independently of the user code that is closing and opening file descriptors.",
      "parentUuid": "34f8f150_5c96c1ec",
      "range": {
        "startLine": 15,
        "startChar": 44,
        "endLine": 19,
        "endChar": 14
      },
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1727c171_73d8b690",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-04-17T15:59:40Z",
      "side": 1,
      "message": "`windows/386` is notable as a 32-bit first-class port that is not Linux, and I am not aware of a proposal to deprecate or remove it.\n\n- Do we have some other solution for netpoll races on 32-bit Windows?\n\n- Have we notified the maintainers of 32-bit secondary ports (`freebsd`, `netbsd`, and `openbsd`) of this problem, and is there some viable hook for them to address it a port-specific way?",
      "range": {
        "startLine": 24,
        "startChar": 44,
        "endLine": 25,
        "endChar": 36
      },
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98d1ea0f_430190b8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-04-17T21:49:04Z",
      "side": 1,
      "message": "This problem can\u0027t happen on Windows, which never calls setEventErr.\n\nIt\u0027s not clear to me that this problem can actually occur on the *BSD systems.  The code path is there but I don\u0027t know that it is ever executed.  We have code in newFile in os/file_unix.go that avoids adding non-pollable files on the *BSD systems.  I don\u0027t know of a similar way to avoid it on Linux.\n\nI tweaked the CL description.",
      "parentUuid": "1727c171_73d8b690",
      "range": {
        "startLine": 24,
        "startChar": 44,
        "endLine": 25,
        "endChar": 36
      },
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97ee6897_2f24e9d6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-14T22:53:15Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "c97c1121_cfba4900",
      "tag": "autogenerated:trybots~beginning",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69d73003_44e7bd88",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-14T22:53:15Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d47f72108\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b33f49fe_c8c83ed8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-14T22:54:21Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "69d73003_44e7bd88",
      "tag": "autogenerated:trybots~beginning",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c442b81d_12902ec5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-14T22:54:21Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d47f72108\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c1b7a220_6d3b4dde",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-04-14T23:03:56Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "c442b81d_12902ec5",
      "tag": "autogenerated:trybots~happy",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b08e7c03_bf886677",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 62274
      },
      "writtenOn": "2023-04-15T11:47:19Z",
      "side": 1,
      "message": "This does NOT fix the issue. There are gaps between fd sequence reads/writes.",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ab10772_f6c8c1ca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-04-15T14:15:52Z",
      "side": 1,
      "message": "Can you expand on the problem?  I don\u0027t yet see it.  Thanks.",
      "parentUuid": "b08e7c03_bf886677",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97fb721a_46377ca6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 62274
      },
      "writtenOn": "2023-04-16T03:35:50Z",
      "side": 1,
      "message": "I added another loop which performs HTTP get in the test, the issue raised again.",
      "parentUuid": "8ab10772_f6c8c1ca",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e25e3b9d_aec905f4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-04-16T06:33:20Z",
      "side": 1,
      "message": "Would it be possible to add the updated test to the issue?  Thanks.",
      "parentUuid": "97fb721a_46377ca6",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f58be122_2f1ed9cd",
        "filename": "src/runtime/netpoll_kqueue.go",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-04-17T15:59:40Z",
      "side": 1,
      "message": "On 64-bit architectures we steal 3 extra low-order bits for tagged pointers. Would it make sense to do the same on 32-bit arches so that we would have a nonzero amount of sequence protection here?",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 68,
        "endChar": 57
      },
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1dce8cc0_9bcc0d61",
        "filename": "src/runtime/netpoll_kqueue.go",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-04-17T21:49:04Z",
      "side": 1,
      "message": "Maybe?  But as noted to date this is not a problem.  Added a comment.",
      "parentUuid": "f58be122_2f1ed9cd",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 68,
        "endChar": 57
      },
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d4c67d6_2f003eb3",
        "filename": "src/runtime/netpoll_kqueue.go",
        "patchSetId": 2
      },
      "lineNbr": 196,
      "author": {
        "id": 6365
      },
      "writtenOn": "2023-04-17T15:59:40Z",
      "side": 1,
      "message": "I don\u0027t understand this comment — do we have reason to suspect that this *doesn\u0027t* \ncause issues on 32-bit platforms?",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd393d88_ce72c60e",
        "filename": "src/runtime/netpoll_kqueue.go",
        "patchSetId": 2
      },
      "lineNbr": 196,
      "author": {
        "id": 5206
      },
      "writtenOn": "2023-04-17T21:49:04Z",
      "side": 1,
      "message": "Yes, per above.",
      "parentUuid": "2d4c67d6_2f003eb3",
      "revId": "47f721085b411fd1d588dc6e190484f26187ea0d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}