{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "95d19693_aad229b5",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-21T19:30:34Z",
      "side": 0,
      "message": "This doesn\u0027t look right. This will leave uninitialized values in the returned slice between len(b)+n and c.",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f7dba963_5f36eb42",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 64033
      },
      "writtenOn": "2023-11-21T23:19:18Z",
      "side": 0,
      "message": "This is an unexported API, which now improves performance by not initializing []byte.\nA similar optimization see https://go-review.googlesource.com/c/go/+/456336, there is a precedent.",
      "parentUuid": "95d19693_aad229b5",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b382b875_ec26646c",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-11-22T00:57:09Z",
      "side": 0,
      "message": "But you could get access to the result via exported API like Bytes() or AvailableBuffer().\nCL 456336 writes every byte of the result of bytealg.MakeNoZero. At least, it should, and if it doesn\u0027t that\u0027s a bug.",
      "parentUuid": "f7dba963_5f36eb42",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb80aba9_c343976f",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 51461
      },
      "writtenOn": "2023-11-22T01:11:40Z",
      "side": 0,
      "message": "`b2 :\u003d bytealg.MakeNoZero(c)[:len(b)+n]` does look problematic here. Might be better understood in context?\n\n```go\n// grow grows the buffer to guarantee space for n more bytes.\n// It returns the index where bytes should be written.\n// If the buffer can\u0027t grow it will panic with ErrTooLarge.\nfunc (b *Buffer) grow(n int) int {\n\tm :\u003d b.Len()\n....\n\tif n \u003c\u003d c/2-m {\n\t\t// We can slide things down instead of allocating a new\n\t\t// slice. We only need m+n \u003c\u003d c to slide, but\n\t\t// we instead let capacity get twice as large so we\n\t\t// don\u0027t spend all our time copying.\n\t\tcopy(b.buf, b.buf[b.off:])\n\t} else if c \u003e maxInt-c-n {\n\t\tpanic(ErrTooLarge)\n\t} else {\n\t\t// Add b.off to account for b.buf[:b.off] being sliced off the front.\n\t\tb.buf \u003d growSlice(b.buf[b.off:], b.off+n)\n\t}\n\t// Restore b.off and len(b.buf).\n\tb.off \u003d 0\n\tb.buf \u003d b.buf[:m+n]\n\treturn m\n}\n```\n\n```go\n// Grow grows the buffer\u0027s capacity, if necessary, to guarantee space for\n// another n bytes. After Grow(n), at least n bytes can be written to the\n// buffer without another allocation.\n// If n is negative, Grow will panic.\n// If the buffer can\u0027t grow it will panic with [ErrTooLarge].\nfunc (b *Buffer) Grow(n int) {\n\tif n \u003c 0 {\n\t\tpanic(\"bytes.Buffer.Grow: negative count\")\n\t}\n\tm :\u003d b.grow(n)\n\tb.buf \u003d b.buf[:m]\n}\n```\n\nThe extra length is used as a buffer, as it is always overwritten.",
      "parentUuid": "f7dba963_5f36eb42",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "acfd3647_f35e0d88",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 55763
      },
      "writtenOn": "2023-11-22T08:48:40Z",
      "side": 0,
      "message": "Consider this tiny change:\n```\n-       b2 :\u003d bytealg.MakeNoZero(c)[:len(b)+n]\n+       realBytes :\u003d bytealg.MakeNoZero(c)\n+       b2 :\u003d realBytes[:len(b)+n]\n        copy(b2, b)\n+       // scrub\n+       for scrub :\u003d realBytes[len(b)+n:]; len(scrub) \u003e 0; scrub \u003d scrub[copy(scrub, \"theses are bad bytes and have not been initialized\"):] {\n+       }\n```\nThis write a string to the uninitialised bytes to ensure we don\u0027t accidentally get zeros because the pages have not be filled by the OS yet or something else like that.\n\nThen I am able to write this code:\n```\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\nconst smallBufferSize \u003d 64\n\nfunc main() {\n\tvar buf bytes.Buffer\n\tvar zeros [smallBufferSize]byte\n\tfor i :\u003d 19; i !\u003d 0; i-- {\n\t\tbuf.Write(zeros[:])\n\t}\n\tunderlying :\u003d buf.Bytes()\n\tfmt.Println(string(underlying[:cap(underlying)][len(underlying):]))\n}\n```\nWhich when run shows:\n```\n\u003e go run /tmp/a.go\ne not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are bad bytes and have not been initializedtheses are\n```\nAs Keith pointed out you can access the uninitialized bytes without using `unsafe` through `.Bytes`.\nThis is an issue in `Buffer.ReadFrom` and I guess other methods too.",
      "parentUuid": "cb80aba9_c343976f",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "435062ec_f3b299c8",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 51461
      },
      "writtenOn": "2023-11-23T10:46:21Z",
      "side": 0,
      "message": "I understand, it\u0027s an unsafe practice, and one point of doubt I have is, under what circumstances would data outside of len be accessed?\n\nMaybe someone will use it that way?\n\n\n```\n// grow grows the buffer to guarantee space for n more bytes.\n// It returns the index where bytes should be written.\n// If the buffer can\u0027t grow it will panic with ErrTooLarge.\nfunc (b *Buffer) grow(n int) int {\n\tm :\u003d b.Len()\n\t// If buffer is empty, reset to recover space.\n\tif m \u003d\u003d 0 \u0026\u0026 b.off !\u003d 0 {\n\t\tb.Reset()\n\t}\n\t// Try to grow by means of a reslice.\n\tif i, ok :\u003d b.tryGrowByReslice(n); ok {\n\t\treturn i\n\t}\n\tif b.buf \u003d\u003d nil \u0026\u0026 n \u003c\u003d smallBufferSize {\n\t\tb.buf \u003d make([]byte, n, smallBufferSize)\n\t\treturn 0\n\t}\n\tc :\u003d cap(b.buf)\n\tif n \u003c\u003d c/2-m {\n\t\t// We can slide things down instead of allocating a new\n\t\t// slice. We only need m+n \u003c\u003d c to slide, but\n\t\t// we instead let capacity get twice as large so we\n\t\t// don\u0027t spend all our time copying.\n\t\tcopy(b.buf, b.buf[b.off:])\n\t} else if c \u003e maxInt-c-n {\n\t\tpanic(ErrTooLarge)\n\t} else {\n\t\t// Add b.off to account for b.buf[:b.off] being sliced off the front.\n\t\tb.buf \u003d growSlice(b.buf[b.off:], b.off+n)\n\t}\n\t// Restore b.off and len(b.buf).\n\tb.off \u003d 0\n\tb.buf \u003d b.buf[:m+n]\n\treturn m\n}\n```\n\n\nFollowing `copy(b.buf, b.buf[b.off:])` will actually produce unsafe data.\n\n\nhttps://go.dev/play/p/vyf76FzMUAg\n\n```\nfunc main() {\n\tb :\u003d Repeat([]byte{\u0027x\u0027}, 713)\n\tr :\u003d NewBuffer(nil)\n\tfmt.Println(\"cap1\", cap(r.Bytes()))\n\tfmt.Println(\"len1\", len(r.Bytes()))\n\tr.Grow(1280)\n\tfmt.Println(\"cap2\", cap(r.Bytes()))\n\tfmt.Println(\"len2\", len(r.Bytes()))\n\tr.Write(b)\n\tfmt.Println(\"cap3\", cap(r.Bytes()))\n\tfmt.Println(\"len3\", len(r.Bytes()))\n\tr.Read(make([]byte, 695))\n\tfmt.Println(\"cap3\", cap(r.Bytes()))\n\tfmt.Println(\"len3\", len(r.Bytes()))\n\tr.Grow(610)\n\tfmt.Println(\"cap4\", cap(r.Bytes()))\n\tfmt.Println(\"len4\", len(r.Bytes()))\n\tunderlying :\u003d r.Bytes()\n\tfmt.Println(underlying[:cap(underlying)][len(underlying):])\n}\n```",
      "parentUuid": "acfd3647_f35e0d88",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cebe99f5_32b0c66d",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 55763
      },
      "writtenOn": "2023-11-23T10:59:37Z",
      "side": 0,
      "message": "\u003e under what circumstances would data outside of len be accessed?\n\nand that is how we got C.\n\nJokes aside, go is a memory safe language, I don\u0027t want to know what is the impact of leaking random heap garbage because I wrote some buggy code.\n\n---\n\nI don\u0027t understand https://go.dev/play/p/vyf76FzMUAg, it\u0027s what you wrote back in the buffer, this is less bad than private TLS keys or something else crazy.\n\n---\n\nI think you could make this work if you harden bytes.Buffer such that never leaks unused capacity to the consumer. Mainly adding `[:len(buf):len(buf)]` before leaking referenced to the buffer.",
      "parentUuid": "435062ec_f3b299c8",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37b69c7f_06246e6b",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 51461
      },
      "writtenOn": "2023-11-23T11:27:45Z",
      "side": 0,
      "message": "Acknowledged, It\u0027s a lack of consideration on my part. Thank you very much, I\u0027ll see if there is another solution, if not will close CL",
      "parentUuid": "cebe99f5_32b0c66d",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be3b9adc_9ac4922e",
        "filename": "src/bytes/buffer.go",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 64033
      },
      "writtenOn": "2023-11-24T09:29:14Z",
      "side": 0,
      "message": "Can this be resolved by modifying the API setting capacity that returns slice references, for example:\nfunc (b *Buffer) Bytes() []byte { return b.buf[b.off::len(b.buf] }",
      "parentUuid": "37b69c7f_06246e6b",
      "revId": "dc094f9c9613a2a8ed24ace1b5416170aa3a334b",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}