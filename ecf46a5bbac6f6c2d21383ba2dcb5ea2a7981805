{
  "comments": [
    {
      "key": {
        "uuid": "9e66f5d1_7002f026",
        "filename": "src/cmd/compile/internal/ssa/gen/RISCV64.rules",
        "patchSetId": 1
      },
      "lineNbr": 417,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-04-27T17:43:21Z",
      "side": 1,
      "message": "These also suffer from the high-order-bits-are-not-zero problem.\nFor instance, on amd64 a bool in a register has a low byte of 0 or 1. The other bytes in the register are junk.\n\nWe can make a different choice for RISCV64, of course. But we need to do it explicitly and check that all the boolean rules then generate full-register values.",
      "revId": "ecf46a5bbac6f6c2d21383ba2dcb5ea2a7981805",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0e32571_a1c7f268",
        "filename": "src/cmd/compile/internal/ssa/gen/RISCV64.rules",
        "patchSetId": 1
      },
      "lineNbr": 417,
      "author": {
        "id": 13640
      },
      "writtenOn": "2020-04-29T20:30:26Z",
      "side": 1,
      "message": "I do not believe this an issue for booleans on riscv64 - boolean loads are handled via MOVBUload, which is an 8-bit load zero extended to 64 bits. Boolean constants are handled via MOVBconst which results in either 0 or 1 being added to the zero register and sign extended to 64 bits. Unless I\u0027m missing something I do not see how we could end up with garbage in the high bits without being able to mix types.",
      "parentUuid": "9e66f5d1_7002f026",
      "revId": "ecf46a5bbac6f6c2d21383ba2dcb5ea2a7981805",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69e0a5e4_02e62b41",
        "filename": "src/cmd/compile/internal/ssa/gen/RISCV64.rules",
        "patchSetId": 1
      },
      "lineNbr": 417,
      "author": {
        "id": 5200
      },
      "writtenOn": "2020-04-29T20:41:56Z",
      "side": 1,
      "message": "Ok, then we just need to document that booleans occupy entire registers, and are 0 or 1.\n\n(See the Notes section of, say, AMD64Ops.go, and copy+modify what it says about high-order parts of registers.)",
      "parentUuid": "e0e32571_a1c7f268",
      "revId": "ecf46a5bbac6f6c2d21383ba2dcb5ea2a7981805",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "35d14b7f_11669617",
        "filename": "src/cmd/compile/internal/ssa/gen/RISCV64.rules",
        "patchSetId": 1
      },
      "lineNbr": 417,
      "author": {
        "id": 13640
      },
      "writtenOn": "2020-05-01T08:19:31Z",
      "side": 1,
      "message": "Sure, done.",
      "parentUuid": "69e0a5e4_02e62b41",
      "revId": "ecf46a5bbac6f6c2d21383ba2dcb5ea2a7981805",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}