{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2619de7f_95ec53d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-09-29T14:31:08Z",
      "side": 1,
      "message": "That atomic load is needed. The atomic read ensures that future reads by the loser see all the writes done by `f` in the winner.",
      "revId": "1fb214413b28f744c5caee868078c6a4dfe4f1fa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "35bbb721_f4d9139c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 59388
      },
      "writtenOn": "2022-09-30T01:13:19Z",
      "side": 1,
      "message": "Hi,Keith. Thanks for your reply. What do you mean when you say \"future reads by the loser\"?\n\nThere are several cases of losers when atomic store is called by winner:\n\n1. Just enter the Do(): If they don\u0027t use atomic load, they may observe the old value 0. Then, get lock and check o.done \u003d\u003d 0 again.\n2. After atomic load, entering the doSlow and before get lock, the continuous common comparison o.done \u003d\u003d 0 may watch the old value 0? I don\u0027t think so. Otherwise, the f() will be called more than once.\n\nSo what\u0027s the reason the second comparison to zero won\u0027t observe the old value? Because of the previous atomic load? that\u0027s the only reason the atomic load is needed?",
      "parentUuid": "2619de7f_95ec53d4",
      "revId": "1fb214413b28f744c5caee868078c6a4dfe4f1fa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ec61db8a_8a8aa78a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2022-09-30T01:52:53Z",
      "side": 1,
      "message": "I recommend asking this question on golang-nuts.  See https://go.dev/wiki/Questions.\n\nThe atomic load is required so that the goroutine doing the load will see all the opreations by the goroutine that ran the function.  Without an atomic load it may see some but not all of those writes.",
      "parentUuid": "35bbb721_f4d9139c",
      "revId": "1fb214413b28f744c5caee868078c6a4dfe4f1fa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9f5bbaa6_55af5587",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-30T10:41:27Z",
      "side": 1,
      "message": "Sorry to make noise here.\n\n@panzhongxian It\u0027s funny to dig into the commit history of `sync/once.go`. It\u0027s very interesting that the very first version was implemented without the atomic package. See https://github.com/golang/go/commit/895c5db6df786e9312d187f27d6a4538afd4b0b1. `atomic` was later introduced by https://github.com/golang/go/commit/93dde6b0e6c0de50a47f9dc5f3ac7205c36742aa. And there is a simple discussion for this commit about the usage of the `atomic` package: https://codereview.appspot.com/4641066/#msg14\n\nBTW, the change is wrong and won\u0027t be accepted. So please abandon this PR (by closing the PR on github).",
      "parentUuid": "ec61db8a_8a8aa78a",
      "revId": "1fb214413b28f744c5caee868078c6a4dfe4f1fa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4be91566_2f11d4af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 52385
      },
      "writtenOn": "2022-09-30T10:45:29Z",
      "side": 1,
      "message": "Oh, I forgot to mention that https://go.dev/ref/mem states that\n\u003e The preceding definition has the same semantics as C++’s sequentially consistent atomics and Java’s volatile variables.\n\nAnd here is a helpful guide to Java’s volatile keyword: https://www.baeldung.com/java-volatile",
      "parentUuid": "9f5bbaa6_55af5587",
      "revId": "1fb214413b28f744c5caee868078c6a4dfe4f1fa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}