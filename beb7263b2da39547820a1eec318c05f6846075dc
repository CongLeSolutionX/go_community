{
  "comments": [
    {
      "key": {
        "uuid": "90927897_1505ec1c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 25,
      "author": {
        "id": 5070
      },
      "writtenOn": "2019-09-11T09:47:18Z",
      "side": 1,
      "message": "Why do you want to invoke chunked sendFile on the file? We already handle files just fine (see line 22 for details). Why using chunked sendFile is better than current approach?",
      "revId": "beb7263b2da39547820a1eec318c05f6846075dc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03cbb220_4ef1b4c9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 25,
      "author": {
        "id": 5137
      },
      "writtenOn": "2019-09-12T00:36:26Z",
      "side": 1,
      "message": "So in the code structure before this CL and even before the\nprevious ones, if the io.Reader wasn\u0027t an *io.LimitedReader\nwhose underlying reader was an *os.File, we wouldn\u0027t know\nwhat the filesize was.\n\nYou can verify what am talking about by invoking sendFile directly\nwith a big *os.File instead of an *io.LimitedReader and you\u0027ll see that we don\u0027t even check the size n \u003d\u003d 0, which isn\u0027t correct. I guess we haven\u0027t yet used an *os.File directly but this approach simplifies it and I even have a test to verify it -- I\u0027ll delete the test like you had previously requested since it is a heavy one.\n\nThis CL stats the *os.File if it wasn\u0027t passed in as the underlying reader, i.e. sendFile(fd, *os.File)",
      "parentUuid": "90927897_1505ec1c",
      "revId": "beb7263b2da39547820a1eec318c05f6846075dc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67b330a2_ff84549b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 25,
      "author": {
        "id": 5070
      },
      "writtenOn": "2019-09-12T10:03:56Z",
      "side": 1,
      "message": "sendFile function is designed to send all os.File data from current position to the end of file. This works just fine with having n set to 0.\n\nsendFile even goes further to also support os.File wrapped around with io.LimitedReader. In this scenario we also know how many bytes we need to send.\n\nWhat other scenario is not covered? I don\u0027t understand. Please explain again.\n\nSorry if I am slow.\n\nAlex",
      "parentUuid": "03cbb220_4ef1b4c9",
      "revId": "beb7263b2da39547820a1eec318c05f6846075dc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41c1bc08_8444f3f6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 25,
      "author": {
        "id": 5137
      },
      "writtenOn": "2019-09-13T18:32:10Z",
      "side": 1,
      "message": "\u003esendFile function is designed to send all os.File data from current position to the end of file. This works just fine with having n set to 0.\n\nAck.\n\n\u003esendFile even goes further to also support os.File wrapped around with io.LimitedReader. In this scenario we also know how many bytes we need to send.\n\nAck.\n\n\u003eWhat other scenario is not covered? I don\u0027t understand. Please explain again.\n\nIn the case that *os.File isn\u0027t wrapped with io.LimitedReader and that *os.File fileSize is \u003e (1\u003c\u003c31 - 2) TransmitFile will fail.\nThis CL also allows us to examine the fileSize like we did for the *io.LimitedReader but also for *os.File.\nAs I had previously mentioned, you can examine this situation by creating a 3GB file and passing its directly to sendFile e.g.\n\n    f, err :\u003d os.Create(\"testFile.txt\")\n    _ \u003d err // Handle the error\n    n, err, _ :\u003d sendFile(tcpConn.conn.fd, f)\n    if err !\u003d nil {\n        t.Fatalf(\"Failed to sendFile: %v\", err)\n    }",
      "parentUuid": "67b330a2_ff84549b",
      "revId": "beb7263b2da39547820a1eec318c05f6846075dc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58b8e591_ff0cb942",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 25,
      "author": {
        "id": 5070
      },
      "writtenOn": "2019-09-15T01:39:27Z",
      "side": 1,
      "message": "You are correct. Setting n to 0 in net.sendFile does not work, if file is larger than 2G. So we would have to split file into 2 G chunks if we want to use syscall.TransmitFile.\n\nBut how about moving all splitting logic from net.sendFile and into internal/poll.SendFile instead. I think you would end-up with much simple code - just a loop in a internal/poll.SendFile. What do you think?",
      "parentUuid": "41c1bc08_8444f3f6",
      "revId": "beb7263b2da39547820a1eec318c05f6846075dc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5e6cf11_f8f82a3c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 25,
      "author": {
        "id": 5137
      },
      "writtenOn": "2019-09-15T07:41:06Z",
      "side": 1,
      "message": "Cool, thanks for checking and verifying :)\n\nGreat idea, I\u0027ve done so. PTAL!",
      "parentUuid": "58b8e591_ff0cb942",
      "revId": "beb7263b2da39547820a1eec318c05f6846075dc",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}