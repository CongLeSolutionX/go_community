{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d9788ec4_d8e28895",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 61858
      },
      "writtenOn": "2023-03-28T02:13:30Z",
      "side": 1,
      "message": "Can I have a review for this? This facilitates us to add more loop opts that depends on loop invariant. Thanks.",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "410a3f87_0d4364d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-03-28T06:58:51Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d424efd10\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be83e938_b1e91f61",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-03-28T07:09:26Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "410a3f87_0d4364d7",
      "tag": "autogenerated:trybots~happy",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9417fccc_115291ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 7061
      },
      "writtenOn": "2023-03-28T08:52:54Z",
      "side": 1,
      "message": "I\u0027m on vacation till Friday, will look at it then.  I\u0027d like to benchmark more thoroughly; we\u0027ve tried this in the past and didn\u0027t get great results, but perhaps your approach is better.",
      "parentUuid": "d9788ec4_d8e28895",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e279b19f_d640079d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 7061
      },
      "writtenOn": "2023-04-03T18:26:48Z",
      "side": 1,
      "message": "Results of additional benchmark (the \"bent\" suite): https://perf.golang.org/search?q\u003dupload:20230401.1\n\nIt\u0027s not super compelling on amd64.  My usual arm64 benchmark box is down, I will try to look into that later today.",
      "parentUuid": "9417fccc_115291ec",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f6f57c44_b3c244ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 7061
      },
      "writtenOn": "2023-04-05T15:48:38Z",
      "side": 1,
      "message": "Sorry for the delay, but arm64 (ODroid N2, restricted to \"big\" processors) was also not compelling: https://perf.golang.org/search?q\u003dupload:20230405.2",
      "parentUuid": "e279b19f_d640079d",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2dee896a_86662540",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 55253
      },
      "writtenOn": "2023-04-05T15:59:12Z",
      "side": 1,
      "message": "hello my friend can help me",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "335376e9_7c8d8a74",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 61858
      },
      "writtenOn": "2023-07-29T07:19:40Z",
      "side": 1,
      "message": "After further consideration and comparing with other compilers, I believe that to achieve expected performance, we need to hoist only meaningful values, with the most important being load/store/call. However, hoisting them requires guaranteeing that the loop executes at least once, which may require additional loop rotation as a prerequisite for LICM. In addition, we may need simple alias analysis, as hoisting call/store is almost impossible without it.",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd237975_0bc274a3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 61858
      },
      "writtenOn": "2023-07-30T04:54:45Z",
      "side": 1,
      "message": "Im trying to revive this..\n\nMore clarification:\n\n1. Only hoist/sink profitable Value\nIn short, hoist one Load \u003e 100 arithmetic ops\n\nLLVM and JVM carefully selects candidate values\n\n- https://github.com/openjdk/jdk/blob/ad34be1f329edc8e7155983835cc70d733c014b8/src/hotspot/share/c1/c1_ValueMap.cpp#L400\n- https://github.com/llvm/llvm-project/blob/989a5feb2ca7d3f63db6c3c33590cfd7596724a8/llvm/lib/Transforms/Scalar/LICM.cpp#L1104\n\n2. Loop rotation or loop guard as prerequisite\n\n```\nfunc foo(arr []int, cnt int) {\n\tr :\u003d 0\n\tfor i\u003d0;i\u003ccnt;i++{\n\t\tr +\u003d arr[5]\n\t}\n}\n```\nWe can speculatively hoist arr[5] only if we can prove loop is executed at least once. We can either insert a loop guard or run loop rotate pass in advance.\n\nGenerally, this is done by loop rotation https://llvm.org/docs/LoopTerminology.html#rotated-loops, i.e.\n\nCurrent loop roate is somewhat different from normal loop rotation, it unconditionally jumps to loop entry.\n\n3. Hoist/Sink Load/Store/Call\n\nTo hoist these values as mush as possible, we can implement a type based alias analysis. For example, according to type based alias analysis result, we can safely hoist arr[5].\n\n```\nfunc foo(arr []int, arrb []int8 cnt int) {\n\tr :\u003d 0\n\tfor i\u003d0;i\u003ccnt;i++{\n\t\tr +\u003d arr[5]\n\t\tarrb[cnt] \u003d int8(5)\n\t\t\n\t}\n}\n```",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d32c4088_87b83d01",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5200
      },
      "writtenOn": "2023-07-30T05:52:45Z",
      "side": 1,
      "message": "\u003e 1. Only hoist/sink profitable Value. In short, hoist one Load \u003e 100 arithmetic ops\n\nI\u0027m not entirely sure what you are asking here. But if I understand then yes, hoisting a load out of a loop might be worth 100 arithmetic ops.\n\n\u003e 2. Loop rotation or loop guard as prerequisite\n\nIn the case you are quoting, yes, we\u0027d have to rotate some part of the first iteration of the loop outside of the loop.\nBut that\u0027s just for your example. This isn\u0027t an issue for the example from #15808.\nI\u0027d like to see what we can do without loop transformations first. Or have in hand real-world examples where loop transformations would help.\n\n\u003e We can speculatively hoist arr[5] only if we can prove loop is executed at least once.\n\nThis is true, but only because the bounds check might fail. If that isn\u0027t an issue, say a load from global, or load from a known non-nil pointer (e.g. loading a value from a closure) then it might still work.",
      "parentUuid": "cd237975_0bc274a3",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ec6071f_b7e9426a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 61858
      },
      "writtenOn": "2023-07-30T07:14:12Z",
      "side": 1,
      "message": "\u003e I\u0027m not entirely sure what you are asking here. But if I understand then yes, hoisting a load out of a loop might be worth 100 arithmetic ops.\n\nNot raising questions, just sync some progress, Maybe I can create issue for this to avoid contaminating subscribers\u0027 timeline\n\n\u003e But that\u0027s just for your example. This isn\u0027t an issue for the example from #15808.\n\u003e I\u0027d like to see what we can do without loop transformations first. Or have in hand real-world examples where loop transformations would help.\n\nAFAIK, the main purpose of loop rotation is that transformed canconcial form can be used for further LICM and other analysises. Any code where the number of loops cannot be determined at compile time can be used as an example. As for why it is necessary to determine that the loop must be executed once, instead of checking whether the load ptr is nil, please refer to the following.\n\n\u003e This is true, but only because the bounds check might fail. If that isn\u0027t an issue, say a load from global, or load from a known non-nil pointer (e.g. loading a value from a closure) then it might still work.\n\nFor store/Call, this is not true even if Ptr is not nil. \n\nExecuting loop transformations first ensures that the program semantics remain unchanged, and the value in the loop is executed as the loop is executed. This will avoid many unexpected things and accidents",
      "parentUuid": "d32c4088_87b83d01",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "612b3258_135f0808",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 61858
      },
      "writtenOn": "2023-07-30T07:19:27Z",
      "side": 1,
      "message": "\u003e I\u0027m not entirely sure what you are asking here. But if I understand then yes, hoisting a load out of a loop might be worth 100 arithmetic ops.\n\nI means, compared with the method of hoisting all remaining values after filtering illegal values of this patch, it may be more appropriate to carefully select high-yield values",
      "parentUuid": "3ec6071f_b7e9426a",
      "revId": "424efd10e85519f943a2a7f510b7ddcd0efcd5cd",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}