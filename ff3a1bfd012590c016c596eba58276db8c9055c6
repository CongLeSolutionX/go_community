{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "910bf6c3_0398a08f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-17T18:50:57Z",
      "side": 1,
      "message": "Thanks Michael. I\u0027ll turn my replies on mprof.go into better comments, and will fix the first-iteration bug in lock_futex.go/lock_sema.go.",
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "548c62ed_b974af4e",
        "filename": "src/runtime/lock_futex.go",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-05-17T17:59:14Z",
      "side": 1,
      "message": "We own the mutex, so `mutex_locked` must always be set, regardless of any updates to head/sleeping, right? Thus I think it would be clearer to say `v \u003d mutex_locked`.\n\nAnd on the first iteration, `v` won\u0027t have `mutex_locked` set at all because it is the value from _before_ locking. But I think the bug below prevents this from causing a correctness issue.",
      "fixSuggestions": [
        {
          "fixId": "07543ac7_ef7df953",
          "description": "prompt_to_edit API",
          "replacements": [
            {
              "path": "src/runtime/lock_futex.go",
              "range": {
                "startLine": 90,
                "startChar": 0,
                "endLine": 91,
                "endChar": 0
              },
              "replacement": "\t\t\t\t\tv \u003d mutex_locked\n"
            }
          ]
        }
      ],
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bbadf787_0f56ccd2",
        "filename": "src/runtime/lock_futex.go",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-17T18:50:57Z",
      "side": 1,
      "message": "Thanks! Will fix.",
      "parentUuid": "548c62ed_b974af4e",
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "28493af9_8a59e944",
        "filename": "src/runtime/lock_futex.go",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-19T06:03:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bbadf787_0f56ccd2",
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ce2d062_92f653c2",
        "filename": "src/runtime/lock_futex.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-05-17T17:59:14Z",
      "side": 1,
      "message": "Won\u0027t this always fail on the first iteration because old is the value of key _before_ we locked it?",
      "range": {
        "startLine": 95,
        "startChar": 20,
        "endLine": 95,
        "endChar": 53
      },
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ccc3ef4_d5bd87f8",
        "filename": "src/runtime/lock_futex.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-17T18:50:57Z",
      "side": 1,
      "message": "Right, will fix.",
      "parentUuid": "0ce2d062_92f653c2",
      "range": {
        "startLine": 95,
        "startChar": 20,
        "endLine": 95,
        "endChar": 53
      },
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "294ef206_b6616654",
        "filename": "src/runtime/lock_futex.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-19T06:03:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3ccc3ef4_d5bd87f8",
      "range": {
        "startLine": 95,
        "startChar": 20,
        "endLine": 95,
        "endChar": 53
      },
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fea3cd2a_ff7d7a78",
        "filename": "src/runtime/mprof.go",
        "patchSetId": 1
      },
      "lineNbr": 593,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-05-17T17:59:14Z",
      "side": 1,
      "message": "How could it still be waiting if this is called when we just successfully locked the mutex? Do you mean it may have been waiting prior to this call and we haven\u0027t consumed the acquireTimes from that wait yet?",
      "range": {
        "startLine": 592,
        "startChar": 55,
        "endLine": 593,
        "endChar": 72
      },
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6853d75_cae8d571",
        "filename": "src/runtime/mprof.go",
        "patchSetId": 1
      },
      "lineNbr": 593,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-17T18:50:57Z",
      "side": 1,
      "message": "Two of the places this is called, yes.\n\nBut lock_sema.go calls this when the thread (at the head of the list, because lock_sema\u0027s wait list is a stack) is woken up for an _attempt_ to grab the lock. But a new thread may have come along and grabbed the lock first, skipping the line.\n\nFor that case, the thread that had been sleeping may fail again to grab the lock, and will need to go to sleep again, and should not modify the acquireTimes in doing so.",
      "parentUuid": "fea3cd2a_ff7d7a78",
      "range": {
        "startLine": 592,
        "startChar": 55,
        "endLine": 593,
        "endChar": 72
      },
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d7d53c6e_d79f8123",
        "filename": "src/runtime/mprof.go",
        "patchSetId": 1
      },
      "lineNbr": 593,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-19T06:03:18Z",
      "side": 1,
      "message": "Done (converted this explanation into a code comment)",
      "parentUuid": "c6853d75_cae8d571",
      "range": {
        "startLine": 592,
        "startChar": 55,
        "endLine": 593,
        "endChar": 72
      },
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab201c07_9267a7cd",
        "filename": "src/runtime/mprof.go",
        "patchSetId": 1
      },
      "lineNbr": 616,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-05-17T17:59:14Z",
      "side": 1,
      "message": "The return is always the same as the input. Why bother returning it?",
      "range": {
        "startLine": 616,
        "startChar": 37,
        "endLine": 616,
        "endChar": 45
      },
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e4f87ec_7117d8d2",
        "filename": "src/runtime/mprof.go",
        "patchSetId": 1
      },
      "lineNbr": 693,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-05-17T17:59:14Z",
      "side": 1,
      "message": "Is this possible? Should it throw?",
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a89c2c03_1aadf5cf",
        "filename": "src/runtime/mprof.go",
        "patchSetId": 1
      },
      "lineNbr": 693,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-17T18:50:57Z",
      "side": 1,
      "message": "When the node at the head of the list acquires the lock (thread A), it needs to update mutex.key in order to remove itself from the list of waiters. Other threads updating the mutex.key -- to push themselves onto the head of the list (thread B) -- can cause that CAS to fail.\n\nThread A needs to try again ... first fixing the list invariants (thread B\u0027s next field will point to thread A, and A\u0027s next field wasn\u0027t modified by removeMutexWaitList, so the singly-linked part of the list is still intact), and then by checking again to see if a CAS is necessary (and successful).",
      "parentUuid": "5e4f87ec_7117d8d2",
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d33f86e_08f59c21",
        "filename": "src/runtime/mprof.go",
        "patchSetId": 1
      },
      "lineNbr": 693,
      "author": {
        "id": 9210
      },
      "writtenOn": "2024-05-19T06:03:18Z",
      "side": 1,
      "message": "The explanation I gave above does not at all describe the problem.\n\nThe real problem is that lock2 is reentrant.\n\nWhen a user goroutine (`getg() \u003d\u003d getg().m.curg`) is in the runtime calling lock2, and when lock2 calls other functions, and if those functions result in a stack move ... the the M\u0027s g0 will find some memory for the new stack, which involves taking a lock. If that lock is contended, the nested lock2 call will corrupt it.\n\nSo this CL now sets a trap for stack splitting, marks those new functions as `go:nosplit`, and allows this to throw (subject to `verifyMutexWaitList`).",
      "parentUuid": "a89c2c03_1aadf5cf",
      "revId": "ff3a1bfd012590c016c596eba58276db8c9055c6",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}