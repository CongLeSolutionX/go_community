{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "37255a99_d64a6ae3",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 6365
      },
      "writtenOn": "2024-01-08T19:38:48Z",
      "side": 1,
      "message": "I\u0027m a little uncomfortable with arbitrarily increasing this internal only for the test â€” won\u0027t that potentially mask bugs that affect real (non-test) users?\n\nIs there a way to make this more robust without introducing a difference between the test and real configurations?\n\n(On https://github.com/golang/go/issues/64752#issuecomment-1875819512 I suggested that we continue the sleep until `crashing.Load()` stops increasing, which seems like it would allow crashes to complete as long as the program can retire at least one thread per 5s, which feels like it ought to be viable even on a very slow machine.)",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "671889e9_678cc48d",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-01-08T21:24:31Z",
      "side": 1,
      "message": "\u003e (On https://github.com/golang/go/issues/64752#issuecomment-1875819512 I suggested that we continue the sleep until `crashing.Load()` stops increasing, which seems like it would allow crashes to complete as long as the program can retire at least one thread per 5s, which feels like it ought to be viable even on a very slow machine.)\n\nI\u0027m not opposed to this, especially if @zzkcode would like to implement it, though the further we take this the more I feel like we are overengineering an extremely niche part of the runtime.",
      "parentUuid": "37255a99_d64a6ae3",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6762cb16_cde95c89",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 66668
      },
      "writtenOn": "2024-01-09T13:39:59Z",
      "side": 1,
      "message": "Agree that we should not introducing a difference between the test and the real. I would love to implement it, and could you please guide me how to deal with these below? Thanks.\n\n1. I want to keep the low sleep time per loop. However, it seems that this may break this [issue](https://github.com/golang/go/issues/64650) more? Should we deal with this issue in this CL also? How about another flag for counting how many threads go into sleep state, check this flag before the first thread to crash?\n\n2. How could we tell that the crashing stops increasing? Check if equals between loops? Given on a slower enough machine it may hard to know this. Another concern is that if one of the threads failed to receive the SIGQUIT for some reason, the application may get into stuck?",
      "parentUuid": "671889e9_678cc48d",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e69211e5_135e45f8",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 6365
      },
      "writtenOn": "2024-01-09T17:10:20Z",
      "side": 1,
      "message": "\u003e 1. I want to keep the low sleep time per loop. However, it seems that this may break this [issue](https://github.com/golang/go/issues/64650) more? Should we deal with this issue in this CL also? How about another flag for counting how many threads go into sleep state, check this flag before the first thread to crash?\n\nIt should be possible to do both. Perhaps something like:\n\n```go\nconst (\n\tcrashSleepMicros \u003d 5000\n\twatchdogTimeoutMicros \u003d 1000 * crashSleepMicros\n)\nif isCrashThread {\n\t// Sleep for short intervals so that we can crash quickly after\n\t// all ms have received SIGQUIT.\n\t// Reset the timer whenever we see s\n\tmaxCrashing :\u003d crashing.Load()\n\ttimeout :\u003d watchdogTimeoutMicros\n\tfor timeout \u003e 0 \u0026\u0026 (crashing.Load() \u003c mcount()-int32(extraMLength.Load())) {\n\t\tusleep(crashSleepMicros)\n\t\ttimeout -\u003d crashSleepMicros\n\n\t\tif c :\u003d crashing.Load(); c \u003e maxCrashing {\n\t\t\t// We made progress, so reset the watchdog timeout\n\t\t\tmaxCrashing \u003d c\n\t\t\ttimeout \u003d watchdogTimeoutMicros\n\t\t}\n\t}\n} else {\n\tmaxCrashing :\u003d int32(0)\n\tfor c :\u003d crashing.Load(); c \u003e maxCrashing {\n\t\tmaxCrashing \u003d c\n\t\tusleep(watchdogTimeoutMicros)\n\t}\n}\n```\n\n\u003e 2. How could we tell that the crashing stops increasing? Check if equals between loops? Given on a slower enough machine it may hard to know this.\n\nYes, exactly (see above). It shouldn\u0027t depend on machine speed: we add to `crashing` but never subtract from it, so it should increase monotonically.\n\n\u003e Another concern is that if one of the threads failed to receive the SIGQUIT for some reason, the application may get into stuck?\n\nThat\u0027s why we impose the (still arbitrary) upper bound on the amount of time spent sleeping if `crashing` does not increase.",
      "parentUuid": "6762cb16_cde95c89",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee77848b_99f19309",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 66668
      },
      "writtenOn": "2024-01-10T12:54:36Z",
      "side": 1,
      "message": "Thanks. By reset the timeout timer should be a good way to wait for more time. In that case which we encountered in [issue](https://github.com/golang/go/issues/64752), however, my concern is: since the simple crash program in the test case will usually have 5 or 6 Ms in total, and per [build log](https://build.golang.org/log/13a5c81f5b5e0e92e1317db27ca5c0f194fcef31), it seems 4 Ms received SIGQUIT, and the others are still waiting? So would this happened: most of Ms received SIGQUIT in a very short time, and the rests spent most time until timeout? In that case, we may have no chance to reset the timeout timer. So I suggest maybe we extend the `watchdogTimeoutMicros` to double, like 10s?\n\nWill send a CL asap.",
      "parentUuid": "e69211e5_135e45f8",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "119e87dd_99f0351e",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 6365
      },
      "writtenOn": "2024-01-10T17:02:07Z",
      "side": 1,
      "message": "I don\u0027t think the test failure was actually due to the timeout being too short: this looks like a genuine watchdog failure due to a race in the runtime leading to a deadlock.\n\n(I\u0027ve added details in https://go.dev/issue/64752#issuecomment-1885242770.)",
      "parentUuid": "ee77848b_99f19309",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "339e20b9_9920dafa",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 66668
      },
      "writtenOn": "2024-01-11T15:56:18Z",
      "side": 1,
      "message": "Thanks. So it looks like this issue had existed already, and [`let the fault thread to crash process`](https://go-review.googlesource.com/c/go/+/536895) with test just expose this out in some corner cases?",
      "parentUuid": "119e87dd_99f0351e",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2ef8481_04e6fba0",
        "filename": "src/runtime/runtime-gdb_unix_test.go",
        "patchSetId": 5
      },
      "lineNbr": 266,
      "author": {
        "id": 6365
      },
      "writtenOn": "2024-01-11T16:17:54Z",
      "side": 1,
      "message": "I believe so, yes. It looks like the race condition was already present before CL 536895, but the new test has the potential to expose it as a test failure.\n\nIf I understand correctly, prior to that change the race would result in an occasional 5s delay in crashes, but otherwise might not be observable in tests (unless it is responsible for one or more of the other [known `runtime` test flakes](https://github.com/golang/go/issues?q\u003dis%3Aissue+runtime+project%3Agolang%2F20+in%3Atitle+is%3Aopen)).",
      "parentUuid": "339e20b9_9920dafa",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 266,
        "endChar": 36
      },
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f762fe5_08ff0b41",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 5
      },
      "lineNbr": 781,
      "author": {
        "id": 6365
      },
      "writtenOn": "2024-01-09T17:10:20Z",
      "side": 1,
      "message": "(nit) `perLoopSleepTimeUs :\u003d uint32(5000)`\nand then you can drop the individual `uint32` conversions below.",
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "55872b8b_9874fee9",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 5
      },
      "lineNbr": 781,
      "author": {
        "id": 66668
      },
      "writtenOn": "2024-01-10T12:54:36Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "9f762fe5_08ff0b41",
      "revId": "72057cc4e87d30105ff65692c5fac3ae1e1ad5c1",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}