{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0715cc42_f6fa31b0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 7530
      },
      "writtenOn": "2022-03-01T07:11:23Z",
      "side": 1,
      "message": "PTAL, thanks.",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a60e00c4_fdce672e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-03-01T07:11:43Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d08c990e0",
      "tag": "autogenerated:trybots~beginning",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "063cc8de_bbce7e73",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-03-01T07:23:38Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "a60e00c4_fdce672e",
      "tag": "autogenerated:trybots~happy",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aeafdcb1_b0b8d793",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13640
      },
      "writtenOn": "2022-03-01T07:37:25Z",
      "side": 1,
      "message": "Thanks, will review soon - do we have any idea as to the real world benefit of this (i.e. how many fewer instructions do we end up with)?",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3fed4f90_32a30284",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 7530
      },
      "writtenOn": "2022-03-01T07:45:18Z",
      "side": 1,
      "message": "\u003e Thanks, will review soon - do we have any idea as to the real world benefit of this (i.e. how many fewer instructions do we end up with)?\n\nFor 64bit little endian load it will save 8 MOVBUs.\nMost of benchmarks in binary/encoding using big endian however we have to wait for B extension merged to enable big endian loads.",
      "parentUuid": "aeafdcb1_b0b8d793",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f1063ec_5b1ff112",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13640
      },
      "writtenOn": "2022-03-01T07:53:29Z",
      "side": 1,
      "message": "Understood. I\u0027m more interested in how many instructions we remove from a typical binary (or for example, the Go binary or the compile binary - if you don\u0027t have numbers I can check).",
      "parentUuid": "3fed4f90_32a30284",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "de29c7a0_3a4e4d8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 7530
      },
      "writtenOn": "2022-03-01T07:55:50Z",
      "side": 1,
      "message": "Sure ðŸ˜Š\nI\u0027m curious about how to check binary size change.",
      "parentUuid": "1f1063ec_5b1ff112",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82dd919b_9da201b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-03-01T16:07:45Z",
      "side": 1,
      "message": "Combined loads are more likely unaligned. Are unaligned loads very slow? At least on some machines, they are kernel emulated, right?\n",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "514aeb64_9f33388d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13640
      },
      "writtenOn": "2022-03-01T17:01:28Z",
      "side": 1,
      "message": "Correct - there is no requirement to support unaligned accesses in hardware and most unaligned accesses will trap, requiring emulation at some level. We would only want to do this if the resulting load instruction is for a naturally aligned load.",
      "parentUuid": "82dd919b_9da201b7",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "adb90bdb_7bdbae2f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 7530
      },
      "writtenOn": "2022-03-03T07:32:22Z",
      "side": 1,
      "message": "Yes, This CL has good improvment while aligned access, but great regression on unaligned access.\n\n@joel is it possible to set SSA for aligned access at compile-time?\n\nhttps://perf.golang.org/search?q\u003dupload:20220303.7\n\nLittleEndianPutUint16\t236MB/s Â± 1%\t230MB/s Â± 4%\tâˆ’2.78%\t(p\u003d0.000 n\u003d9+10)\nLittleEndianPutUint32\t336MB/s Â± 1%\t338MB/s Â± 0%\t+0.61%\t(p\u003d0.003 n\u003d9+10)\nLittleEndianPutUint64\t523MB/s Â± 1%\t1189MB/s Â± 0%\t+127.35%\t(p\u003d0.000 n\u003d10+9)\nLittleEndianUint16\t184MB/s Â± 7%\t241MB/s Â± 7%\t+31.09%\t(p\u003d0.000 n\u003d10+9)\nLittleEndianUint32\t289MB/s Â± 6%\t406MB/s Â± 7%\t+40.29%\t(p\u003d0.000 n\u003d10+10)\nLittleEndianUint64\t357MB/s Â± 8%\t800MB/s Â±12%\t+124.12%\t(p\u003d0.000 n\u003d10+9)\nLittleEndianUint16Unalign\t105MB/s Â± 9%\t6MB/s Â± 1%\tâˆ’94.40%\t(p\u003d0.000 n\u003d10+9)\nLittleEndianUint32Unaligned\t177MB/s Â± 8%\t9MB/s Â± 2%\tâˆ’94.63%\t(p\u003d0.000 n\u003d10+10)\nLittleEndianUint64Unaligned\t266MB/s Â± 6%\t14MB/s Â± 1%\tâˆ’94.76%\t(p\u003d0.000 n\u003d10+8)",
      "parentUuid": "514aeb64_9f33388d",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3857d2f2_1a194abc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 7530
      },
      "writtenOn": "2022-03-04T03:34:25Z",
      "side": 1,
      "message": "Hi Joel, Cherry, unaligned benchmarks (not in current go) shows arm64 also has 50% regression and unalgined loads shouldn\u0027t happen in real life.",
      "parentUuid": "adb90bdb_7bdbae2f",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5b47d094_1b982536",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-03-07T16:52:52Z",
      "side": 1,
      "message": "Thanks for the benchmark.\n\n\u003e unalgined loads shouldn\u0027t happen in real life\n\nThis is not true. Encoding/decoding code may well read/write a binary-encoded 64-bit value to a byte stream, without requiring alignment (and I know actual code that does this).\n\nThis is also the reason we don\u0027t do this on MIPS and 32-bit ARM. I\u0027d say let\u0027s not do this for now.\n\nOne possibility is to generate combined load when it is aligned, something like\n\nif addr%8 \u003d\u003d 0 { 64-bit load } else { byte by byte load }\n\nBut I\u0027m not sure what the speedup is with the conditional. Also this will be extra complexity in the compiler.",
      "parentUuid": "3857d2f2_1a194abc",
      "revId": "08c990e06660aec5c77c502647b114d0f6fe15e3",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}