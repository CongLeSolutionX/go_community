{
  "comments": [
    {
      "key": {
        "uuid": "61cad4df_491cc504",
        "filename": "src/runtime/asm_ppc64x.s",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 5055
      },
      "writtenOn": "2014-12-23T01:31:49Z",
      "side": 1,
      "message": "could we make the power64 assembly code use arm\u0027s\nexisting naming convention?\n\ne.g.\nMOVD gobuf_g(R5), R3\nBL setg\u003c\u003e(SB) // copy R3 to g and store it in TLS if necessary",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 20
      },
      "revId": "f528d81c52b174710055c6080465d48d5d8916f2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "61cad4df_29722952",
        "filename": "src/runtime/asm_ppc64x.s",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 5167
      },
      "writtenOn": "2014-12-23T01:39:50Z",
      "side": 1,
      "message": "I considered this, but decided not to because the semantics are different.  On arm, the setg\u003c\u003e call is actually setting g based on the value of R3.  But on ppc, you\u0027ve already set g, you just need to do some extra work after you set g.  I\u0027d be inclined to make them consistent the other way around: make arm code set g directly and then call save_g.",
      "parentUuid": "61cad4df_491cc504",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 20
      },
      "revId": "f528d81c52b174710055c6080465d48d5d8916f2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "816348c3_5710ecc2",
        "filename": "src/runtime/asm_ppc64x.s",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 5055
      },
      "writtenOn": "2014-12-23T06:51:42Z",
      "side": 1,
      "message": "Actually, I was thinking about one possible problem of setting\ng before the TLS.\n\nIs it possible that a asynchronous signal comes between we\nupdate g (the register) and the TLS slot? As when cgo is enabled\nsigtramp will always load g from TLS, i think that could potentially\nlead to problem when the g in TLS is wrong (zero, basically).\n\nHow about update g\u0027s TLS slot and then update the g register?\nAnd then ARM\u0027s setg name makes more sense. But I do need to\nchange asm_arm.s.",
      "parentUuid": "61cad4df_29722952",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 20
      },
      "revId": "f528d81c52b174710055c6080465d48d5d8916f2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "816348c3_dad3416a",
        "filename": "src/runtime/asm_ppc64x.s",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 5167
      },
      "writtenOn": "2014-12-23T15:17:10Z",
      "side": 1,
      "message": "Interesting.  However, this isn\u0027t actually a problem on ppc64 (and I assume it isn\u0027t a problem on arm) because rt_sigreturn restores all GPRs from the signal context when sigtramp returns.  Hence, the kernel will take care of restoring g to what it was even if this race does happen (and our \"restore g\" at the end of sigtramp is unnecessary, but *shrug*).",
      "parentUuid": "816348c3_5710ecc2",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 20
      },
      "revId": "f528d81c52b174710055c6080465d48d5d8916f2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}