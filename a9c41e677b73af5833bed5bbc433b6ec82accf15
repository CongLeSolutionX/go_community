{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7fe33ca3_b70ff5cd",
        "filename": "src/crypto/internal/fips/check/check.go",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-11-14T14:53:32Z",
      "side": 1,
      "message": "You can call asanunpoison(addr, size) before fetching the values.  It\u0027s defined in the runtime package.",
      "revId": "a9c41e677b73af5833bed5bbc433b6ec82accf15",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be44c9a9_81960af5",
        "filename": "src/crypto/internal/fips/check/check.go",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 5056
      },
      "writtenOn": "2024-11-15T14:43:57Z",
      "side": 1,
      "message": "Thanks, I didn\u0027t know about that. I added a note to that effect and will come back once I can think more about what exactly that would mean; in particular, does unpoisoning the full range cause false negatives later? Another option would be to have a package that doesn\u0027t get asan instrumentation and have it do the reads into a temporary buffer and then write them into the hash from that buffer.",
      "parentUuid": "7fe33ca3_b70ff5cd",
      "revId": "a9c41e677b73af5833bed5bbc433b6ec82accf15",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "31210478_0998cf15",
        "filename": "src/crypto/internal/fips/check/check.go",
        "patchSetId": 1
      },
      "lineNbr": 82,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-11-15T22:44:34Z",
      "side": 1,
      "message": "Yes, using asanunpoison will mean that asan won\u0027t report invalid accesses that happen to land in the middle of that range.  We could call asanpoison after reading the memory; that would run the risk of causing valid existing pointers to fail, although since we presumably do this early in the execution there may not be any such pointers.\n\nWe could also modify the compiler to permit disabling asan instrumentation in this function.\n\nIn any case doing something seems better than refusing to run the code in ASAN mode.  In fact, we already have go:norace.  And in fact that might already work in ASAN mode, as it seems to apply to instrumentation in general.",
      "parentUuid": "be44c9a9_81960af5",
      "revId": "a9c41e677b73af5833bed5bbc433b6ec82accf15",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57473e35_228df1b5",
        "filename": "src/crypto/internal/fips/check/checktest/test.go",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 11715
      },
      "writtenOn": "2024-11-14T12:03:47Z",
      "side": 1,
      "message": "Are these changes a leftover of an attempt to make it work, or are they needed?",
      "revId": "a9c41e677b73af5833bed5bbc433b6ec82accf15",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dedff710_95a21b44",
        "filename": "src/crypto/internal/fips/check/checktest/test.go",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5056
      },
      "writtenOn": "2024-11-15T15:49:05Z",
      "side": 1,
      "message": "They are needed. This is a weird test since it is trying to test a RODATA symbol directly, whereas normally those are only generated by the compiler. Normal code will not have to do this kind of thing.",
      "parentUuid": "57473e35_228df1b5",
      "revId": "a9c41e677b73af5833bed5bbc433b6ec82accf15",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}