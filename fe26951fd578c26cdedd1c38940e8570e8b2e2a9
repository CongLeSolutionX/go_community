{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "06299f11_21ea8ac9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-04-25T00:50:47Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dfe26951f",
      "tag": "autogenerated:trybots~beginning",
      "revId": "fe26951fd578c26cdedd1c38940e8570e8b2e2a9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0bf784cd_9e57e5e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-04-25T01:06:29Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "06299f11_21ea8ac9",
      "tag": "autogenerated:trybots~happy",
      "revId": "fe26951fd578c26cdedd1c38940e8570e8b2e2a9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf57749e_1d12987b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 7061
      },
      "writtenOn": "2021-04-25T22:39:30Z",
      "side": 1,
      "message": "This CL is required to make the next two work correctly, and appears to also improve the presence of debug information at function/method entry.  \n\nAt the 3rd CL in this repair series, I recorded the last of the entries below, showing improvement from Go-regabi, though still not as with register abi as 1.16 (which was a regression).  I also ran 26 repetitions (successfully) of `./make.bash; GOGC\u003d1 ./run.bash` to look for liveness-related flakes.\n\nThis below shows the history of debugging information quality, which took a notable dip in 1.16 for optimized code (yet nobody complained) and then got further worse with the transition to register args.  There is additional work to do.  The version of optargorder here was enhanced to treat registers as legitimate sources of arguments-at-entrypoint.\n\nI think that further efforts here should be directed at DWARF generation, perhaps special-casing parameters in the prologue/entry.  Tinkering with the SSA names map has interesting side-effects on stack allocation and caused several subtle bugs.\n\n```\ngp go-1.15\n\ngo build . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2839,133,5,0,0,117,0,0.910180\n\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3865,86,0,2,0,5,0,0.975938\n\n\ngp go-1.16 (notable regression for optimized debugging -- but nobody has complained)\n\ngo build . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2430,601,3,1,0,93,246,0.611523\n\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3473,176,0,2,0,5,29,0.938958\n\n\ngp go (before cleanup CLs)\n\ngo build . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2278,805,286,1,90,74,322,0.307287\n\nGOEXPERIMENT\u003dnone go build . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2251,368,6,1,1,78,411,0.615726\n\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3301,468,37,2,38,7,45,0.819146\n\nGOEXPERIMENT\u003dnone go build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3266,161,1,2,1,8,47,0.932639\n\n\ngp go-debug (after cleanup CLs, first try)\n\ngo build . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2278,724,351,1,82,74,151,0.392888\n\nGOEXPERIMENT\u003dnone go build . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2251,232,1,1,1,79,65,0.831630\n\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3301,458,40,2,39,7,11,0.831263\n\nGOEXPERIMENT\u003dnone go build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3266,141,0,2,1,8,4,0.952235\n\n\ngp go-debug (with additional cleanup CLs)\n\n./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2278,724,204,1,54,74,151,0.469710\n\nGOEXPERIMENT\u003dnone go build . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n2251,233,1,1,0,79,51,0.837850\n\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3301,458,31,2,35,7,11,0.835201\n\nGOEXPERIMENT\u003dnone go build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\nnFunctions,argumentError,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n3266,141,0,2,1,8,4,0.952235\n\n( \necho go-1.15\ngp go-1.15 \ngo build . ; ./optargorder ./optargorder\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\necho\necho go-1.16\ngp go-1.16\ngo build . ; ./optargorder ./optargorder\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\necho\necho go \"(tip)\"\ngp go\ngo build . ; ./optargorder ./optargorder\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\necho\necho go \"(tip+CLs)\"\ngp go-debug\ngo build . ; ./optargorder ./optargorder\ngo build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\necho\necho go \"(tip, x\u003dnone)\"\ngp go\nGOEXPERIMENT\u003dnone go build . ; ./optargorder ./optargorder\nGOEXPERIMENT\u003dnone go build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\necho\necho go \"(tip+CLs, x\u003dnone)\"\ngp go-debug\nGOEXPERIMENT\u003dnone go build . ; ./optargorder ./optargorder\nGOEXPERIMENT\u003dnone go build -gcflags\u003dall\u003d-N\\ -l . ; ./optargorder ./optargorder\n)\n```\n",
      "revId": "fe26951fd578c26cdedd1c38940e8570e8b2e2a9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e8d0f7e_83a595a2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-04-27T22:29:16Z",
      "side": 1,
      "message": "\u003e This CL is required to make the next two work correctly,\n\nIn which order do you think the CLs should be submitted, so it doesn\u0027t break build in between? (If it is really hard,  it is probably fine to have a temporary failure.)\n\n\u003e  I also ran 26 repetitions (successfully) of `./make.bash; GOGC\u003d1 ./run.bash` to look for liveness-related flakes.\n\nDid you find any?",
      "parentUuid": "bf57749e_1d12987b",
      "revId": "fe26951fd578c26cdedd1c38940e8570e8b2e2a9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3eb1cf8_b163f56a",
        "filename": "src/cmd/compile/internal/ssa/stackalloc.go",
        "patchSetId": 2
      },
      "lineNbr": 160,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-04-27T22:29:16Z",
      "side": 1,
      "message": "I\u0027m not so sure about this. What happens if the arg is re-assigned in the function body? Like\n\nfunc F(a) {\n  use(a)\n  ...\n  a \u003d something_else\n  use(a)\n}",
      "range": {
        "startLine": 160,
        "startChar": 5,
        "endLine": 160,
        "endChar": 75
      },
      "revId": "fe26951fd578c26cdedd1c38940e8570e8b2e2a9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da3a9ac2_cc8719a8",
        "filename": "src/cmd/compile/internal/ssa/stackalloc.go",
        "patchSetId": 2
      },
      "lineNbr": 190,
      "author": {
        "id": 13315
      },
      "writtenOn": "2021-04-27T22:29:16Z",
      "side": 1,
      "message": "In this function, the parameter is re-assigned within the body. I guess there may be something to do with that. Either the initial input or the re-assigned value takes the named slot, but probably not both at same time (or interleaved life times).",
      "range": {
        "startLine": 190,
        "startChar": 36,
        "endLine": 190,
        "endChar": 80
      },
      "revId": "fe26951fd578c26cdedd1c38940e8570e8b2e2a9",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}