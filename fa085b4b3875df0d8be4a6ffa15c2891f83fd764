{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8238d045_23102f18",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-08-21T02:12:21Z",
      "side": 1,
      "message": "Since the source is an integer constant, I wonder if using MOVZ and MOVK instructions is more efficient. ADRP+ADD+LDR theoretically costs 6 cycles, move an integer into a general purpose register costs at most 4 instructions, namely 4 cycles. In addition we need one instruction to move the value from the general purpose register to floating-pointer register. So at most 5 cycles.\nFor VMOVS, moving a 32-bit integer takes at most 2 movX instructions.",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 10,
        "endChar": 50
      },
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3847b03c_c405641d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 13640
      },
      "writtenOn": "2023-08-21T07:46:12Z",
      "side": 1,
      "message": "I did consider this, however I cannot find anywhere that these instructions are used in Go or golang.org/x/crypto (so optimising highly does not seem justified). Also, unless I\u0027m missing something, the move from a general register to a vector register is 3-4 cycles - the main gain is likely to be that the instruction text probably has lower load latency than an arbitrary read from memory. The flip side is that we have larger text and do not benefit from the content addressable symbols, which can provide deduplication, etc.",
      "parentUuid": "8238d045_23102f18",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 10,
        "endChar": 50
      },
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a86a969_83ebf891",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-08-21T08:04:31Z",
      "side": 1,
      "message": "\u003e the move from a general register to a vector register is 3-4 cycles\n\nOh yes you are right, I mistook FMOV for one cycle. Thanks.",
      "parentUuid": "3847b03c_c405641d",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 10,
        "endChar": 50
      },
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8955874d_96d22c82",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 13640
      },
      "writtenOn": "2023-08-21T08:13:20Z",
      "side": 1,
      "message": "Thanks for confirming.",
      "parentUuid": "5a86a969_83ebf891",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 10,
        "endChar": 50
      },
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfc1f426_59eac1a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-04T09:11:26Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dfa085b4b\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91f76e46_c7b81656",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-04T09:23:40Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "dfc1f426_59eac1a1",
      "tag": "autogenerated:trybots~happy",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d75d532a_891d3056",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-08-21T15:54:42Z",
      "side": 1,
      "message": "This is probably fine. But I don\u0027t see a clear downside for using constant pool in text, besides the OpenBSD issue. Maybe do this only for OpenBSD? Or as this is rare we just lean towards code simplicity and do it everywhere so we don\u0027t need a special case for OpenBSD?",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84bd4255_79a1dced",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-08-22T08:56:35Z",
      "side": 1,
      "message": "I think x-only may not be a special case. In fact, the Linux kernel has supported this mode since 2021(https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id\u003d18107f8a2df6bf1c6cac8d0713f757f866d5af51), and most Linux distros support it.",
      "parentUuid": "d75d532a_891d3056",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "796591c5_071f3ff2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 24534
      },
      "writtenOn": "2023-08-22T09:51:29Z",
      "side": 1,
      "message": "It should be noted that execute-only feature only works on CPUs which supports FEAT_PAN3",
      "parentUuid": "84bd4255_79a1dced",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "495bfd30_c4ce0c4e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13640
      },
      "writtenOn": "2023-08-22T13:31:59Z",
      "side": 1,
      "message": "I think there are several aspects to this:\n\n1) The VMOV{Q,D,S} instructions are infrequently used and the cost of two additional cycles (which are potentially run in a separate pipeline) are of no real consequence. We also get benefits from removing arm64 specific complexity and leveraging the existing content addressable symbols infrastructure.\n\n2) I suspect that other operating systems will eventually push for x-only, or at least provide support for it (as Eric also notes).\n\n3) I do not think that arm64 gains anything from the literal pool - with the changes that have landed (or are in flight), all of the literal pool usage has been removed from the binaries that build for Go, aside from the large reflect calls. The changes so far have only resulted in better code generation and use the same number or fewer instructions. The remaining uses can be eliminated by inlining the load, which will require one or two additional instructions but remove a load from memory (and should therefore be faster/require fewer cycles).",
      "parentUuid": "84bd4255_79a1dced",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "456eec3b_b2dd3e2f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2023-08-22T16:05:44Z",
      "side": 1,
      "message": "I thought using constant pool within the function body can generate shorter PC-relative load instruction sequence than using a global symbol? But as you mentioned, using global symbols has its own advantages, such as deduplicate through content addressable symbols. If your experiment shows the code generation doesn\u0027t get worse, I think this is fine. Thanks.",
      "parentUuid": "495bfd30_c4ce0c4e",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4774fe01_bc5b99ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13640
      },
      "writtenOn": "2023-08-22T16:15:35Z",
      "side": 1,
      "message": "Thanks. You\u0027re correct in that a PC-relative load will be fewer instructions (i.e. we avoid ADRP+ADD), however the latency of the LDR is already high - this change moves from 4 cycles to 6 cycles (although in practice it probably has lower overhead). Other than the test code there do not appear to be any VMOV{Q,D,S} use cases that exist in an all.bash run.",
      "parentUuid": "456eec3b_b2dd3e2f",
      "revId": "fa085b4b3875df0d8be4a6ffa15c2891f83fd764",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}