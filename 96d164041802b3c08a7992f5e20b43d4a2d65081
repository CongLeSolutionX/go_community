{
  "comments": [
    {
      "key": {
        "uuid": "ed33c736_344a019d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T04:02:24Z",
      "side": 1,
      "message": "Seems the failure due to \"noWB\" in \"runtime/internal/atomic/atomic_wasm.go\" is being marked as \"go:notinheap\"",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bf11ce0_7cab05ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T04:07:20Z",
      "side": 1,
      "message": "Thanks, I\u0027ve wanted to collapse the has-pointer functions for a while, but was never successful. It seems like extending //go:notinheap to disallow variables on the stack was the extra step I never thought to try.\n\ncmd/compile changes look good, but js-wasm failure seems real.",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82b4bc0c_6527c1b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T04:33:13Z",
      "side": 1,
      "message": "Can you elaborate on why you think that\u0027s the case?\n\nI see that noWB is the only //go:notinheap type that\u0027s specific to wasm, but I don\u0027t immediately see anything wrong with wasm\u0027s StorepNoWB function. I also don\u0027t see anything in the js-wasm trybot logs that indicate this code in particular.",
      "parentUuid": "ed33c736_344a019d",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d62b6bf_2b60ee03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T04:33:13Z",
      "side": 1,
      "message": "I looked over the CL a couple extra times because of the js-wasm failures, but I\u0027m still not seeing anything that I would attribute the js-wasm failures to.",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59df375a_207a0e47",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T04:51:09Z",
      "side": 1,
      "message": "That\u0027s totally my guess only, without digging further by running wasn/js test in local. Before this CL:\n\n```\n./atomic_wasm.go:161:17: ptr does not escape\n./atomic_wasm.go:161:37: leaking param: val\n```\n\nAfter:\n\n```\n./atomic_wasm.go:161:37: val does not escape\n./atomic_wasm.go:167:10: ptr does not escape\n```\n\nAnd looking at your fix in 814c97b3133d0e5a8aa884e2ef752aaf7e7bd500, that seems to be problem because \"val\" is treated as a non-leaking parameter.",
      "parentUuid": "82b4bc0c_6527c1b7",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d243111_0c8d098b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T04:52:54Z",
      "side": 1,
      "message": "Sorry, copy-paste error, \"After\" case:\n\n```\n./atomic_wasm.go:161:17: ptr does not escape\n./atomic_wasm.go:161:37: val does not escape\n```",
      "parentUuid": "59df375a_207a0e47",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c723948_56bd04f6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T05:20:23Z",
      "side": 1,
      "message": "Ah, well spotted. That definitely seems like a problem.\n\nWhen I\u0027m looking for escape analysis related failures, I typically run something like\n\n    go test -c -gcflags\u003dall\u003d-m bufio | grep -e \"moved to heap\" -e \"escapes to heap\"\n\nbefore and after a compiler CL and look for any changes in the diff output. I bet you can find a \"new(T)\" statement somewhere in the runtime that\u0027s now being stack allocated because of this CL.\n\n(The \"moved to heap\" and \"escapes to heap\" diagnostics are much more important because they indicate whether a particular variable was actually allocated on the heap or stack, whereas the latter are internal details; the \"does not escape\" and \"leaking param\" diagnostics are just to help understand why escape analysis made the decisions it did.)",
      "parentUuid": "2d243111_0c8d098b",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27b43e90_3c9db997",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T05:53:41Z",
      "side": 1,
      "message": "Yep, this CL causes the \"new([]*moduledata)\" at runtime/symtab.go:460 to be stack allocated.",
      "parentUuid": "3c723948_56bd04f6",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}