{
  "comments": [
    {
      "key": {
        "uuid": "ed33c736_344a019d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T04:02:24Z",
      "side": 1,
      "message": "Seems the failure due to \"noWB\" in \"runtime/internal/atomic/atomic_wasm.go\" is being marked as \"go:notinheap\"",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bf11ce0_7cab05ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T04:07:20Z",
      "side": 1,
      "message": "Thanks, I\u0027ve wanted to collapse the has-pointer functions for a while, but was never successful. It seems like extending //go:notinheap to disallow variables on the stack was the extra step I never thought to try.\n\ncmd/compile changes look good, but js-wasm failure seems real.",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82b4bc0c_6527c1b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T04:33:13Z",
      "side": 1,
      "message": "Can you elaborate on why you think that\u0027s the case?\n\nI see that noWB is the only //go:notinheap type that\u0027s specific to wasm, but I don\u0027t immediately see anything wrong with wasm\u0027s StorepNoWB function. I also don\u0027t see anything in the js-wasm trybot logs that indicate this code in particular.",
      "parentUuid": "ed33c736_344a019d",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d62b6bf_2b60ee03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T04:33:13Z",
      "side": 1,
      "message": "I looked over the CL a couple extra times because of the js-wasm failures, but I\u0027m still not seeing anything that I would attribute the js-wasm failures to.",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59df375a_207a0e47",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T04:51:09Z",
      "side": 1,
      "message": "That\u0027s totally my guess only, without digging further by running wasn/js test in local. Before this CL:\n\n```\n./atomic_wasm.go:161:17: ptr does not escape\n./atomic_wasm.go:161:37: leaking param: val\n```\n\nAfter:\n\n```\n./atomic_wasm.go:161:37: val does not escape\n./atomic_wasm.go:167:10: ptr does not escape\n```\n\nAnd looking at your fix in 814c97b3133d0e5a8aa884e2ef752aaf7e7bd500, that seems to be problem because \"val\" is treated as a non-leaking parameter.",
      "parentUuid": "82b4bc0c_6527c1b7",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d243111_0c8d098b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T04:52:54Z",
      "side": 1,
      "message": "Sorry, copy-paste error, \"After\" case:\n\n```\n./atomic_wasm.go:161:17: ptr does not escape\n./atomic_wasm.go:161:37: val does not escape\n```",
      "parentUuid": "59df375a_207a0e47",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c723948_56bd04f6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T05:20:23Z",
      "side": 1,
      "message": "Ah, well spotted. That definitely seems like a problem.\n\nWhen I\u0027m looking for escape analysis related failures, I typically run something like\n\n    go test -c -gcflags\u003dall\u003d-m bufio | grep -e \"moved to heap\" -e \"escapes to heap\"\n\nbefore and after a compiler CL and look for any changes in the diff output. I bet you can find a \"new(T)\" statement somewhere in the runtime that\u0027s now being stack allocated because of this CL.\n\n(The \"moved to heap\" and \"escapes to heap\" diagnostics are much more important because they indicate whether a particular variable was actually allocated on the heap or stack, whereas the latter are internal details; the \"does not escape\" and \"leaking param\" diagnostics are just to help understand why escape analysis made the decisions it did.)",
      "parentUuid": "2d243111_0c8d098b",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27b43e90_3c9db997",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T05:53:41Z",
      "side": 1,
      "message": "Yep, this CL causes the \"new([]*moduledata)\" at runtime/symtab.go:460 to be stack allocated.",
      "parentUuid": "3c723948_56bd04f6",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "005ba93c_fd3dbc02",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T05:54:24Z",
      "side": 1,
      "message": "(For GOOS\u003djs GOARCH\u003dwasm, that is.)",
      "parentUuid": "27b43e90_3c9db997",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2aee333_c198a3fc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T06:14:26Z",
      "side": 1,
      "message": "Yeah, that explains the fails, since when \"atomicstorep\" was called with \"unsafe.Pointer(modules)\", which then calls \"atomic.StorepNoWB(noescape(ptr), unsafe.Pointer(modules))\"",
      "parentUuid": "005ba93c_fd3dbc02",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2f02554_3f70d336",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14665
      },
      "writtenOn": "2020-08-22T06:16:32Z",
      "side": 1,
      "message": "I wonder could we just remove the \"go:notinheap\" for \"noWB\"?",
      "parentUuid": "d2aee333_c198a3fc",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d52f815b_86839fd7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-22T06:40:56Z",
      "side": 1,
      "message": "No, that would cause the assignment to use write barriers, which is what this function is trying to avoid.\n\nSomething like this seems to work:\n\n```\nfunc StorepNoWB(ptr unsafe.Pointer, val unsafe.Pointer) {\n    *(*uintptr)(ptr) \u003d uintptr(val)\n\n    if never :\u003d false; never {\n        *(*unsafe.Pointer)(ptr) \u003d val\n    }\n}\n```\n\nThat\u0027s obfuscated just enough that escape analysis will treat val as escaping, but easy for SSA to optimize away as dead code.\n\nThat\u0027s pretty brittle though (e.g., if/when we move escape analysis to SSA, it won\u0027t work anymore). We\u0027d probably want a test that runs \"GOOS\u003djs GOARCH\u003dwasm go build -gcflags\u003d-m runtime/internal/atomic\" and looks for the \"leaking param: val\" line.",
      "parentUuid": "d2f02554_3f70d336",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8076568_8dca9aa5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5440
      },
      "writtenOn": "2020-08-23T20:49:03Z",
      "side": 1,
      "message": "The fix for StorepNoWB was handled in CL 249962. A test is being discussed in CL 249761.\n\nMarking this conversation as Resolved.",
      "parentUuid": "d52f815b_86839fd7",
      "revId": "96d164041802b3c08a7992f5e20b43d4a2d65081",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}