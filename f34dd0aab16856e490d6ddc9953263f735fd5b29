{
  "comments": [
    {
      "key": {
        "uuid": "d9a500d9_08b164b4",
        "filename": "src/internal/poll/copy_file_range_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 78,
      "author": {
        "id": 5206
      },
      "writtenOn": "2020-04-27T23:59:19Z",
      "side": 1,
      "message": "I\u0027m looking at this comment and it\u0027s making me wonder why we don\u0027t do the locks outside of the loop in CopyFileRange.  If we really need the loop in CopyFileRange, then doing the locks down here will permit possibly unexpected interleaving.  That isn\u0027t that serious, in that io.Copy doesn\u0027t prohibit interleaving in general, but it seems that it would be very easy to get it right so why not get it right.",
      "revId": "f34dd0aab16856e490d6ddc9953263f735fd5b29",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1dbaf777_3b9c178e",
        "filename": "src/internal/poll/copy_file_range_linux.go",
        "patchSetId": 6
      },
      "lineNbr": 78,
      "author": {
        "id": 27279
      },
      "writtenOn": "2020-04-28T00:12:51Z",
      "side": 1,
      "message": "The reason is CL 120317 from the splice work we did a few years ago. But perhaps I ported some incorrect assumptions over. I think you\u0027re right: maybe we don\u0027t need to do permit interleaving here. The situation is pretty different, and I imagine that if copy_file_range blocks for a long time, then closing either of the file descriptors involved will unblock the entire call, and we cannot hang in a manner similar to #25985.\n\nWhat do you think? If you agree with this assessment, then I will move the locks outside the loop.",
      "parentUuid": "d9a500d9_08b164b4",
      "revId": "f34dd0aab16856e490d6ddc9953263f735fd5b29",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}