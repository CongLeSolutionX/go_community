{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "80ee369c_327bee09",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-07-11T19:15:12Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dbef031c6\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "bef031c60fe9acd18c6917fbb0cbd93eb71f8206",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "055de3c5_48e5cceb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-07-11T19:27:51Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "80ee369c_327bee09",
      "tag": "autogenerated:trybots~happy",
      "revId": "bef031c60fe9acd18c6917fbb0cbd93eb71f8206",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b08bf64c_08978a8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-07-11T19:42:26Z",
      "side": 1,
      "message": "Does this change need to be ported to go/types?",
      "revId": "bef031c60fe9acd18c6917fbb0cbd93eb71f8206",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58d10221_2cbcbd8c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 7061
      },
      "writtenOn": "2023-07-24T17:35:25Z",
      "side": 1,
      "message": "go/types, and/or go/ast?  It does seem necessary, if anyone ever writes code that cares about variable scope/lifetime in parsed Go files.\n\nI\u0027ve been looking at those two packages, one problem thus far is I cannot tell if (1) it is okay to add a new public field to go/ast/{ForStmt,RangeStmt}\n(2) how to determine the Go version in effect for whatever file is currently being parsed.\n\nI\u0027m trying to put together a separate CL for this",
      "parentUuid": "b08bf64c_08978a8e",
      "revId": "bef031c60fe9acd18c6917fbb0cbd93eb71f8206",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "090403a0_3b522ce7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 7061
      },
      "writtenOn": "2023-07-24T18:42:38Z",
      "side": 1,
      "message": "The scope is definitely affected by this.  Type checking however is not.\nFor example, this loop \n```\n   for i :\u003d 0; i \u003c 32; i++ {\n      g :\u003d float64(i)\n      f--\n      f +\u003d g\n   }\n```\ncurrently creates these scopes\n```\n.  .  .  for scope {\n.  .  .  .  var i int\n.  .  .  .  block scope {\n.  .  .  .  .  var g float64\n.  .  .  .  }\n.  .  .  }\n```\nbut with the new semantics it is instead (in my opinion)\n```\n.  .  .  for scope {\n.  .  .  .  block scope {\n.  .  .  .  .  var i int\n.  .  .  .  .  var g float64\n.  .  .  .  }\n.  .  .  }\n```\nor perhaps\n```\n.  .  .  for scope {\n.  .  .  .  var i int\n.  .  .  .  block scope {\n.  .  .  .  .  var i int\n.  .  .  .  .  var g float64\n.  .  .  .  }\n.  .  .  }\n```\nwhere the inner i is implicit (this is literally the transformation made in the compiler).",
      "parentUuid": "58d10221_2cbcbd8c",
      "revId": "bef031c60fe9acd18c6917fbb0cbd93eb71f8206",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff3efad3_1b5b1261",
        "filename": "src/cmd/compile/internal/types2/stmt.go",
        "patchSetId": 1
      },
      "lineNbr": 655,
      "author": {
        "id": 7061
      },
      "writtenOn": "2023-07-11T19:41:35Z",
      "side": 1,
      "message": "s/it/loopvar/",
      "range": {
        "startLine": 655,
        "startChar": 70,
        "endLine": 655,
        "endChar": 72
      },
      "revId": "bef031c60fe9acd18c6917fbb0cbd93eb71f8206",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af2a5d4b_6dae770a",
        "filename": "src/cmd/compile/internal/types2/stmt.go",
        "patchSetId": 1
      },
      "lineNbr": 656,
      "author": {
        "id": 7061
      },
      "writtenOn": "2023-07-11T19:41:35Z",
      "side": 1,
      "message": "I am trying to decide if this right here.\n\nThe current 1.21 behavior is \"if GOEXPERIMENT or -d\u003dloopvar\u003d1+, then do it\", ignoring language behavior.\n\nArguably that is \"wrong\", but fixing it would interfere with people testing the loop semantics change since they\u0027d need to update their go.mod files all over the place.\n\nThe only reason to do the GOEXPERIMENT (which sets loopvar) with 1.22 would be to do a quick test of a an older\u003dversion package(s) to see if they were affected by the semantic change, and it seems like the same rules apply, and that it should not demand a concurrent go.mod update to 1.21 to run the experiment.",
      "range": {
        "startLine": 656,
        "startChar": 28,
        "endLine": 656,
        "endChar": 54
      },
      "revId": "bef031c60fe9acd18c6917fbb0cbd93eb71f8206",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}