{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "07c33e25_7d3680a8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 25391
      },
      "writtenOn": "2022-04-05T00:17:36Z",
      "side": 1,
      "message": "the tradeoff here seems to be whole-application latency for profile acquisition latency. I think that\u0027s very reasonable, but it should probably be noted. profile acquisition latency would be a nice benchmark just to confirm (or deny!). take a look at the readMetrics benchmark which reports tail metrics acquisition latencies.",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "314a251e_da8c9203",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 9210
      },
      "writtenOn": "2022-04-05T23:16:47Z",
      "side": 1,
      "message": "The main ways we see an increase in profile acquisition latency are 1/ stopping the world twice per profile instead of once, and 2/ the goroutine that\u0027s collecting the profile has the same priority as any other, so isn\u0027t guaranteed execution time like it would be with the world stopped.\n\nI\u0027ve added a benchmark (in CL 387414) that shows the first, and shows the second during a particular adversary workload (applyGCLoad). I don\u0027t know what (if anything) to do about the second: because it can run for a long time, claiming on-CPU time by disabling preemption doesn\u0027t seem right.",
      "parentUuid": "07c33e25_7d3680a8",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6ab74809_7becb094",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 22,
      "author": {
        "id": 25391
      },
      "writtenOn": "2022-04-05T23:33:22Z",
      "side": 1,
      "message": "yeah I don\u0027t mean to say you should do something to mitigate it. personally I think it\u0027s a reasonable thing to trade-off here. thanks for the benchmark!",
      "parentUuid": "314a251e_da8c9203",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "907ffc5f_edb71c78",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-02T18:30:38Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003da46f1ec2",
      "tag": "autogenerated:trybots~beginning",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af7943e7_ce2150df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-04-02T18:42:32Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "907ffc5f_edb71c78",
      "tag": "autogenerated:trybots~happy",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96228338_9568703c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 50449
      },
      "writtenOn": "2022-04-03T11:42:35Z",
      "side": 1,
      "message": "Thanks for the changes Rhys, they look great. I just took a quick look and have one immediate question.",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9b9ca6d_107f5d9e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 25391
      },
      "writtenOn": "2022-04-05T00:17:36Z",
      "side": 1,
      "message": "looks OK on a first pass, will take a closer look soon",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34955264_2cc39430",
        "filename": "src/runtime/mfinal.go",
        "patchSetId": 4
      },
      "lineNbr": 170,
      "author": {
        "id": 25391
      },
      "writtenOn": "2022-04-05T00:17:36Z",
      "side": 1,
      "message": "I think this needs to happen behind a lock. there isn\u0027t synchronization that ensures this gets set like in other system goroutines IIRC.",
      "range": {
        "startLine": 169,
        "startChar": 0,
        "endLine": 170,
        "endChar": 10
      },
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6cd58e08_0bde2b34",
        "filename": "src/runtime/mfinal.go",
        "patchSetId": 4
      },
      "lineNbr": 170,
      "author": {
        "id": 9210
      },
      "writtenOn": "2022-04-05T23:16:47Z",
      "side": 1,
      "message": "Done\n\nIs it right that _any_ lock here would do, since the other access is during STW which gathers all the Ps and so guarantees that no other M is holding any locks? Thanks!",
      "parentUuid": "34955264_2cc39430",
      "range": {
        "startLine": 169,
        "startChar": 0,
        "endLine": 170,
        "endChar": 10
      },
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70cfbb7e_53151c9d",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 3830,
      "author": {
        "id": 50449
      },
      "writtenOn": "2022-04-03T11:42:35Z",
      "side": 1,
      "message": "I\u0027m a little confused. Looking at `mcall(exitsyscall0)` it seems like it should never (!) return, so I don\u0027t understand why there is any code here. When is the scheduler expected to return?\n\nSince I don\u0027t understand the control flow, I\u0027m also not sure if it is safe to set `_g_.syscallsp \u003d 0` here while a goroutine profile is being taken. Are we guaranteed that a `execute(_g_)` has taken place before we reach this point? If not, we probably need another `tryRecordGoroutineProfileWB` call here similar to the one above?",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7e0651b_22e0472e",
        "filename": "src/runtime/proc.go",
        "patchSetId": 4
      },
      "lineNbr": 3830,
      "author": {
        "id": 9210
      },
      "writtenOn": "2022-04-04T23:59:03Z",
      "side": 1,
      "message": "Although `mcall(exitsyscall0)` doesn\u0027t return, it does queue the calling goroutine to run later. At some point that goroutine will have its status changed from _Grunnable to _Grunning and will resume, as far as I can tell, at the PC after the call to `mcall`.\n\nThe code paths I see in `exitsyscall0` either end in `execute`, or put the goroutine on the global run queue (and then call `schedule`). So I think that yes, the path that goroutine takes to being _Grunning again is the same as any other in the program. Once it\u0027s in the _Grunnable state, it\u0027s done being a special case.\n\nOnce it\u0027s running again, it\u0027s fine for it to modify `_g_.syscallsp` because the goroutine profiler will have already looked.\n\nThis also now covers all (two) places that do `traceGoStart` and which also change status to _Grunning.",
      "parentUuid": "70cfbb7e_53151c9d",
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d5ad4fc_26ef8a11",
        "filename": "src/runtime/runtime2.go",
        "patchSetId": 4
      },
      "lineNbr": 492,
      "author": {
        "id": 25391
      },
      "writtenOn": "2022-04-05T00:17:36Z",
      "side": 1,
      "message": "please use runtime/internal/atomic.Uint32",
      "range": {
        "startLine": 492,
        "startChar": 19,
        "endLine": 492,
        "endChar": 25
      },
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d74c95a_751c3d29",
        "filename": "src/runtime/runtime2.go",
        "patchSetId": 4
      },
      "lineNbr": 492,
      "author": {
        "id": 9210
      },
      "writtenOn": "2022-04-05T23:16:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9d5ad4fc_26ef8a11",
      "range": {
        "startLine": 492,
        "startChar": 19,
        "endLine": 492,
        "endChar": 25
      },
      "revId": "a46f1ec252f70f1c880f41c511661f0eae3264e2",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}