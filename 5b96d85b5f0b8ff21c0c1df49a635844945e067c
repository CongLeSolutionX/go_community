{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ca51e583_fc08d83a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-12T08:37:54Z",
      "side": 1,
      "message": "Before go1.22, the example in #65625 can be run successfully, though the core issue is in old version glibc, but it will be better to provide this backward compatibility to let people can upgrade to go 1.22+.",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d64cd181_f858f36c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-12T08:57:29Z",
      "side": 1,
      "message": "Because glibc didn\u0027t provide Convenient methods to let user clear tid cache in struct pthread, people need to try lots of work and do some hack way(maybe a incorrect way) to let cgo with clone(2) can work like before after they upgrade to go 1.22.",
      "parentUuid": "ca51e583_fc08d83a",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bb95b0f_8f6ff5a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-05-13T15:29:15Z",
      "side": 1,
      "message": "This workaround doesn\u0027t seem too bad. But the ultimate bug is the use of clone(2) in runc isn\u0027t safe, which should be addressed, instead of being worked around. In theory a stale tid cache can lead to any weird behavior, not just the crashing.",
      "parentUuid": "d64cd181_f858f36c",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "653ce634_9e032339",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-05-13T18:44:45Z",
      "side": 1,
      "message": "I agree. I think attempting to continue in this state is asking for trouble. In https://github.com/golang/go/issues/65625#issuecomment-1939390070, I noted my opinion that we should abort the process entirely on these errors. IMO, that still seems like the safest approach.",
      "parentUuid": "9bb95b0f_8f6ff5a1",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70a040b3_b0e9c722",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-14T09:52:43Z",
      "side": 1,
      "message": "I think we can abort the process entirely when there is an error on calling `pthread_*` functions, except `pthread_getattr_np`. Because there is a fact that in cgo, only `pthread_getattr_np`\u0027s error is related to `tid dirty cache`, other `pthread_*` functions\u0027 error has no relationship to `tid dirty cache`. Consider the new version glibc has removed `tid cache`, so I think we can have a backwork compatibility for `pthread_getattr_np`. I think it is safe enough for golang.\n\nI have read the gblic code, and this is the list of `pthread_*` function list that could be influenced by `tid dirty cache`:\npthread_getaffinity_np\npthread_getcpuclockid\npthread_getname_np\npthread_getschedparam\npthread_kill\npthread_setaffinity_np\npthread_setname_np\npthread_setschedparam\npthread_sigqueue\npthread_getattr_np\n\nOnly the last one is used by cgo.",
      "parentUuid": "653ce634_9e032339",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "105b9c55_efee4c6d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-14T10:24:50Z",
      "side": 1,
      "message": "And do you agree that it’s not necessary using ‘pthread_getattr_np’ here, the failback codes are enough in before. But using ‘pthread_getattr_np’ looks better for new versions glibc, so I think backwards compatibility is safe enough.",
      "parentUuid": "70a040b3_b0e9c722",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "177cfc5b_6ebb104b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-19T14:38:28Z",
      "side": 1,
      "message": "I have a strong opinion to suggest to consider this backward compatibility. Because maintainers in runc have tried many solutions to replace `clone(2)`, but each solution are not perfect.\n\nConsider the following code, cgo in 1.22 also can\u0027t work with SYS_clone3:\n```c\npackage main\n/*\n#cgo CFLAGS: -Wall\n#define _GNU_SOURCE\n#include \u003clinux/sched.h\u003e\n#include \u003csched.h\u003e\n#include \u003csignal.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003csys/syscall.h\u003e\n#include \u003cunistd.h\u003e\n#include \u003cerrno.h\u003e\n\nstatic int child_fn(void *args) {\n    printf(\"Hello from C!\\n\");\n    return 0;\n}\n\nvoid clone3() {\n    struct clone_args args \u003d {\n        .exit_signal \u003d SIGCHLD,\n    };\n\n    pid_t pid \u003d syscall(SYS_clone3, \u0026args, sizeof(args));\n    if (pid \u003d\u003d -1) {\n        perror(\"clone3 failed\");\n        _exit(-1);\n    } else if (pid \u003d\u003d 0) { // Child process\n        child_fn(NULL);\n    } else { // Parent process\n        _exit(0);\n    }\n}\nvoid __attribute__((constructor)) init(void) {\n        clone3();\n}\n*/\nimport \"C\"\n\nimport \"fmt\"\n\nfunc main() {\n        fmt.Println(\"Hello from go!\");\n}\n```",
      "parentUuid": "105b9c55_efee4c6d",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c17ebd9_dda61d84",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-20T00:02:30Z",
      "side": 1,
      "message": "You really can\u0027t call clone in a Go program if you don\u0027t immediately call execve.  It just can\u0027t work.  A CL like this seems like it is just papering over the cracks.  But it\u0027s actually better to fail fast and reliably than it is to fail slowly and unpredictably.  The latter is just a source of lingering unfixable bugs.\n\nIf there is some reason that the use of clone in runc is OK, please explain why it is OK.  Thanks.",
      "parentUuid": "177cfc5b_6ebb104b",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5775558_de49b097",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-20T00:41:36Z",
      "side": 1,
      "message": "It’s because when we unshare or enter an new pid namespace, this has no effects for the caller process, we must create an new process to enter this new pid namespace. If runc uses fork(2), it must use ‘PR_SET_CHILD_SUBREAPER’ to reap this forked process, but this will cause all grandchildren processes reparent to the caller process after their parent dead, maybe this is a broken change for runc lib users, because the API has served for about ten years.\n\nIf you have any other suggestions to solve this broken change, it will also appreciated.",
      "parentUuid": "4c17ebd9_dda61d84",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ecf33d7_af577fc4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-20T03:58:27Z",
      "side": 1,
      "message": "So runc uses `clone(2)` with `CLONE_PARENT` to let the grandchild process become a child process, it can avoid to use `PR_SET_CHILD_SUBREAPER`. Before go 1.22, it can work fine. If we change this behavior, as I metioned above, it will cause broken changes.",
      "parentUuid": "e5775558_de49b097",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ade9a492_349c95a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-20T05:20:50Z",
      "side": 1,
      "message": "To be clear, I\u0027m not asking why you use clone.  I\u0027m saying that in Go it is only OK to use clone if the cloned child is going to run execve very quickly.  It is never OK to use clone in any other circumstance.\n\nWhen runc calls clone, does the child call execve very quickly?\n\nIf not, calling clone is going to leave the child in an unsafe state.  We should not let that case succeed.",
      "parentUuid": "7ecf33d7_af577fc4",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82af6827_48bcd60e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-20T09:26:33Z",
      "side": 1,
      "message": "\u003e\u003e\u003e When runc calls clone, does the child call execve very quickly?\n\nNo, after calling `clone(2)`, runc has to do lots of work before calling `execve`, and the `execve` calling is in the go routine, not in C env. Before go 1.22, it works fine in runc, the main reason is that both Go and runc are not using `pthread lib` to deal with the main business. This is also the main reason I recommend to have a backward compatibility. Because the `tid dirty cache` bug is a `pthread lib` bug, neither a kernel bug, nor a runtime / user code bug. So I think if we know there is a bug in a lib, we should not use it, but we think that there is no bug in the newer version pthread lib, so we want to adopt it, I admit that it makes sense, but we should have a backward compatibility.\n\n\u003e\u003e\u003e calling clone is going to leave the child in an unsafe state\n\nI think it is `pthread lib` let the child in an unsafe state, not go runtime. If the child does not use `pthread lib`, it will not in an unsafe state. Whether using `pthread lib` or not is determined by the child, not go runtime. The child should take responsibility for this unsafe state if he uses `pthread lib`, I think go runtime should have no responsibility for this unsafe state.\n\nWDYT",
      "parentUuid": "ade9a492_349c95a9",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd59c3e4_dccdef40",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-20T16:09:39Z",
      "side": 1,
      "message": "After clone, there will only be a single thread of execution running.  If any goroutine before clone is holding a lock, that lock will never be released.  That could be the garbage collector--it\u0027s not under the control of your application.  So calling clone and then continuing to run means that your program will occasionally and predictably deadlock trying to acquire a lock that will never be released.  That is just one example of the kind of problem that can occur if a Go program continues to run after calling clone.",
      "parentUuid": "82af6827_48bcd60e",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18e8c370_baff563e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-20T17:32:51Z",
      "side": 1,
      "message": "Oh my god, the core issue is not the tid dirty cache, because the tid cache removal PR has been back-ported to glibc \u003e\u003d 2.25. (Maybe still has wrong tid cache issue for newer glibc.)\nAnd @prattmic has indicated that the core issue of cgo failed with clone(2) is that: before 2.32, `pthread_getattr_np` did not call `__pthread_attr_init (attr)`, we need to init the attr in go runtime. (https://github.com/golang/go/issues/65625#issuecomment-1939390070)\n\nI have a test in runc, it indeed solves the issue. (https://github.com/opencontainers/runc/pull/4278)",
      "parentUuid": "dd59c3e4_dccdef40",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bf5a30f_68b2c93b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-21T16:12:03Z",
      "side": 1,
      "message": "\u003e\u003e\u003e After clone, there will only be a single thread of execution running. If any goroutine before clone is holding a lock, that lock will never be released. That could be the garbage collector--it\u0027s not under the control of your application. So calling clone and then continuing to run means that your program will occasionally and predictably deadlock trying to acquire a lock that will never be released. That is just one example of the kind of problem that can occur if a Go program continues to run after calling clone.\n\nRunc uses C `constructor`, so before the clone syscall, there is no goroutine. Runc does not call clone syscall from go code, it\u0027s only in C code.",
      "parentUuid": "18e8c370_baff563e",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77ed326f_5c535e57",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-21T17:47:54Z",
      "side": 1,
      "message": "Then I guess I don\u0027t understand the problem.\n\nBut stepping back, I do see that glibc 2.32 adds the call to pthread_attr_init in pthread_getattr_np.  glibc 2.32 was released 2020-08-05, so it seems reasonable for us to always call pthread_attr_init before pthread_getattr_np.  Can you change the CL to do that?  On an error, we should crash.  Thanks.",
      "parentUuid": "2bf5a30f_68b2c93b",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}