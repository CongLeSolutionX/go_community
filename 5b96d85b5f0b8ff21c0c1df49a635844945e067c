{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ca51e583_fc08d83a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-12T08:37:54Z",
      "side": 1,
      "message": "Before go1.22, the example in #65625 can be run successfully, though the core issue is in old version glibc, but it will be better to provide this backward compatibility to let people can upgrade to go 1.22+.",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d64cd181_f858f36c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-12T08:57:29Z",
      "side": 1,
      "message": "Because glibc didn\u0027t provide Convenient methods to let user clear tid cache in struct pthread, people need to try lots of work and do some hack way(maybe a incorrect way) to let cgo with clone(2) can work like before after they upgrade to go 1.22.",
      "parentUuid": "ca51e583_fc08d83a",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bb95b0f_8f6ff5a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 13315
      },
      "writtenOn": "2024-05-13T15:29:15Z",
      "side": 1,
      "message": "This workaround doesn\u0027t seem too bad. But the ultimate bug is the use of clone(2) in runc isn\u0027t safe, which should be addressed, instead of being worked around. In theory a stale tid cache can lead to any weird behavior, not just the crashing.",
      "parentUuid": "d64cd181_f858f36c",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "653ce634_9e032339",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 12120
      },
      "writtenOn": "2024-05-13T18:44:45Z",
      "side": 1,
      "message": "I agree. I think attempting to continue in this state is asking for trouble. In https://github.com/golang/go/issues/65625#issuecomment-1939390070, I noted my opinion that we should abort the process entirely on these errors. IMO, that still seems like the safest approach.",
      "parentUuid": "9bb95b0f_8f6ff5a1",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70a040b3_b0e9c722",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-14T09:52:43Z",
      "side": 1,
      "message": "I think we can abort the process entirely when there is an error on calling `pthread_*` functions, except `pthread_getattr_np`. Because there is a fact that in cgo, only `pthread_getattr_np`\u0027s error is related to `tid dirty cache`, other `pthread_*` functions\u0027 error has no relationship to `tid dirty cache`. Consider the new version glibc has removed `tid cache`, so I think we can have a backwork compatibility for `pthread_getattr_np`. I think it is safe enough for golang.\n\nI have read the gblic code, and this is the list of `pthread_*` function list that could be influenced by `tid dirty cache`:\npthread_getaffinity_np\npthread_getcpuclockid\npthread_getname_np\npthread_getschedparam\npthread_kill\npthread_setaffinity_np\npthread_setname_np\npthread_setschedparam\npthread_sigqueue\npthread_getattr_np\n\nOnly the last one is used by cgo.",
      "parentUuid": "653ce634_9e032339",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "105b9c55_efee4c6d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-14T10:24:50Z",
      "side": 1,
      "message": "And do you agree that it’s not necessary using ‘pthread_getattr_np’ here, the failback codes are enough in before. But using ‘pthread_getattr_np’ looks better for new versions glibc, so I think backwards compatibility is safe enough.",
      "parentUuid": "70a040b3_b0e9c722",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "177cfc5b_6ebb104b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-19T14:38:28Z",
      "side": 1,
      "message": "I have a strong opinion to suggest to consider this backward compatibility. Because maintainers in runc have tried many solutions to replace `clone(2)`, but each solution are not perfect.\n\nConsider the following code, cgo in 1.22 also can\u0027t work with SYS_clone3:\n```c\npackage main\n/*\n#cgo CFLAGS: -Wall\n#define _GNU_SOURCE\n#include \u003clinux/sched.h\u003e\n#include \u003csched.h\u003e\n#include \u003csignal.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003csys/syscall.h\u003e\n#include \u003cunistd.h\u003e\n#include \u003cerrno.h\u003e\n\nstatic int child_fn(void *args) {\n    printf(\"Hello from C!\\n\");\n    return 0;\n}\n\nvoid clone3() {\n    struct clone_args args \u003d {\n        .exit_signal \u003d SIGCHLD,\n    };\n\n    pid_t pid \u003d syscall(SYS_clone3, \u0026args, sizeof(args));\n    if (pid \u003d\u003d -1) {\n        perror(\"clone3 failed\");\n        _exit(-1);\n    } else if (pid \u003d\u003d 0) { // Child process\n        child_fn(NULL);\n    } else { // Parent process\n        _exit(0);\n    }\n}\nvoid __attribute__((constructor)) init(void) {\n        clone3();\n}\n*/\nimport \"C\"\n\nimport \"fmt\"\n\nfunc main() {\n        fmt.Println(\"Hello from go!\");\n}\n```",
      "parentUuid": "105b9c55_efee4c6d",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c17ebd9_dda61d84",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-20T00:02:30Z",
      "side": 1,
      "message": "You really can\u0027t call clone in a Go program if you don\u0027t immediately call execve.  It just can\u0027t work.  A CL like this seems like it is just papering over the cracks.  But it\u0027s actually better to fail fast and reliably than it is to fail slowly and unpredictably.  The latter is just a source of lingering unfixable bugs.\n\nIf there is some reason that the use of clone in runc is OK, please explain why it is OK.  Thanks.",
      "parentUuid": "177cfc5b_6ebb104b",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5775558_de49b097",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-20T00:41:36Z",
      "side": 1,
      "message": "It’s because when we unshare or enter an new pid namespace, this has no effects for the caller process, we must create an new process to enter this new pid namespace. If runc uses fork(2), it must use ‘PR_SET_CHILD_SUBREAPER’ to reap this forked process, but this will cause all grandchildren processes reparent to the caller process after their parent dead, maybe this is a broken change for runc lib users, because the API has served for about ten years.\n\nIf you have any other suggestions to solve this broken change, it will also appreciated.",
      "parentUuid": "4c17ebd9_dda61d84",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ecf33d7_af577fc4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 29495
      },
      "writtenOn": "2024-05-20T03:58:27Z",
      "side": 1,
      "message": "So runc uses `clone(2)` with `CLONE_PARENT` to let the grandchild process become a child process, it can avoid to use `PR_SET_CHILD_SUBREAPER`. Before go 1.22, it can work fine. If we change this behavior, as I metioned above, it will cause broken changes.",
      "parentUuid": "e5775558_de49b097",
      "revId": "5b96d85b5f0b8ff21c0c1df49a635844945e067c",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}