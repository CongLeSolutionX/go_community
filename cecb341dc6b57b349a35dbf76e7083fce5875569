{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bdfc3dd2_d4758985",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-05-25T14:25:23Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dcecb341d",
      "tag": "autogenerated:trybots~beginning",
      "revId": "cecb341dc6b57b349a35dbf76e7083fce5875569",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20699320_db5e1c2c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-05-25T14:37:18Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "bdfc3dd2_d4758985",
      "tag": "autogenerated:trybots~happy",
      "revId": "cecb341dc6b57b349a35dbf76e7083fce5875569",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e845f83_70d91900",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 2
      },
      "lineNbr": 623,
      "author": {
        "id": 12120
      },
      "writtenOn": "2022-05-25T18:09:08Z",
      "side": 1,
      "message": "My read of https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp#L2079 is that signals are delivered immediately for:\n\n* All synchronous signals.\n* Signals explicitly sent by the current thread with kill etc.\n* If the thread happens to be blocked.\n* If the thread `is_dead` (I don\u0027t know what this means).\n\nThus, I\u0027d expect this to significantly skew CPU profiles, as we will be dropping lots of samples (especially since \"blocked\" code presumably uses less CPU than running code). I think we should consider completely disabling CPU profiling in race mode to avoid giving a false sense of correctness.\n\nWe will also likely lose many async preemption signals, which is unfortunate as I wonder if it could mask race conditions that would otherwise get detected.\n\nI think we need this CL because I don\u0027t see how to reconcile the memory skew, but it makes me sad.",
      "revId": "cecb341dc6b57b349a35dbf76e7083fce5875569",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dfb548d_de0348c0",
        "filename": "src/runtime/signal_unix.go",
        "patchSetId": 2
      },
      "lineNbr": 623,
      "author": {
        "id": 13315
      },
      "writtenOn": "2022-05-25T20:26:49Z",
      "side": 1,
      "message": "I think this only affects code that uses cgo and the C code is built with TSAN, but does not affect the race detector. But I couldn\u0027t find where the condition is in TSAN code... Not sure if C TSAN + profiling is a common case that we need to worry about. But it is probably a good idea to just disable profiling in that case. Or, would it make sense for the profiler to just record the signal PC, but not the call stack?\n\nYeah, the preemption signals are unfortunate. All the failures we\u0027ve seen are from profiling signals. Maybe preemption signals are fine? But I don\u0027t know how it could work safely. Or maybe we could use SIGSYS in TSAN mode (real SIGSYS is probably really rare).",
      "parentUuid": "0e845f83_70d91900",
      "revId": "cecb341dc6b57b349a35dbf76e7083fce5875569",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}