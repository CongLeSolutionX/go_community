{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c2537067_7a7e74d7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-10-04T19:22:41Z",
      "side": 1,
      "message": "Should we actually make this a requirement?\n\nJust thinking ahead to when we have structured fuzzing, and the mutator hands the fuzz target a data structure with pointers. If the target can modify that data structure at will, we\u0027ll need to allocate a new one every iteration; I don\u0027t think we can use this approach with two copies.\n\nWe could potentially enforce this by hashing the data before and after each call and stopping if the hashes don\u0027t match. Hashing should be at least marginally faster than allocating and garbage collecting.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 47
      },
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a502647_5c49821c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-10-04T20:57:15Z",
      "side": 1,
      "message": "\u003e Should we actually make this a requirement?\nI would lean towards no. I think it\u0027s pretty reasonable that a function could alter the underlying bytes, and that those kinds of functions are worth fuzzing. It\u0027s also minimal work to allow this, so it seems like we should try.\n\nYou make a fair point about structs. If we\u0027re concerned about this for structs, we can always make it requirement that you can\u0027t alter the data structure when fuzzing structs for example, but still allow it for []byte types. Wdyt?",
      "parentUuid": "c2537067_7a7e74d7",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 47
      },
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1218b0a_e6888279",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-10-04T21:43:45Z",
      "side": 1,
      "message": "Better to have the same rule for slices and structs I think: otherwise, what do we do with a slice of structs or struct of slices?\n\nIf we do choose to make structs mutable, that\u0027s terribly difficult to implement. We\u0027ll just need some recursive deep copy function.\n\nI\u0027d lean toward not allowing mutation in either case though. Do we know of examples where it\u0027s useful?",
      "parentUuid": "3a502647_5c49821c",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 47
      },
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "17306ffa_239f56dc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-10-05T16:22:16Z",
      "side": 1,
      "message": "\u003e Do we know of examples where it\u0027s useful?\n\nI was thinking about functions in the bytes package as an example, but after looking at those, I guess they all return a new []byte rather than alter the provided []byte.\n\nYou\u0027ve convinced me! Another argument to be made is that it\u0027s simpler to say now that fuzz targets can\u0027t alter the underlying data, since we can always loosen this restriction later down the line if we come up with a good way to handle it. It\u0027s a lot harder (and would probably break backwards compatibility) if we wanted to add the requirement later on.\n\nI\u0027m going to leave this CL open if we want to re-visit in the future, but will remove y\u0027all from the reviewer line.",
      "parentUuid": "f1218b0a_e6888279",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 47
      },
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50f39648_fbf94774",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-30T19:27:27Z",
      "side": 1,
      "message": "SlowBots beginning. Status page: https://farmer.golang.org/try?commit\u003da2f679b4",
      "tag": "autogenerated:trybots~beginning",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fe9c845_57aa6220",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-30T19:27:27Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "230f3090_5d36e41d",
      "tag": "autogenerated:trybots~beginning",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a4bcec42_4a5b350a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-30T19:48:03Z",
      "side": 1,
      "message": "SlowBots are happy.\n\nSlowBot builds that ran:\n* linux-amd64-longtest\n* windows-amd64-longtest\n",
      "parentUuid": "50f39648_fbf94774",
      "tag": "autogenerated:trybots~happy",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fe4bda2_458ef3f8",
        "filename": "src/internal/fuzz/worker.go",
        "patchSetId": 2
      },
      "lineNbr": 623,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-10-04T19:22:41Z",
      "side": 1,
      "message": "Instead of allocating the slice lazily, could we define a workerServer constructor that creates it? I guess the challenge is knowing how many values there will be, but the caller ought to know that.",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0153b3e5_6ea9881d",
        "filename": "src/internal/fuzz/worker.go",
        "patchSetId": 2
      },
      "lineNbr": 629,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-10-04T19:22:41Z",
      "side": 1,
      "message": "Let\u0027s avoid allocating slice memory until we need it though. Instead of setting length and copying below, could do something like:\n\n   ws.scratchVals[i] \u003d append(ws.scratchVals[i].([]byte)[:0], v...)\n\nThat would reallocate the slice only if it\u0027s too small.",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}