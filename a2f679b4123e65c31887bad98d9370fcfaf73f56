{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c2537067_7a7e74d7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-10-04T19:22:41Z",
      "side": 1,
      "message": "Should we actually make this a requirement?\n\nJust thinking ahead to when we have structured fuzzing, and the mutator hands the fuzz target a data structure with pointers. If the target can modify that data structure at will, we\u0027ll need to allocate a new one every iteration; I don\u0027t think we can use this approach with two copies.\n\nWe could potentially enforce this by hashing the data before and after each call and stopping if the hashes don\u0027t match. Hashing should be at least marginally faster than allocating and garbage collecting.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 47
      },
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a502647_5c49821c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 28759
      },
      "writtenOn": "2021-10-04T20:57:15Z",
      "side": 1,
      "message": "\u003e Should we actually make this a requirement?\nI would lean towards no. I think it\u0027s pretty reasonable that a function could alter the underlying bytes, and that those kinds of functions are worth fuzzing. It\u0027s also minimal work to allow this, so it seems like we should try.\n\nYou make a fair point about structs. If we\u0027re concerned about this for structs, we can always make it requirement that you can\u0027t alter the data structure when fuzzing structs for example, but still allow it for []byte types. Wdyt?",
      "parentUuid": "c2537067_7a7e74d7",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 12,
        "endChar": 47
      },
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50f39648_fbf94774",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-30T19:27:27Z",
      "side": 1,
      "message": "SlowBots beginning. Status page: https://farmer.golang.org/try?commit\u003da2f679b4",
      "tag": "autogenerated:trybots~beginning",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fe9c845_57aa6220",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-30T19:27:27Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "230f3090_5d36e41d",
      "tag": "autogenerated:trybots~beginning",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a4bcec42_4a5b350a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-30T19:48:03Z",
      "side": 1,
      "message": "SlowBots are happy.\n\nSlowBot builds that ran:\n* linux-amd64-longtest\n* windows-amd64-longtest\n",
      "parentUuid": "50f39648_fbf94774",
      "tag": "autogenerated:trybots~happy",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fe4bda2_458ef3f8",
        "filename": "src/internal/fuzz/worker.go",
        "patchSetId": 2
      },
      "lineNbr": 623,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-10-04T19:22:41Z",
      "side": 1,
      "message": "Instead of allocating the slice lazily, could we define a workerServer constructor that creates it? I guess the challenge is knowing how many values there will be, but the caller ought to know that.",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0153b3e5_6ea9881d",
        "filename": "src/internal/fuzz/worker.go",
        "patchSetId": 2
      },
      "lineNbr": 629,
      "author": {
        "id": 17092
      },
      "writtenOn": "2021-10-04T19:22:41Z",
      "side": 1,
      "message": "Let\u0027s avoid allocating slice memory until we need it though. Instead of setting length and copying below, could do something like:\n\n   ws.scratchVals[i] \u003d append(ws.scratchVals[i].([]byte)[:0], v...)\n\nThat would reallocate the slice only if it\u0027s too small.",
      "revId": "a2f679b4123e65c31887bad98d9370fcfaf73f56",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}