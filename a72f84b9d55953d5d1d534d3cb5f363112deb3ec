{
  "comments": [
    {
      "key": {
        "uuid": "22f91579_7fc50859",
        "filename": "/COMMIT_MSG",
        "patchSetId": 11
      },
      "lineNbr": 1,
      "author": {
        "id": 5070
      },
      "writtenOn": "2017-04-17T07:19:12Z",
      "side": 1,
      "message": "Your parent is too old now. Please update this CL to the current tip.",
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ae733237_c3b71bc7",
        "filename": "src/runtime/os_windows.go",
        "patchSetId": 11
      },
      "lineNbr": 317,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-04-17T00:17:04Z",
      "side": 1,
      "message": "Given that this is a monotonic timer, does it matter to make it start with the beginning of the program? Wouldn\u0027t be possible to simply drop this qpcStartConter?",
      "range": {
        "startLine": 317,
        "startChar": 19,
        "endLine": 317,
        "endChar": 34
      },
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1d8785f6_ec0a866b",
        "filename": "src/runtime/os_windows.go",
        "patchSetId": 11
      },
      "lineNbr": 317,
      "author": {
        "id": 17055
      },
      "writtenOn": "2017-04-17T11:43:13Z",
      "side": 1,
      "message": "\u003e Given that this is a monotonic timer, does it matter to make it start with the beginning of the program? Wouldn\u0027t be possible to simply drop this qpcStartConter?\n\nIn theory, it would be safe to start this \u0027timer\u0027 from any point in time, but in practice this will damage time.String(), since its \u0027monotonic\u0027 part (m\u003dxxx) will have this weird offset instead of zero. With start counter it will start with zero.",
      "parentUuid": "ae733237_c3b71bc7",
      "range": {
        "startLine": 317,
        "startChar": 19,
        "endLine": 317,
        "endChar": 34
      },
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "437afee8_6ec01987",
        "filename": "src/runtime/os_windows.go",
        "patchSetId": 11
      },
      "lineNbr": 330,
      "author": {
        "id": 5070
      },
      "writtenOn": "2017-04-17T07:19:12Z",
      "side": 1,
      "message": "Reading doc from timeasm.go:\n```\nDeclarations for operating systems implementing time.now directly in assembly.\nThose systems are also expected to have nanotime subtract startNano,\nso that time.now and nanotime return the same monotonic clock readings.\n```\nI interpret that you should return\n\nnanotimeQPC() - startNano\n\nfor monotime. No?",
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3e476abb_ece8461a",
        "filename": "src/runtime/os_windows.go",
        "patchSetId": 11
      },
      "lineNbr": 330,
      "author": {
        "id": 17055
      },
      "writtenOn": "2017-04-17T11:43:13Z",
      "side": 1,
      "message": "\u003e Reading doc from timeasm.go:\n\u003e ```\n\u003e Declarations for operating systems implementing time.now directly in assembly.\n\u003e Those systems are also expected to have nanotime subtract startNano,\n\u003e so that time.now and nanotime return the same monotonic clock readings.\n\u003e ```\n\u003e I interpret that you should return\n\u003e \n\u003e nanotimeQPC() - startNano\n\u003e \n\u003e for monotime. No?\n\nstartNano is not used in wine (and it will be very close to zero anyway), basically \n(counter - qpcStartCounter) * qpcMultiplier\nis somewhat similar to nontime() - startNano, but scaled into qpc measures.",
      "parentUuid": "437afee8_6ec01987",
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4ed7af5_9fab3247",
        "filename": "src/runtime/sys_windows_386.s",
        "patchSetId": 11
      },
      "lineNbr": 445,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-04-17T00:17:04Z",
      "side": 1,
      "message": "Forward branche are statically predicted as not taken. dynamic prediction will eventually fix this, but given that the vast majority of users will run natively, you may want to move the wine branch at the end of the function.",
      "range": {
        "startLine": 445,
        "startChar": 1,
        "endLine": 445,
        "endChar": 8
      },
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5cbc9c4_aaffcfc3",
        "filename": "src/runtime/sys_windows_386.s",
        "patchSetId": 11
      },
      "lineNbr": 445,
      "author": {
        "id": 5070
      },
      "writtenOn": "2017-04-17T07:19:12Z",
      "side": 1,
      "message": "That is what Russ asked us to do (see Russ comment from Feb 28 and March 1). I know nothing about branch prediction, but what exactly are you proposing?",
      "parentUuid": "e4ed7af5_9fab3247",
      "range": {
        "startLine": 445,
        "startChar": 1,
        "endLine": 445,
        "endChar": 8
      },
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6254466c_92d9b15a",
        "filename": "src/runtime/sys_windows_386.s",
        "patchSetId": 11
      },
      "lineNbr": 445,
      "author": {
        "id": 17055
      },
      "writtenOn": "2017-04-17T11:53:17Z",
      "side": 1,
      "message": "I thought it is converted as is into native asm and thus it is CPU who runs the prediction, in this case it should be correctly predicted since this variable is not updated since the very beginning of the process lifetime.\n\nOr do you mean that dynamic prediction will evaluate runtimeÂ·nanotimeQPC(SB) anyway because of JE and not JNE?",
      "parentUuid": "f5cbc9c4_aaffcfc3",
      "range": {
        "startLine": 445,
        "startChar": 1,
        "endLine": 445,
        "endChar": 8
      },
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d692942_32a468b7",
        "filename": "src/runtime/sys_windows_386.s",
        "patchSetId": 11
      },
      "lineNbr": 445,
      "author": {
        "id": 5340
      },
      "writtenOn": "2017-04-17T16:18:58Z",
      "side": 1,
      "message": "I\u0027m simply suggesting to move the JMP runtime.nanotimeQPC line at the end of the function, with a new label, and changing the JE into JNE. Basically:\n\n   CMPB runtime.useQPCTime(SB), $0\n   JNE useQPC\n   [... normal function ... ]\n   RET\nuseQPC:\n   JMP runtime.nanotimeQPC(SB)\n\nIt\u0027s true that the branch will generally predict very well because it\u0027s always taken or not taken, depending on a condition that never mutates, but when the branch predictor is not warm, the general static prediction rules are to predict a forward branch as not taken. Given that the Wine use-case is rare, I\u0027m suggesting to statically predicting that we are not running under Wine.",
      "parentUuid": "6254466c_92d9b15a",
      "range": {
        "startLine": 445,
        "startChar": 1,
        "endLine": 445,
        "endChar": 8
      },
      "revId": "a72f84b9d55953d5d1d534d3cb5f363112deb3ec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}