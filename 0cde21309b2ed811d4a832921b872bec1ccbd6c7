{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "19814792_4a87f2f8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 53288
      },
      "writtenOn": "2022-04-28T12:36:18Z",
      "side": 1,
      "message": "For structure comparisons that are inlined by walk/compare.go, there is a performance improvement for cases where the size isnâ€™t a power of 2. Previously it called a runtime.memequal function which is a way slower than using 2-3 cmp instructions inline.\n\n\nFor structure comparison functions that are generated with reflectdata/alg.go we can notice a performance improvement even for cases where simplified versions of memequal are used (memequal{1/2/4/8/16}), since the geneq function is called after the inlining stage, memequal{1/2/4/8/16}, were not inlined so there were extra calls.",
      "revId": "0cde21309b2ed811d4a832921b872bec1ccbd6c7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f08c429e_973ea796",
        "filename": "src/cmd/compile/internal/compare/compare.go",
        "patchSetId": 1
      },
      "lineNbr": 141,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-04-28T16:49:59Z",
      "side": 1,
      "message": "Doing pointer math on uintptr here makes me nervous. Maybe it\u0027s ok because there are no calls between the uintptr cast and the conversion back to pointers?\nAny way we could use the new-ish unsafe.Add for this arithmetic?",
      "revId": "0cde21309b2ed811d4a832921b872bec1ccbd6c7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c960fad9_70bccd71",
        "filename": "src/cmd/compile/internal/compare/compare.go",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 5200
      },
      "writtenOn": "2022-04-28T16:49:59Z",
      "side": 1,
      "message": "We have to worry about alignment here. Some platforms can\u0027t do unaligned loads. e.g.  if this is 3 uint32 fields, we can\u0027t necessarily start with a uint64 comparison. I think you can condition on required alignment using base.Ctxt.Arch.Alignment (see cmd/internal/sys/arch.go).\n\nAnother option here is to just compare field-by-field as before (with len\u003c\u003d16 instead of len(s)\u003c\u003d2), and figure out how to combine comparisons in the optimizer somehow. That would help both this code and maybe user code as well.",
      "revId": "0cde21309b2ed811d4a832921b872bec1ccbd6c7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}