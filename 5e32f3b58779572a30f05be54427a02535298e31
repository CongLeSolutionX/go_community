{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dc439bd3_a32a917d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14020
      },
      "writtenOn": "2021-08-31T20:34:40Z",
      "side": 1,
      "message": "\nI pulled the patch and looked at the generated DWARF for the example that you put into your regression test.\n\nBuilding with tip (without your change) here is what I see for main.testfn[.shape.string]:\n\n \u003c1\u003e\u003c77e90\u003e: Abbrev Number: 3 (DW_TAG_subprogram)\n    \u003c77e91\u003e   DW_AT_name        : main.testfn[.shape.string]\n    \u003c77eac\u003e   DW_AT_low_pc      : 0x47d300\n    \u003c77eb4\u003e   DW_AT_high_pc     : 0x47d3f9\n    \u003c77ebc\u003e   DW_AT_frame_base  : 1 byte block: 9c \t(DW_OP_call_frame_cfa)\n    \u003c77ebe\u003e   DW_AT_decl_file   : 0x2\n    \u003c77ec2\u003e   DW_AT_external    : 1\n \u003c2\u003e\u003c77ec3\u003e: Abbrev Number: 16 (DW_TAG_formal_parameter)\n    \u003c77ec4\u003e   DW_AT_name        : arg\n    \u003c77ec8\u003e   DW_AT_variable_parameter: 0\n    \u003c77ec9\u003e   DW_AT_decl_line   : 5\n    \u003c77eca\u003e   DW_AT_type        : \u003c0x69416\u003e\n    \u003c77ece\u003e   DW_AT_location    : 0x8e3fe (location list)\n \u003c2\u003e\u003c77ed2\u003e: Abbrev Number: 11 (DW_TAG_variable)\n    \u003c77ed3\u003e   DW_AT_name        : mapvar\n    \u003c77eda\u003e   DW_AT_decl_line   : 6\n    \u003c77edb\u003e   DW_AT_type        : \u003c0x69448\u003e\n    \u003c77edf\u003e   DW_AT_location    : 0x8e45e (location list)\n \u003c2\u003e\u003c77ee3\u003e: Abbrev Number: 0\n\nwhere the type at 0x69448 looks like\n\n \u003c1\u003e\u003c69448\u003e: Abbrev Number: 32 (DW_TAG_typedef)\n    \u003c69449\u003e   DW_AT_name        : map[int]%2eshape.string\n    \u003c69461\u003e   DW_AT_type        : \u003c0x6cb63\u003e\n    \u003c69465\u003e   Unknown AT value: 2900: 21\n    \u003c69466\u003e   Unknown AT value: 2904: 0x96a0\n    \u003c6946e\u003e   Unknown AT value: 2901: \u003c0x58318\u003e\n    \u003c69472\u003e   Unknown AT value: 2902: \u003c0x69416\u003e\n\nThis plausible -- \"mapvar\" is after all a map type. It is obviously not perfect (in particular it doesn\u0027t work with dictionaries), but at least it\u0027s a map.\n\nWith your change, I see this:\n\n \u003c1\u003e\u003c77e90\u003e: Abbrev Number: 3 (DW_TAG_subprogram)\n    \u003c77e91\u003e   DW_AT_name        : main.testfn[.shape.string]\n    \u003c77eac\u003e   DW_AT_low_pc      : 0x47d300\n    \u003c77eb4\u003e   DW_AT_high_pc     : 0x47d3f9\n    \u003c77ebc\u003e   DW_AT_frame_base  : 1 byte block: 9c \t(DW_OP_call_frame_cfa)\n    \u003c77ebe\u003e   DW_AT_decl_file   : 0x2\n    \u003c77ec2\u003e   DW_AT_external    : 1\n \u003c2\u003e\u003c77ec3\u003e: Abbrev Number: 39 (DW_TAG_typedef)\n    \u003c77ec4\u003e   DW_AT_name        : .param0\n    \u003c77ecc\u003e   DW_AT_type        : \u003c0x69416\u003e\n    \u003c77ed0\u003e   Unknown AT value: 2906: 0\n \u003c2\u003e\u003c77ed1\u003e: Abbrev Number: 39 (DW_TAG_typedef)\n    \u003c77ed2\u003e   DW_AT_name        : .param1\n    \u003c77eda\u003e   DW_AT_type        : \u003c0x69448\u003e\n    \u003c77ede\u003e   Unknown AT value: 2906: 1\n \u003c2\u003e\u003c77edf\u003e: Abbrev Number: 16 (DW_TAG_formal_parameter)\n    \u003c77ee0\u003e   DW_AT_name        : arg\n    \u003c77ee4\u003e   DW_AT_variable_parameter: 0\n    \u003c77ee5\u003e   DW_AT_decl_line   : 5\n    \u003c77ee6\u003e   DW_AT_type        : \u003c0x77ec3\u003e\n    \u003c77eea\u003e   DW_AT_location    : 0x8e3fe (location list)\n \u003c2\u003e\u003c77eee\u003e: Abbrev Number: 11 (DW_TAG_variable)\n    \u003c77eef\u003e   DW_AT_name        : mapvar\n    \u003c77ef6\u003e   DW_AT_decl_line   : 6\n    \u003c77ef7\u003e   DW_AT_type        : \u003c0x77ed1\u003e                 \u003c\u003c\u003c HERE\n    \u003c77efb\u003e   DW_AT_location    : 0x8e45e (location list)\n \u003c2\u003e\u003c77eff\u003e: Abbrev Number: 0\n\n\nNote the DW_AT_type attribute for the mapvar DIE (marked \"HERE\") -- it now points to 0x77ed1, which is definitely not a map type DIE (it\u0027s just a direct reference the new \"param0\" typedef). This doesn\u0027t seem right.\n\nIt is worth pointing out that type synthesis for maps (and channels, and other things like that) is done in the linker currently. (e.g. things like https://go.googlesource.com/go/+/d7e2e2ec2b2a11c2bfb98a27c03d0dccba62c4fb/src/cmd/link/internal/ld/dwarf.go#875 ).  In order for the linker to emit the proper map type DIE, that type synthesis code would need to be able to discover the type here somehow (e.g. \".param0\").\n\nOne thing that we (compiler+linker team) have talked about for a while is the possibility of moving DWARF type DIE generation out of the linker and into the compiler (it is a messy job, but I think it is doable). I wonder if this might be the time to seriously think about doing that? Or is there a way to pass enough info along to the linker that it can do the right thing?\n",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "60cceb28_488ae551",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2021-09-01T08:24:57Z",
      "side": 1,
      "message": "The point of this CL is to add an attribute to variables that have a parametric type that would tell a debugger aware about it where to look in the dictionary for the real type of the variable.\n\nNote that the DW_AT_type attribute of .param1 still references the map type so a debugger that is unaware could still use that. However I checked with gdb and it doesn\u0027t do that, so that\u0027s an actual problem. I don\u0027t know how much of a problem that is, though, because if you do this:\n\n    testfn(\u0026somestruct{ ... })\n    \nthe instantiation of testfn will use .shape.*uint8 and map[int]%2eshape.*uint8 which isn\u0027t going to be very useful anyway.\n\nThe other solution would be to put the DW_AT_go_dict_index on the variables themselves, I just didn\u0027t do that because of how messy abbrev selection already is.\n\n\u003e I wonder if this might be the time to seriously think about doing that? Or is there a way to pass enough info along to the linker that it can do the right thing?\n\nI\u0027m not sure what you have in mind here.",
      "parentUuid": "dc439bd3_a32a917d",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a87b089f_ca5dd5a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14020
      },
      "writtenOn": "2021-09-01T13:15:25Z",
      "side": 1,
      "message": "\u003e Note that the DW_AT_type attribute of .param1 still references the map type so a debugger that is unaware could still use that. However I checked with gdb and it doesn\u0027t do that, so that\u0027s an actual problem. I don\u0027t know how much of a problem that is, though, because if you do this:\n\u003e \n\u003e     testfn(\u0026somestruct{ ... })\n\u003e     \n\u003e the instantiation of testfn will use .shape.*uint8 and map[int]%2eshape.*uint8 which isn\u0027t going to be very useful anyway.\n\u003e \n\u003e The other solution would be to put the DW_AT_go_dict_index on the variables themselves, I just didn\u0027t do that because of how messy abbrev selection already is.\n\nI see. Yes, it does look like \".param1\" points to the map type DIE. I guess I wonder whether this will generalize-- so for example, consider this somewhat more complicated code in which the map refers to two type parameters, not one:\n\n   package main\n\n   import \"fmt\"\n\n   type Apple int\n   type Orange int\n   type Pear int\n\n   func testfn[K comparable, J comparable, L comparable](karg K, jarg J, larg L) {\n\t   var mapvar \u003d make(map[K]J)\n\t   mapvar[karg] \u003d jarg\n\t   fmt.Println(mapvar)\n\t   var mapvar2 \u003d make(map[J]L)\n\t   mapvar2[jarg] \u003d larg\n\t   fmt.Println(mapvar2)\n   }\n\n   func main() {\n\t   testfn(Apple(42), Orange(43), Pear(101))\n\t   testfn(Orange(43), Pear(101), Apple(33))\n   }\n\nI compiled this and it looks as though the type for \"mapvar\" points at this DIE:\n\n \u003c2\u003e\u003c77f0a\u003e: Abbrev Number: 39 (DW_TAG_typedef)\n    \u003c77f0b\u003e   DW_AT_name        : .param3\n    \u003c77f13\u003e   DW_AT_type        : \u003c0x6942f\u003e\n    \u003c77f17\u003e   Unknown AT value: 2906: 3\n\nThis DIE above has a single instance of DW_AT_go_dict_index even though the variable in question refers to two type params: in order for the debugger to have complete information on the type it would need both.  [ For maps etc it isn\u0027t clear whether this really buys you anything, but maybe in other cases like structs it might be more important ].\n\n\n\u003e \u003e I wonder if this might be the time to seriously think about doing that? Or is there a way to pass enough info along to the linker that it can do the right thing?\n\u003e \n\u003e I\u0027m not sure what you have in mind here.\n\nThis is just the first time we\u0027re having the compiler emit an actual type DIE -- used to be that those were only generated in the linker.  Not that I think this is a bad thing, on the contrary I think it\u0027s a good thing, just wondering if it might make sense to start thinking about moving even more type DIE generation into the compiler (since it will improve link times); this is something we\u0027ve talked about periodically.",
      "parentUuid": "60cceb28_488ae551",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2efa141_0a023586",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2021-09-01T15:01:35Z",
      "side": 1,
      "message": "\u003e \u003e Note that the DW_AT_type attribute of .param1 still references the map type so a debugger that is unaware could still use that. However I checked with gdb and it doesn\u0027t do that, so that\u0027s an actual problem. I don\u0027t know how much of a problem that is, though, because if you do this:\n\u003e \u003e \n\u003e \u003e     testfn(\u0026somestruct{ ... })\n\u003e \u003e     \n\u003e \u003e the instantiation of testfn will use .shape.*uint8 and map[int]%2eshape.*uint8 which isn\u0027t going to be very useful anyway.\n\u003e \u003e \n\u003e \u003e The other solution would be to put the DW_AT_go_dict_index on the variables themselves, I just didn\u0027t do that because of how messy abbrev selection already is.\n\u003e \n\u003e I see. Yes, it does look like \".param1\" points to the map type DIE. I guess I wonder whether this will generalize-- so for example, consider this somewhat more complicated code in which the map refers to two type parameters, not one:\n\u003e \n\u003e    package main\n\u003e \n\u003e    import \"fmt\"\n\u003e \n\u003e    type Apple int\n\u003e    type Orange int\n\u003e    type Pear int\n\u003e \n\u003e    func testfn[K comparable, J comparable, L comparable](karg K, jarg J, larg L) {\n\u003e \t   var mapvar \u003d make(map[K]J)\n\u003e \t   mapvar[karg] \u003d jarg\n\u003e \t   fmt.Println(mapvar)\n\u003e \t   var mapvar2 \u003d make(map[J]L)\n\u003e \t   mapvar2[jarg] \u003d larg\n\u003e \t   fmt.Println(mapvar2)\n\u003e    }\n\u003e \n\u003e    func main() {\n\u003e \t   testfn(Apple(42), Orange(43), Pear(101))\n\u003e \t   testfn(Orange(43), Pear(101), Apple(33))\n\u003e    }\n\u003e \n\u003e I compiled this and it looks as though the type for \"mapvar\" points at this DIE:\n\u003e \n\u003e  \u003c2\u003e\u003c77f0a\u003e: Abbrev Number: 39 (DW_TAG_typedef)\n\u003e     \u003c77f0b\u003e   DW_AT_name        : .param3\n\u003e     \u003c77f13\u003e   DW_AT_type        : \u003c0x6942f\u003e\n\u003e     \u003c77f17\u003e   Unknown AT value: 2906: 3\n\u003e \n\u003e This DIE above has a single instance of DW_AT_go_dict_index even though the variable in question refers to two type params: in order for the debugger to have complete information on the type it would need both.  [ For maps etc it isn\u0027t clear whether this really buys you anything, but maybe in other cases like structs it might be more important ].\n\nMy understanding is that the dictionary will have an entry for every derived parametric type so if I looked up entry number 3 of the dictionary I would get a *runtime._type for the map type, fully instantiated, in this case `map[main.Apple]main.Orange`.\nIs this wrong?\nIncidentally trying to verify this I discovered that I can\u0027t turn the *runtime._type into a DIE because no DIEs are emitted for types that are used like this, for example the above code doesn\u0027t even have a DIE for main.Apple, let alone map[main.Apple]main.Orange.\n\nTo give more context: I\u0027m trying to make this process (figuring out the real type of an instantiated parametric type) similar to what delve does with the data field of interfaces: we take the *runtime._type field of the interface and use the DW_AT_go_runtime_type to convert it into a DIE.\n\n\u003e \u003e \u003e I wonder if this might be the time to seriously think about doing that? Or is there a way to pass enough info along to the linker that it can do the right thing?\n\u003e \u003e \n\u003e \u003e I\u0027m not sure what you have in mind here.\n\u003e \n\u003e This is just the first time we\u0027re having the compiler emit an actual type DIE -- used to be that those were only generated in the linker.  Not that I think this is a bad thing, on the contrary I think it\u0027s a good thing, just wondering if it might make sense to start thinking about moving even more type DIE generation into the compiler (since it will improve link times); this is something we\u0027ve talked about periodically.",
      "parentUuid": "a87b089f_ca5dd5a7",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5fa7ea0b_8f1c24ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14020
      },
      "writtenOn": "2021-09-01T15:18:30Z",
      "side": 1,
      "message": "\u003e My understanding is that the dictionary will have an entry for every derived parametric type so if I looked up entry number 3 of the dictionary I would get a *runtime._type for the map type, fully instantiated, in this case `map[main.Apple]main.Orange`.\n\u003e Is this wrong?\n\nRight, of course. Yes, that makes sense (my misunderstanding).\n\n\n\u003e Incidentally trying to verify this I discovered that I can\u0027t turn the *runtime._type into a DIE because no DIEs are emitted for types that are used like this, for example the above code doesn\u0027t even have a DIE for main.Apple, let alone map[main.Apple]main.Orange.\n\nIndeed. I think this is related to \n\nhttps://github.com/golang/go/issues/46670",
      "parentUuid": "f2efa141_0a023586",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30593899_507852e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14020
      },
      "writtenOn": "2021-09-01T15:27:45Z",
      "side": 1,
      "message": "DWARF changes look good. I am less familiar with noder/ir/stencil stuff.",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1fe8be6b_d4de6e72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-01T15:28:17Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d5e32f3b5",
      "tag": "autogenerated:trybots~beginning",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65fb435e_3e486cf0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-01T15:37:08Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003d5e32f3b5\nFailed on linux-amd64-unified: https://storage.googleapis.com/go-build-log/5e32f3b5/linux-amd64-unified_bbd83fc7.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "1fe8be6b_d4de6e72",
      "tag": "autogenerated:trybots~progress",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5c44d64_6ad0a32e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-09-01T15:39:48Z",
      "side": 1,
      "message": "1 of 26 TryBots failed.\nFailed on linux-amd64-unified: https://storage.googleapis.com/go-build-log/5e32f3b5/linux-amd64-unified_bbd83fc7.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\n",
      "parentUuid": "1fe8be6b_d4de6e72",
      "tag": "autogenerated:trybots~failed",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81a5e3fa_a4cd6c0a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-09-01T16:28:47Z",
      "side": 1,
      "message": "ir/stencil changes look good!\n\nThe unified IR experiment doesn\u0027t support dictionaries yet, so you may need to disable the TestDictIndex for that case.  Matthew, if that seems right, what is the best way to skip that test in the case of GOEXPERIMENT\u003dunified?\n\n",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7279d734_312a82de",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5167
      },
      "writtenOn": "2021-09-02T13:43:52Z",
      "side": 1,
      "message": "We\u0027ve talked about only emitting derived types when a function actually needs the rtype (e.g., when the type goes into an interface or gets used for new/make) just to reduce the size of dictionaries. Given that it\u0027s not even clear right now how much that would save and it clearly makes debugging harder, we decided not to do it for now, but if the overhead turns out to be significant, we may have to revisit that.\n\n*If* we wind up going down that path, I think the DWARF would probably have to push the dictionary-placeholder types down the DIE tree. E.g., a map[T]U derived type would look like a regular map type DIE that points to a shape type DIE for T, where T\u0027s type DIE has the DW_AT_go_dict_index attribute (and likewise for U). The result would be sort of a mix of DIE-based types and rtype-based types.\n\nNot something we have to solve right now, I just wanted to share our thinking.",
      "parentUuid": "5fa7ea0b_8f1c24ce",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d294cee_78cb5cd3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2021-09-03T09:51:52Z",
      "side": 1,
      "message": "sgtm",
      "parentUuid": "7279d734_312a82de",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76c2fa78_9c6bc2c7",
        "filename": "src/cmd/compile/internal/ir/name.go",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 28783
      },
      "writtenOn": "2021-09-01T16:28:47Z",
      "side": 1,
      "message": "Is it worth making this a unt16 and moving it to right after line 42?  Then there would be no extra cost for this new field on 64-bit architectures, as things are currently arranged, since it will fill in the padding spot after the flags field.  This is nice, since ir.Name nodes are quite common.\n\nProbably not worth optimizing right now if it is at all a pain to make the DictIndex field be a uint16.",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "51ed0491_e3779efb",
        "filename": "src/cmd/compile/internal/ir/name.go",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 5821
      },
      "writtenOn": "2021-09-03T09:51:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "76c2fa78_9c6bc2c7",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f590ccb4_4dc170f3",
        "filename": "src/cmd/internal/dwarf/dwarf.go",
        "patchSetId": 2
      },
      "lineNbr": 367,
      "author": {
        "id": 14020
      },
      "writtenOn": "2021-09-01T15:24:49Z",
      "side": 1,
      "message": "I think it might be better to choose a different name for this.  Folks may interpret PARAM_TYPE as \"the type of a formal parameter\" as opposed to \"subtype/typedef that supplies dictionary index\". Maybe you could call it DICT_INDEX_TYPE?",
      "range": {
        "startLine": 367,
        "startChar": 1,
        "endLine": 367,
        "endChar": 19
      },
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53a3a766_83f445af",
        "filename": "src/cmd/link/internal/ld/dwarf_test.go",
        "patchSetId": 2
      },
      "lineNbr": 1768,
      "author": {
        "id": 5440
      },
      "writtenOn": "2021-09-01T18:36:38Z",
      "side": 1,
      "message": "I think you can add a check here:\n\n```\nif buildcfg.Unified !\u003d 0 {\n  t.Skip(\"GOEXPERIMENT\u003dunified does not emit dictionaries yet\")\n}\n```",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ad507f9_6f9831c9",
        "filename": "src/cmd/link/internal/ld/dwarf_test.go",
        "patchSetId": 2
      },
      "lineNbr": 1768,
      "author": {
        "id": 5821
      },
      "writtenOn": "2021-09-03T09:51:52Z",
      "side": 1,
      "message": "Did you mean goexperiment.Unified?",
      "parentUuid": "53a3a766_83f445af",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e2d8221_46ecb147",
        "filename": "src/cmd/link/internal/ld/dwarf_test.go",
        "patchSetId": 2
      },
      "lineNbr": 1768,
      "author": {
        "id": 5821
      },
      "writtenOn": "2021-09-03T09:51:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "53a3a766_83f445af",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}