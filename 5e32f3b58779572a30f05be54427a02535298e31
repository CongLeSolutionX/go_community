{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dc439bd3_a32a917d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14020
      },
      "writtenOn": "2021-08-31T20:34:40Z",
      "side": 1,
      "message": "\nI pulled the patch and looked at the generated DWARF for the example that you put into your regression test.\n\nBuilding with tip (without your change) here is what I see for main.testfn[.shape.string]:\n\n \u003c1\u003e\u003c77e90\u003e: Abbrev Number: 3 (DW_TAG_subprogram)\n    \u003c77e91\u003e   DW_AT_name        : main.testfn[.shape.string]\n    \u003c77eac\u003e   DW_AT_low_pc      : 0x47d300\n    \u003c77eb4\u003e   DW_AT_high_pc     : 0x47d3f9\n    \u003c77ebc\u003e   DW_AT_frame_base  : 1 byte block: 9c \t(DW_OP_call_frame_cfa)\n    \u003c77ebe\u003e   DW_AT_decl_file   : 0x2\n    \u003c77ec2\u003e   DW_AT_external    : 1\n \u003c2\u003e\u003c77ec3\u003e: Abbrev Number: 16 (DW_TAG_formal_parameter)\n    \u003c77ec4\u003e   DW_AT_name        : arg\n    \u003c77ec8\u003e   DW_AT_variable_parameter: 0\n    \u003c77ec9\u003e   DW_AT_decl_line   : 5\n    \u003c77eca\u003e   DW_AT_type        : \u003c0x69416\u003e\n    \u003c77ece\u003e   DW_AT_location    : 0x8e3fe (location list)\n \u003c2\u003e\u003c77ed2\u003e: Abbrev Number: 11 (DW_TAG_variable)\n    \u003c77ed3\u003e   DW_AT_name        : mapvar\n    \u003c77eda\u003e   DW_AT_decl_line   : 6\n    \u003c77edb\u003e   DW_AT_type        : \u003c0x69448\u003e\n    \u003c77edf\u003e   DW_AT_location    : 0x8e45e (location list)\n \u003c2\u003e\u003c77ee3\u003e: Abbrev Number: 0\n\nwhere the type at 0x69448 looks like\n\n \u003c1\u003e\u003c69448\u003e: Abbrev Number: 32 (DW_TAG_typedef)\n    \u003c69449\u003e   DW_AT_name        : map[int]%2eshape.string\n    \u003c69461\u003e   DW_AT_type        : \u003c0x6cb63\u003e\n    \u003c69465\u003e   Unknown AT value: 2900: 21\n    \u003c69466\u003e   Unknown AT value: 2904: 0x96a0\n    \u003c6946e\u003e   Unknown AT value: 2901: \u003c0x58318\u003e\n    \u003c69472\u003e   Unknown AT value: 2902: \u003c0x69416\u003e\n\nThis plausible -- \"mapvar\" is after all a map type. It is obviously not perfect (in particular it doesn\u0027t work with dictionaries), but at least it\u0027s a map.\n\nWith your change, I see this:\n\n \u003c1\u003e\u003c77e90\u003e: Abbrev Number: 3 (DW_TAG_subprogram)\n    \u003c77e91\u003e   DW_AT_name        : main.testfn[.shape.string]\n    \u003c77eac\u003e   DW_AT_low_pc      : 0x47d300\n    \u003c77eb4\u003e   DW_AT_high_pc     : 0x47d3f9\n    \u003c77ebc\u003e   DW_AT_frame_base  : 1 byte block: 9c \t(DW_OP_call_frame_cfa)\n    \u003c77ebe\u003e   DW_AT_decl_file   : 0x2\n    \u003c77ec2\u003e   DW_AT_external    : 1\n \u003c2\u003e\u003c77ec3\u003e: Abbrev Number: 39 (DW_TAG_typedef)\n    \u003c77ec4\u003e   DW_AT_name        : .param0\n    \u003c77ecc\u003e   DW_AT_type        : \u003c0x69416\u003e\n    \u003c77ed0\u003e   Unknown AT value: 2906: 0\n \u003c2\u003e\u003c77ed1\u003e: Abbrev Number: 39 (DW_TAG_typedef)\n    \u003c77ed2\u003e   DW_AT_name        : .param1\n    \u003c77eda\u003e   DW_AT_type        : \u003c0x69448\u003e\n    \u003c77ede\u003e   Unknown AT value: 2906: 1\n \u003c2\u003e\u003c77edf\u003e: Abbrev Number: 16 (DW_TAG_formal_parameter)\n    \u003c77ee0\u003e   DW_AT_name        : arg\n    \u003c77ee4\u003e   DW_AT_variable_parameter: 0\n    \u003c77ee5\u003e   DW_AT_decl_line   : 5\n    \u003c77ee6\u003e   DW_AT_type        : \u003c0x77ec3\u003e\n    \u003c77eea\u003e   DW_AT_location    : 0x8e3fe (location list)\n \u003c2\u003e\u003c77eee\u003e: Abbrev Number: 11 (DW_TAG_variable)\n    \u003c77eef\u003e   DW_AT_name        : mapvar\n    \u003c77ef6\u003e   DW_AT_decl_line   : 6\n    \u003c77ef7\u003e   DW_AT_type        : \u003c0x77ed1\u003e                 \u003c\u003c\u003c HERE\n    \u003c77efb\u003e   DW_AT_location    : 0x8e45e (location list)\n \u003c2\u003e\u003c77eff\u003e: Abbrev Number: 0\n\n\nNote the DW_AT_type attribute for the mapvar DIE (marked \"HERE\") -- it now points to 0x77ed1, which is definitely not a map type DIE (it\u0027s just a direct reference the new \"param0\" typedef). This doesn\u0027t seem right.\n\nIt is worth pointing out that type synthesis for maps (and channels, and other things like that) is done in the linker currently. (e.g. things like https://go.googlesource.com/go/+/d7e2e2ec2b2a11c2bfb98a27c03d0dccba62c4fb/src/cmd/link/internal/ld/dwarf.go#875 ).  In order for the linker to emit the proper map type DIE, that type synthesis code would need to be able to discover the type here somehow (e.g. \".param0\").\n\nOne thing that we (compiler+linker team) have talked about for a while is the possibility of moving DWARF type DIE generation out of the linker and into the compiler (it is a messy job, but I think it is doable). I wonder if this might be the time to seriously think about doing that? Or is there a way to pass enough info along to the linker that it can do the right thing?\n",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "60cceb28_488ae551",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5821
      },
      "writtenOn": "2021-09-01T08:24:57Z",
      "side": 1,
      "message": "The point of this CL is to add an attribute to variables that have a parametric type that would tell a debugger aware about it where to look in the dictionary for the real type of the variable.\n\nNote that the DW_AT_type attribute of .param1 still references the map type so a debugger that is unaware could still use that. However I checked with gdb and it doesn\u0027t do that, so that\u0027s an actual problem. I don\u0027t know how much of a problem that is, though, because if you do this:\n\n    testfn(\u0026somestruct{ ... })\n    \nthe instantiation of testfn will use .shape.*uint8 and map[int]%2eshape.*uint8 which isn\u0027t going to be very useful anyway.\n\nThe other solution would be to put the DW_AT_go_dict_index on the variables themselves, I just didn\u0027t do that because of how messy abbrev selection already is.\n\n\u003e I wonder if this might be the time to seriously think about doing that? Or is there a way to pass enough info along to the linker that it can do the right thing?\n\nI\u0027m not sure what you have in mind here.",
      "parentUuid": "dc439bd3_a32a917d",
      "revId": "5e32f3b58779572a30f05be54427a02535298e31",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}