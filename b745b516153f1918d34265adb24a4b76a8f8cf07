{
  "comments": [
    {
      "key": {
        "uuid": "b8239a88_b582a6ad",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1016,
      "author": {
        "id": 5206
      },
      "writtenOn": "2019-03-11T23:20:17Z",
      "side": 1,
      "message": "Won\u0027t the atomic.Store on the next line ensure that this store is pushed out to all processors?  Or, for that matter, the unlock(\u0026sched.lock) below?\n\nI can see the use of the atomic.Load below, since it is called when sched.lock is not held.  Similarly I can see the use of an atomic.Load in exitsyscallfast, though this CL doesn\u0027t have that.  But I can\u0027t see the use of an atomic.Store here.",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b81b88a0_5810e337",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1016,
      "author": {
        "id": 27994
      },
      "writtenOn": "2019-03-12T07:54:17Z",
      "side": 1,
      "message": "That was my guess too. But Martin suggested that it could be safer to have it.",
      "parentUuid": "b8239a88_b582a6ad",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "111df3df_ff17327d",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1016,
      "author": {
        "id": 16006
      },
      "writtenOn": "2019-03-18T10:54:50Z",
      "side": 1,
      "message": "While the other atomic stores/locks might impose an ordering/visibility sufficient for shed.stopwait it looks to be only implicit. Future additions of code or refactoring might miss that sched.stopwait needs to be atomically stored as its otherwise not explicitly stated locally if the atomic.Store is simply removed. If the unlock(\u0026sched.lock) is sufficient to provide all memory guarantees it might be good to document that and also why it is not sufficient for sched.gcwaiting.",
      "parentUuid": "b81b88a0_5810e337",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "adbd0124_d8b5d729",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1016,
      "author": {
        "id": 27994
      },
      "writtenOn": "2019-04-12T08:01:56Z",
      "side": 1,
      "message": "Austin, should this atomic.Store be removed to ? If yes, why is it needed for sched.gcwaiting then ?",
      "parentUuid": "111df3df_ff17327d",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ccc17392_3f381db6",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1016,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-04-12T14:11:21Z",
      "side": 1,
      "message": "Actually, yes, I think this atomic.Store is unnecessary, too. Martin has a good point in general, but in this case it\u0027s not about the atomic.Store on the next line acting as a memory barrier. All of the reads of sched.stopwait are protected by sched.lock except the sanity check on line 1060 below.\n\nsched.gcwaiting, in contrast, is regularly read without sched.lock.",
      "parentUuid": "adbd0124_d8b5d729",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f19c0709_d97eedc7",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-04-12T14:11:21Z",
      "side": 1,
      "message": "If this is indeed necessary, that bothers me. It suggests that notewakeup / notetsleep don\u0027t form a happens-before edge. What should be happening is that the thread that decrements stopwait to 0 then calls notewakeup on stopnote (the 0 write locally happens before notewakeup), and then notetsleep above succeeds (notewakeup happens-before notetsleep succeeds), so the decrement should be visible to this read.",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a5150eb_c5dc0e97",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 27994
      },
      "writtenOn": "2019-04-15T11:29:20Z",
      "side": 1,
      "message": "Indeed, it should. We (I and a colleague) have looked at the assembly generated but nothing seems to be the root of this problem. We\u0027ve a doubt about the lwsync instruction in the atomic.Casuninptr of notetsleep_internal. It\u0027s a lighter version of the hwsync (which is created by atomic.Load) and should block the reordering of load/store. However, is the cache syncs between all CPUs ? We don\u0027t know yet... \nIt might also be a problem with our semasleep/semawakeup implementation..  \n\nAnyway, if even the root cause isn\u0027t yet known on AIX, the code without atomic.Load seems to make some assumptions about notetsleep/noteclear which have a different implementation on almost each OSes. \nMoreover, what is preventing the compiler to used a value previously stored in a register during the \"wait\" creation instead of reloading it. That\u0027s not the case on aix/ppc64 but it might happen one day (expect if the unlock is preventing such a thing). \nThis might be the best possible implementation, but isn\u0027t it safer to keep this atomic.Load anyway ? \n\nI will continue to search what is wrong with aix/ppc64 as it maybe a wider bug (one maybe also triggers all the acquirep bugs). But, this patch is still important as it will prevent half of the crash in the AIX builder. And if the root cause is found, it might be removed if you wish to.",
      "parentUuid": "f19c0709_d97eedc7",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3976039_cb45f064",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-04-15T18:15:58Z",
      "side": 1,
      "message": "\u003e the code without atomic.Load seems to make some assumptions about notetsleep/noteclear which have a different implementation on almost each OSes.\n\nIt requires that notetsleep creates a happens-before edge, but that\u0027s not an assumption, that\u0027s a guarantee of notetsleep. Are you thinking of another assumption it\u0027s making?\n\n\u003e Moreover, what is preventing the compiler to used a value previously stored in a register during the \"wait\" creation instead of reloading it.\n\nIf wait is false, it could in principle use a cached version of sched.stopwait, but that would be fine (since wait \u003d\u003d false \u003d\u003d\u003e sched.stopwait \u003d 0). If wait is true, then we call notetsleep and since that\u0027s a synchronization operation, the compiler would not be allowed to cache sched.stopwait in that path, no matter how aggressive the optimizer was.\n\nWe can go ahead and do the atomic load here, but there should be a comment explaining that this shouldn\u0027t be necessary and is working around an unknown bug on AIX.",
      "parentUuid": "7a5150eb_c5dc0e97",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8d9e813_8c0579a6",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 5065
      },
      "writtenOn": "2019-04-15T18:19:03Z",
      "side": 1,
      "message": "If we do that, I\u0027d prefer to only do so on GOOS \u003d\u003d \"aix\" which will not only make that super obvious, but will also prevent new bugs from slipping in on other GOOSes that accidentally start relying on an atomic Load here.",
      "parentUuid": "b3976039_cb45f064",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e585e3d_7b35eb50",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 27994
      },
      "writtenOn": "2019-04-16T14:15:08Z",
      "side": 1,
      "message": "\u003e It requires that notetsleep creates a happens-before edge, but that\u0027s not an assumption, that\u0027s a guarantee of notetsleep. Are you thinking of another assumption it\u0027s making?\n\nWhich parts in lock_sema.go is making such guarantee ? The atomic.Loaduintptr in notewakeup and the first atomic.Casuinptr in notetsleep_internal ? If yes, the bug might be related to atomic.Casuinptr which isn\u0027t using the \"strongest\" sync instruction of PPC. But I need to make some experimentation to be sure. \n\nAnyway, I\u0027ve updated this patch to impact only AIX. And If I ever find the root cause I\u0027ll submit another CL.",
      "parentUuid": "b8d9e813_8c0579a6",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dff5cad0_1f77b016",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 5206
      },
      "writtenOn": "2019-04-16T14:45:15Z",
      "side": 1,
      "message": "As I understand it, in C++ memory model terms, the Casuintptr in notewakeup should be a release and the Casuintptr in notetsleep_internal should be an acquire (https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering).  That is, Casuintptr should be an acquire-release operation.  Or, the semawakeup in notewakeup should be a release and the semasleep in notetsleep_internal should be an acquire.\n\nRight now Casuintptr on PPC64 uses an LWSYNC instruction after what cmd/asm calls the STDCCC instruction.  It\u0027s interesting to note that for the corresponding function in GCC, when using __ATOMIC_ACQ_REL, GCC generates an ISYNC instruction rather than LWSYNC after STDCCC.  The Go implementation was changed to use LWSYNC rather than ISYNC in CL 95175 for issue #21348.\n\nI don\u0027t know what is correct.  It would be interesting to know whether the problems you see are fixed by using ISYNC rather than LWSYNC for the second synchronization instruction in Casuintptr.",
      "parentUuid": "9e585e3d_7b35eb50",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6439971a_6a7a7c66",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 27994
      },
      "writtenOn": "2019-04-16T15:06:33Z",
      "side": 1,
      "message": "I\u0027ll check with ISYNC tonight and keep you update if the bug has happened. \n\nI\u0027m gonna ping Carlos and Lynn which might have a better idea of what\u0027s going on with ISYNC/LWSYNC instructions. I don\u0027t know enough PowerPC to know how LWSYNC is acting on threads running on other CPUs compared to ISYNC or HWSYNC.",
      "parentUuid": "dff5cad0_1f77b016",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a151c538_44fc4764",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1060,
      "author": {
        "id": 13015
      },
      "writtenOn": "2019-04-16T16:47:27Z",
      "side": 1,
      "message": "LWSYNC is safe to use there if the memory is not cache-inhibited, which seems the case here. Could you please check if SYNC works? If that works, I\u0027m missing something here.",
      "parentUuid": "6439971a_6a7a7c66",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93158980_f7ac01c2",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1345,
      "author": {
        "id": 5206
      },
      "writtenOn": "2019-03-11T23:20:17Z",
      "side": 1,
      "message": "I don\u0027t see the use of this atomic.Store either, since sched.lock is held.  The atomic.Load below makes sense.",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b9d4e0d_4dc0a7a4",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1345,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-04-11T19:12:46Z",
      "side": 1,
      "message": "I agree. All sched.safePointWait reads and writes except the one below are protected by sched.lock.",
      "parentUuid": "93158980_f7ac01c2",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "738dc459_58cad53c",
        "filename": "src/runtime/proc.go",
        "patchSetId": 3
      },
      "lineNbr": 1403,
      "author": {
        "id": 5167
      },
      "writtenOn": "2019-04-11T19:12:46Z",
      "side": 1,
      "message": "Add a comment saying why this one is an atomic load.\n\nOr move it into the block that holds sched.lock a few lines down.",
      "revId": "b745b516153f1918d34265adb24a4b76a8f8cf07",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}