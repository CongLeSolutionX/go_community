{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a996eaf8_d00eaa44",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-06-21T22:22:21Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d92e764b6",
      "tag": "autogenerated:trybots~beginning",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "067ed1f7_8d019dd7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-06-21T22:22:21Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "fc9a6a5e_4d05824d",
      "tag": "autogenerated:trybots~beginning",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c117d9f_7d720b69",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 18
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-06-21T22:46:10Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "a996eaf8_d00eaa44",
      "tag": "autogenerated:trybots~happy",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f9ed09c_ed04184c",
        "filename": "src/cmd/go/internal/modload/buildlist.go",
        "patchSetId": 18
      },
      "lineNbr": 43,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "To help reason about changes to the module graph during iteration, I\u0027ve been trying to keep the structure of the Requirements type as close as possible to the structure of the underlying graph.\n\nIn the context of multi-module workspaces, I think that implies either factoring out the `depth`, `rootModules`, and `direct` fields into per-main-module structs, or perhaps having rootModules be identical to MainModules.versions in workspace mode.",
      "range": {
        "startLine": 42,
        "startChar": 19,
        "endLine": 43,
        "endChar": 11
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec93e1b9_f0089f43",
        "filename": "src/cmd/go/internal/modload/buildlist.go",
        "patchSetId": 18
      },
      "lineNbr": 274,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "This doesn\u0027t look right to me. Each main module should require only the dependencies listed in its own go.mod file — otherwise `go mod graph` will be very misleading, and I think we\u0027ll end up leaning on `go mod graph` fairly heavily for debugging in workspace mode.",
      "range": {
        "startLine": 273,
        "startChar": 0,
        "endLine": 274,
        "endChar": 60
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "056e7390_7a4d67b4",
        "filename": "src/cmd/go/internal/modload/buildlist.go",
        "patchSetId": 18
      },
      "lineNbr": 528,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "Actually, this brings up an interesting question, I think.\n\nIf the user runs `go mod tidy` in workspace mode, and the packages missing in the current module are provided at a specific version by some *other* module in the workspace, should we add that version, or resolve an entirely new one?\n\nI think perhaps we should add the version required by the other module, because that is the version the user is already building and testing against.\n\nIf so, that implies that we need two different pieces of information:\n• Which modules are in the workspace?\n• Which of those modules (if any) is “the main module”?\n\nThen, `go mod tidy` would consist of:\n\n1. Load the module requirements of the entire workspace.\n2. Load the transitive closure of packages imported by the (singular) main module, resolving any missing dependencies by adding requirements to the module graph.\n3. Update the requirements for the main module (only) by preserving the versions for packages in (2). If we need to iterate,¹ iterate by reloading the full workspace graph (not just the main module\u0027s requirement graph) until the roots of the main module converge.\n\n\n¹https://github.com/golang/go/blob/c080d0323bce56e25622a51dffecf756758c95a1/src/cmd/go/internal/modload/load.go#L1244-L1285",
      "range": {
        "startLine": 525,
        "startChar": 0,
        "endLine": 528,
        "endChar": 40
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e086ba0_dbbb6093",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 55,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "Clarify that `modRoots !\u003d nil` implies `len(modRoots) \u003e 0`, or switch from `modRoots !\u003d nil` to `len(modRoots) \u003e 0` throughout.",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "938e5a93_74b6c860",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 55,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "I\u0027m not sure exactly what this TODO means; could you clarify?\n\n(Does this mean to move users of this variable over to the MainModules variable instead?)",
      "range": {
        "startLine": 55,
        "startChar": 71,
        "endLine": 55,
        "endChar": 104
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65b37ee4_84ee585f",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 60,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "A comment for this field would be helpful.\n\nAre the paths ordinary module paths, or filesystem paths like in replace directives? Are the versions real versions, or empty strings, or some mix of the two?\n\nAre the paths unique, or can there be duplicate paths with different versions?",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d289c29_8d9c64ab",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 62,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "Please add a comment. (Without reading further, I assume this maps each module in versions to its absolute filesystem path?)",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "febb3433_50ddf97c",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 72,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "This seems like a lot of parallel data indexed by module.Version. Would it make sense to instead structure this data as a single map with struct (or pointer-to-struct) values?\n\nIs it important to retain the original order of the modules? If not, perhaps this whole type can be collapsed to a map:\n\n\ttype MainModule struct {\n\t\tPath string   // if we use a map, is this actually needed?\n\t\tPrefix string   // normally equal to Path, but empty for the \"std\" module in GOROOT/src\n\t\tRoot string   // absolute filesystem path\n\t\tInGorootSrc bool  // is this module within GOROOT/src? The \"std\" module is special there but not otherwise.\n\t\t\n\t\t// Will we also need a per-module *modfile.File and *modFileIndex, or do those only matter if we\u0027re making a change to a single module?\n\t}\n\n\t// MainModules maps the module path for each main module to information about that module.\n\tvar MainModules map[string]*MainModule\n\t\nOr, if we want to preserve flexibility (and/or maintain a consistent order of module paths, instead of relying on nondeterministic map iteration), perhaps keep it wrapped in a struct but with one internal map instead of many.",
      "range": {
        "startLine": 69,
        "startChar": 0,
        "endLine": 72,
        "endChar": 0
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fe111ac_9cd6b6eb",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 83,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "This seems allocation-heavy for something I expect most callers won\u0027t mutate.\n\nWould it make sense to instead maintain an invariant that the versions slice has cap \u003d\u003d length (so that it is safe to append to) and return it directly, with a requirement that callers not modify the returned slice?",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 10
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4943d86_e384e7e9",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 140,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "s/Size/Len/ (since `mainModules` is container-like)",
      "range": {
        "startLine": 140,
        "startChar": 24,
        "endLine": 140,
        "endChar": 28
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66dd0eb4_e000b302",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 144,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "It seems awkward to have an exported variable of unexported type, especially since `go doc` refuses to display documentation for unexported types by default.\n\nCan we instead use a set of names that would allow us to export both? (Perhaps `MainModules` for the variable and `MainModuleSet` for the type?)",
      "range": {
        "startLine": 143,
        "startChar": 0,
        "endLine": 144,
        "endChar": 27
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a90d94f9_aa5ea17c",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 361,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "Probably this check should be hoisted into the findModuleRoots function: we should ignore /tmp/go.work and /tmp/go.mod when searching for the roots, but if we find go.work elsewhere and it lists /tmp/go.work explicitly that\u0027s probably allowable.",
      "range": {
        "startLine": 360,
        "startChar": 0,
        "endLine": 361,
        "endChar": 53
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b015d79a_e792bf7e",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 381,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "Don\u0027t update this comment until you address the TODO. (This really does return the singular root of the main module.)",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da0c97b3_a6053ca8",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 515,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "I\u0027m a bit confused. It looks like we only ever call initTarget with a single main module — how do we know that len(modRoots) \u003d\u003d 1 here?",
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86ae142b_fa6b35ec",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 696,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "This function seems misnamed now, and it was always a little awkward anyway (since it set multiple global variables).\n\nNow that it populates only a single variable, perhaps move the assignment to the caller side and rename it to be a constructor function?\n\n\tMainModules \u003d makeMainModules(ms, rootDirs)",
      "range": {
        "startLine": 696,
        "startChar": 3,
        "endLine": 696,
        "endChar": 50
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a1a4ae4_e6a9f129",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 1090,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "I wonder if it would be clearer to maintain the invariant that every module within MainModules has a non-empty module root, and MainModules.Size() \u003d\u003d 0 when we are in module mode but not inside any module.\n\nWe might have to update some tests for that, but over the long term I think it will be less confusing than maintaining a degenerate (rootless) \"command-line-arguments\" module.",
      "range": {
        "startLine": 1090,
        "startChar": 4,
        "endLine": 1090,
        "endChar": 81
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45a323d5_333384b4",
        "filename": "src/cmd/go/internal/modload/init.go",
        "patchSetId": 18
      },
      "lineNbr": 1090,
      "author": {
        "id": 6365
      },
      "writtenOn": "2021-06-30T19:23:15Z",
      "side": 1,
      "message": "(naming / API)\n\nFrom the name, I would expect MainModules.HasModRoot to report whether any of the main modules has the argument as its module root, but instead it reports whether the named main module has a root.\n\nI think this would be clearer if we factor out a `MainModule` struct as suggested above. Then the call\n\n\tMainModules.HasModRoot(path)\n\ncould be written something like\n\n\tMainModules.Get(path).modRoot !\u003d \"\"\n\nwhich parses a lot more clearly for me.",
      "range": {
        "startLine": 1090,
        "startChar": 32,
        "endLine": 1090,
        "endChar": 81
      },
      "revId": "92e764b6a368c97a28c7c91e46c6fb9e78f09fc7",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}