{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "42acda15_44671c8f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 56198
      },
      "writtenOn": "2024-05-10T03:05:54Z",
      "side": 1,
      "message": "Apologies for the delay and thank you for the review. I\u0027ve updated the code in bytes.IndexRune as per your suggestion and have also updated the code in the strings.IndexRune to match that of the bytes package. \n\nOne question that I have is: this PR originally had both {bytes,strings}.Index use IndexRune when the needle was a single rune, but now that strings.Index has been moved to the stringslite package we cannot call IndexRune without both moving IndexRune to the stringslite package and updating the deps test to allow stringslite to import \"unicode/utf8\" or implementing utf8.ValidRune in stringslite - I\u0027m wondering if any of these approaches are viable or if we should simply not have Index call IndexRune when the needle is a single rune (my only concern is that this would introduce a performance discrepency)?",
      "revId": "ea5a3be54f17be39c9c5c1b0a8b12d5234ac7036",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c44536c0_2d0b91e6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-10T21:42:03Z",
      "side": 1,
      "message": "I think for now let\u0027s just not have strings.Index call strings.IndexRune.",
      "parentUuid": "42acda15_44671c8f",
      "revId": "ea5a3be54f17be39c9c5c1b0a8b12d5234ac7036",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5108373_a2adcd4f",
        "filename": "src/bytes/bytes.go",
        "patchSetId": 9
      },
      "lineNbr": 1354,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-10T21:42:03Z",
      "side": 1,
      "message": "Should this be MaxLen rather than MaxBruteForce?  That would seem to match the switch.\n\nBut also I wonder whether we should just move the n \u003c\u003d bytealg.MaxLen out of the switch.  Then we don\u0027t need to duplicate the code that calls IndexRune.",
      "revId": "ea5a3be54f17be39c9c5c1b0a8b12d5234ac7036",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "649d5749_0b79d050",
        "filename": "src/bytes/bytes.go",
        "patchSetId": 9
      },
      "lineNbr": 1354,
      "author": {
        "id": 56198
      },
      "writtenOn": "2024-05-10T22:47:20Z",
      "side": 1,
      "message": "I chose MaxBruteForce here since it is a constant and we want this code to be elided on platforms that have bytealg.Index (MaxBruteForce and MaxLen are zero if bytealg.Index is not implemented). \n\nAs for moving MaxLen out of the switch that would complicate the logic for switching to bytealg.Index or Rabin-Karp when we have too many failures since that is based on two factors: the length of the needle; and if bytealg.Index is implemented for the current arch. Additionally, we want to use bytealg.Index if both the haystack and needle are small (and bytealg.Index is implemented).\n\nThat said, it is possible and below is a quickly put together example of what it might look to move bytealg.MaxLen out of the switch:\n\n```\n// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\nfunc Index(s, sep []byte) int {\n\tn :\u003d len(sep)\n\tswitch {\n\tcase n \u003d\u003d 0:\n\t\treturn 0\n\tcase n \u003d\u003d 1:\n\t\treturn IndexByte(s, sep[0])\n\tcase n \u003d\u003d len(s):\n\t\tif Equal(sep, s) {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n \u003e len(s):\n\t\treturn -1\n\t}\n\t// Use brute force when s and sep both are small\n\tif n \u003c\u003d bytealg.MaxLen \u0026\u0026 len(s) \u003c\u003d bytealg.MaxBruteForce {\n\t\treturn bytealg.Index(s, sep)\n\t}\n\tif n \u003c\u003d utf8.UTFMax \u0026\u0026 sep[0] \u003e\u003d utf8.RuneSelf {\n\t\t// Use optimized IndexRune if sep consists of a single valid rune.\n\t\tif r, sz :\u003d utf8.DecodeRune(sep); sz \u003d\u003d n {\n\t\t\treturn IndexRune(s, r)\n\t\t}\n\t}\n\tc0 :\u003d sep[0]\n\tc1 :\u003d sep[1]\n\ti :\u003d 0\n\tt :\u003d len(s) - n + 1\n\tfails :\u003d 0\n\tfor i \u003c t {\n\t\tif s[i] !\u003d c0 {\n\t\t\t// IndexByte is faster than bytealg.Index, so use it as long as\n\t\t\t// we\u0027re not getting lots of false positives.\n\t\t\to :\u003d IndexByte(s[i+1:t], c0)\n\t\t\tif o \u003c 0 {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\ti +\u003d o + 1\n\t\t}\n\t\tif s[i+1] \u003d\u003d c1 \u0026\u0026 Equal(s[i:i+n], sep) {\n\t\t\treturn i\n\t\t}\n\t\tfails++\n\t\ti++\n\t\t// Switch to bytealg.Index when IndexByte produces too many false positives.\n\t\tif (bytealg.MaxBruteForce !\u003d 0 \u0026\u0026 n \u003c bytealg.MaxLen \u0026\u0026 fails \u003e bytealg.Cutover(i)) ||\n\t\t\t(fails \u003e\u003d 4+i\u003e\u003e4 \u0026\u0026 i \u003c t) {\n\t\t\tvar j int\n\t\t\tif bytealg.MaxBruteForce !\u003d 0 \u0026\u0026 n \u003c bytealg.MaxLen {\n\t\t\t\tj \u003d bytealg.Index(s[i:], sep)\n\t\t\t} else {\n\t\t\t\tj \u003d bytealg.IndexRabinKarp(s[i:], sep)\n\t\t\t}\n\t\t\tif j \u003e\u003d 0 {\n\t\t\t\treturn j + i\n\t\t\t}\n\t\t\treturn -1\n\t\t}\n\t}\n\treturn -1\n}\n```",
      "parentUuid": "c5108373_a2adcd4f",
      "revId": "ea5a3be54f17be39c9c5c1b0a8b12d5234ac7036",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5f355d0_e4aecd70",
        "filename": "src/bytes/bytes.go",
        "patchSetId": 9
      },
      "lineNbr": 1354,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-05-10T23:47:34Z",
      "side": 1,
      "message": "Thanks.  Honestly that new code seems better to me.  The cost of the more complex fails condition seems outweighed by not having to duplicate the loop.",
      "parentUuid": "649d5749_0b79d050",
      "revId": "ea5a3be54f17be39c9c5c1b0a8b12d5234ac7036",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "736eff44_6dd03fc1",
        "filename": "src/bytes/bytes.go",
        "patchSetId": 9
      },
      "lineNbr": 1354,
      "author": {
        "id": 56198
      },
      "writtenOn": "2024-05-16T04:20:54Z",
      "side": 1,
      "message": "SGTM and I cleaned up the above and updated bytes/byes.Index. \n\nI ended up splitting up the fails condition into an `if..else if` so that `bytealg.Cutover` takes precedence, when implemented and the needle is small since it\u0027s possible that on systems with `bytealg.Index(String)?` we might want to fallback to it sooner than when only Rabin-Karp (this matches the original behavior). N.B. using a nested `fails \u003e bytealg.Cutover(i)` check under the `if n \u003c\u003d bytealg.MaxLen` check was about ~5-6% faster than checking if `n \u003e bytealg.MaxLen` in the `else if`.",
      "parentUuid": "b5f355d0_e4aecd70",
      "revId": "ea5a3be54f17be39c9c5c1b0a8b12d5234ac7036",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "856e3818_302a3887",
        "filename": "src/bytes/bytes.go",
        "patchSetId": 9
      },
      "lineNbr": 1354,
      "author": {
        "id": 5206
      },
      "writtenOn": "2024-07-10T20:29:20Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "736eff44_6dd03fc1",
      "revId": "ea5a3be54f17be39c9c5c1b0a8b12d5234ac7036",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}